{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Starlite is a powerful, flexible, highly performant and opinionated ASGI framework, offering first class typing support and a full Pydantic integration. The Starlite framework supports plugins , ships with dependency injection , security primitives , OpenAPI specifications-generation , MessagePack support \u2013 among other common API-framework components such as middleware . Installation pip install starlite Extras Brotli Compression Middleware : pip install starlite [ brotli ] Client-side sessions pip install starlite [ cryptography ] Server-side sessions with redis / Redis caching : pip install starlite [ redis ] Server-side sessions with memcached / memcached caching : pip install starlite [ memcached ] Picologging : pip install starlite [ picologging ] StructLog : pip install starlite [ structlog ] OpenTelemetry : pip install starlite [ openetelemetry ] CLI : pip install starlite [ cli ] Standard installation (includes CLI, picologging and Jinja2 templating): pip install starlite [ standard ] All extras: pip install starlite [ full ] Minimal Example Define your data model using pydantic or any library based on it (for example ormar, beanie, SQLModel): my_app/models/user.py from pydantic import BaseModel , UUID4 class User ( BaseModel ): first_name : str last_name : str id : UUID4 You can also use dataclasses (standard library and Pydantic), TypedDict s or msgspec.Struct s : my_app/models/user.py from uuid import UUID # from pydantic.dataclasses import dataclass from dataclasses import dataclass @dataclass class User : first_name : str last_name : str id : UUID Define a Controller for your data model: Python 3.8+ Python 3.9+ my_app/controllers/user.py from typing import List from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> List [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partial_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> None : ... my_app/controllers/user.py from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> list [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partial_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> None : ... When instantiating your app, import your controller into your application's entry-point and pass it to Starlite: my_app/main.py from starlite import Starlite from my_app.controllers.user import UserController app = Starlite ( route_handlers = [ UserController ]) To run your application , use an ASGI server such as uvicorn : uvicorn my_app.main:app --reload Example Applications starlite-pg-redis-docker : In addition to Starlite, this demonstrates a pattern of application modularity, SQLAlchemy 2.0 ORM, Redis cache connectivity, and more. Like all Starlite projects, this application is open to contributions, big and small. starlite-hello-world : A bare-minimum application setup. Great for testing and POC work. About Starlite Starlite is a community-driven project. This means not a single author, but rather a core team of maintainers is leading the project, supported by a community of contributors. Starlite currently has 5 maintainers and is being very actively developed. Starlite draws inspiration from NestJS - a contemporary TypeScript framework - which places opinions and patterns at its core. While still allowing for function-based endpoints , Starlite seeks to build on Python's powerful and versatile OOP, by placing class-based controllers at its core. Starlite is not a microframework. Unlike frameworks such as FastAPI, Starlette or Flask, Starlite includes a lot of functionalities out of the box needed for a typical modern web application, such as ORM integration, client- and server-side sessions, caching, OpenTelemetry integration and many more. It's not aiming to be \"the next Django\" (for example, it will never feature its own ORM), but its scope is not micro either. Comparison with other frameworks Starlite FastAPI Starlette Sanic Quart OpenAPI Automatic API documentation Swagger, ReDoc, Stoplight Elements Swagger, ReDoc Data validation Dependency Injection Class based routing (Through extension) ORM integration SQLAlchemy, Tortoise, Piccolo (Through extension) Templating Jinja, Mako Jinja Jinja Jinja Jinja MessagePack CORS (Through extension) CSRF Rate-limiting (Through extension) JWT Sessions Client-side Client-side Client-side Authentication JWT / Session based Caching Project Governance From its inception, Starlite was envisaged as a community driven project. We encourage users to become involved with the project - feel free to open issues, chime in on discussions, review pull requests and of course - contribute code. The project is led by a group of maintainers. You can see the list of maintainers in the pyproject.toml file. Additionally, substantial contributors are invited to be members of the starlite-api organization. Our aim is to increase the number of maintainers and have at least 5 active maintainers - this will ensure the long term stability and growth of Starlite in the long run. Contributors who show commitment, contribute great code and show a willingness to become maintainers will be invited to do so. So really feel free to contribute and propose yourself as a maintainer once you contribute substantially. Contribution Guide Any and all contributions and involvement with the project is welcome. The easiest way to begin contributing is to check out the open issues - and reach out on our discord server or Matrix space. License The MIT License (MIT) Copyright (c) 2021, 2022 Starlite-API Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"Intro"},{"location":"#_1","text":"Starlite is a powerful, flexible, highly performant and opinionated ASGI framework, offering first class typing support and a full Pydantic integration. The Starlite framework supports plugins , ships with dependency injection , security primitives , OpenAPI specifications-generation , MessagePack support \u2013 among other common API-framework components such as middleware .","title":""},{"location":"#installation","text":"pip install starlite Extras Brotli Compression Middleware : pip install starlite [ brotli ] Client-side sessions pip install starlite [ cryptography ] Server-side sessions with redis / Redis caching : pip install starlite [ redis ] Server-side sessions with memcached / memcached caching : pip install starlite [ memcached ] Picologging : pip install starlite [ picologging ] StructLog : pip install starlite [ structlog ] OpenTelemetry : pip install starlite [ openetelemetry ] CLI : pip install starlite [ cli ] Standard installation (includes CLI, picologging and Jinja2 templating): pip install starlite [ standard ] All extras: pip install starlite [ full ]","title":"Installation"},{"location":"#minimal-example","text":"Define your data model using pydantic or any library based on it (for example ormar, beanie, SQLModel): my_app/models/user.py from pydantic import BaseModel , UUID4 class User ( BaseModel ): first_name : str last_name : str id : UUID4 You can also use dataclasses (standard library and Pydantic), TypedDict s or msgspec.Struct s : my_app/models/user.py from uuid import UUID # from pydantic.dataclasses import dataclass from dataclasses import dataclass @dataclass class User : first_name : str last_name : str id : UUID Define a Controller for your data model: Python 3.8+ Python 3.9+ my_app/controllers/user.py from typing import List from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> List [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partial_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> None : ... my_app/controllers/user.py from pydantic import UUID4 from starlite import Controller , Partial , get , post , put , patch , delete from my_app.models import User class UserController ( Controller ): path = \"/users\" @post () async def create_user ( self , data : User ) -> User : ... @get () async def list_users ( self ) -> list [ User ]: ... @patch ( path = \"/{user_id:uuid}\" ) async def partial_update_user ( self , user_id : UUID4 , data : Partial [ User ]) -> User : ... @put ( path = \"/{user_id:uuid}\" ) async def update_user ( self , user_id : UUID4 , data : User ) -> User : ... @get ( path = \"/{user_id:uuid}\" ) async def get_user ( self , user_id : UUID4 ) -> User : ... @delete ( path = \"/{user_id:uuid}\" ) async def delete_user ( self , user_id : UUID4 ) -> None : ... When instantiating your app, import your controller into your application's entry-point and pass it to Starlite: my_app/main.py from starlite import Starlite from my_app.controllers.user import UserController app = Starlite ( route_handlers = [ UserController ]) To run your application , use an ASGI server such as uvicorn : uvicorn my_app.main:app --reload","title":"Minimal Example"},{"location":"#example-applications","text":"starlite-pg-redis-docker : In addition to Starlite, this demonstrates a pattern of application modularity, SQLAlchemy 2.0 ORM, Redis cache connectivity, and more. Like all Starlite projects, this application is open to contributions, big and small. starlite-hello-world : A bare-minimum application setup. Great for testing and POC work.","title":"Example Applications"},{"location":"#about-starlite","text":"Starlite is a community-driven project. This means not a single author, but rather a core team of maintainers is leading the project, supported by a community of contributors. Starlite currently has 5 maintainers and is being very actively developed. Starlite draws inspiration from NestJS - a contemporary TypeScript framework - which places opinions and patterns at its core. While still allowing for function-based endpoints , Starlite seeks to build on Python's powerful and versatile OOP, by placing class-based controllers at its core. Starlite is not a microframework. Unlike frameworks such as FastAPI, Starlette or Flask, Starlite includes a lot of functionalities out of the box needed for a typical modern web application, such as ORM integration, client- and server-side sessions, caching, OpenTelemetry integration and many more. It's not aiming to be \"the next Django\" (for example, it will never feature its own ORM), but its scope is not micro either.","title":"About Starlite"},{"location":"#comparison-with-other-frameworks","text":"Starlite FastAPI Starlette Sanic Quart OpenAPI Automatic API documentation Swagger, ReDoc, Stoplight Elements Swagger, ReDoc Data validation Dependency Injection Class based routing (Through extension) ORM integration SQLAlchemy, Tortoise, Piccolo (Through extension) Templating Jinja, Mako Jinja Jinja Jinja Jinja MessagePack CORS (Through extension) CSRF Rate-limiting (Through extension) JWT Sessions Client-side Client-side Client-side Authentication JWT / Session based Caching","title":"Comparison with other frameworks"},{"location":"#project-governance","text":"From its inception, Starlite was envisaged as a community driven project. We encourage users to become involved with the project - feel free to open issues, chime in on discussions, review pull requests and of course - contribute code. The project is led by a group of maintainers. You can see the list of maintainers in the pyproject.toml file. Additionally, substantial contributors are invited to be members of the starlite-api organization. Our aim is to increase the number of maintainers and have at least 5 active maintainers - this will ensure the long term stability and growth of Starlite in the long run. Contributors who show commitment, contribute great code and show a willingness to become maintainers will be invited to do so. So really feel free to contribute and propose yourself as a maintainer once you contribute substantially.","title":"Project Governance"},{"location":"#contribution-guide","text":"Any and all contributions and involvement with the project is welcome. The easiest way to begin contributing is to check out the open issues - and reach out on our discord server or Matrix space.","title":"Contribution Guide"},{"location":"#license","text":"The MIT License (MIT) Copyright (c) 2021, 2022 Starlite-API Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","title":"License"},{"location":"benchmarks/","text":"Benchmarks Methodology Benchmarking is done using the bomardier benchmarking tool. Benchmarks are run on a dedicated machine, with a base Debian 11 installation. Each framework is contained within its own docker container, running on a dedicated CPU core (using the cset shield command and the --cpuset-cpus option for docker) Tests for the frameworks are written to make them as comparable as possible while completing the same tasks (you can see them here ) Each application is run using uvicorn with one worker and uvloop Test data has been randomly generated and is being imported from a shared module Results Info If a result is missing for a specific framework that means either It does not support this functionality (this will be mentioned in the test description) More than 0.1% of responses were dropped / erroneous JSON Serializing a d dictionary into JSON Files Path and query parameter handling All responses return \"No Content\" No params: No path parameters Path params: Single path parameter, coerced into an integer Query params: Single query parameter, coerced into an integer Mixed params: A path and a query parameters, coerced into integers Dependency injection (not supported by Starlette ) Resolving 3 nested synchronous dependencies Resolving 3 nested asynchronous dependencies (only supported by Starlite and FastAPI ) Resolving 3 nested synchronous, and 3 nested asynchronous dependencies (only supported by Starlite and FastAPI ) Modifying responses All responses return \"No Content\" Plaintext Interpreting the results An interpretation of these results should be approached with caution, as is the case for nearly all benchmarks. A high score in a test does not necessarily translate to high performance of your application in your use case. For almost any test you can probably write an app that performs better or worse at a comparable task in your scenario . While trying to design the tests in a way that simulate somewhat realistic scenarios, they can never give an exact representation of how a real world application, where, aside from the workload, many other factors come into play. These tests were mainly written to be used internally for starlite development, to help us locate the source of some performance regression we were experiencing.","title":"Benchmarks"},{"location":"benchmarks/#benchmarks","text":"","title":"Benchmarks"},{"location":"benchmarks/#methodology","text":"Benchmarking is done using the bomardier benchmarking tool. Benchmarks are run on a dedicated machine, with a base Debian 11 installation. Each framework is contained within its own docker container, running on a dedicated CPU core (using the cset shield command and the --cpuset-cpus option for docker) Tests for the frameworks are written to make them as comparable as possible while completing the same tasks (you can see them here ) Each application is run using uvicorn with one worker and uvloop Test data has been randomly generated and is being imported from a shared module","title":"Methodology"},{"location":"benchmarks/#results","text":"Info If a result is missing for a specific framework that means either It does not support this functionality (this will be mentioned in the test description) More than 0.1% of responses were dropped / erroneous","title":"Results"},{"location":"benchmarks/#json","text":"Serializing a d dictionary into JSON","title":"JSON"},{"location":"benchmarks/#files","text":"","title":"Files"},{"location":"benchmarks/#path-and-query-parameter-handling","text":"All responses return \"No Content\" No params: No path parameters Path params: Single path parameter, coerced into an integer Query params: Single query parameter, coerced into an integer Mixed params: A path and a query parameters, coerced into integers","title":"Path and query parameter handling"},{"location":"benchmarks/#dependency-injection","text":"(not supported by Starlette ) Resolving 3 nested synchronous dependencies Resolving 3 nested asynchronous dependencies (only supported by Starlite and FastAPI ) Resolving 3 nested synchronous, and 3 nested asynchronous dependencies (only supported by Starlite and FastAPI )","title":"Dependency injection"},{"location":"benchmarks/#modifying-responses","text":"All responses return \"No Content\"","title":"Modifying responses"},{"location":"benchmarks/#plaintext","text":"","title":"Plaintext"},{"location":"benchmarks/#interpreting-the-results","text":"An interpretation of these results should be approached with caution, as is the case for nearly all benchmarks. A high score in a test does not necessarily translate to high performance of your application in your use case. For almost any test you can probably write an app that performs better or worse at a comparable task in your scenario . While trying to design the tests in a way that simulate somewhat realistic scenarios, they can never give an exact representation of how a real world application, where, aside from the workload, many other factors come into play. These tests were mainly written to be used internally for starlite development, to help us locate the source of some performance regression we were experiencing.","title":"Interpreting the results"},{"location":"migration/","text":"Migrating to Starlite Migrating from Starlette or FastAPI to Starlite is straightforward, as they are both ASGI frameworks and as such build on the same fundamental principles. The following sections can help to navigate a migration from either framework by introducing Starlite-equivalents to common functionalities. From Starlette / FastAPI Routing Decorators Starlite does not include any decorator as part of the Router or Starlite instances. Instead, all routes are declared using route handlers , either as standalone functions or controller methods. The handler can then be registered on an application or router instance. FastAPI Starlette Starlite from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def index () -> dict [ str , str ]: ... from starlette.applications import Starlette from starlette.routing import Route async def index ( request ): ... routes = [ Route ( \"/\" , endpoint = index )] app = Starlette ( routes = routes ) from starlite import Starlite , get @get ( \"/\" ) async def index () -> dict [ str , str ]: ... app = Starlite ([ get ]) Learn more To learn more about registering routes, check out this chapter in the documentation: registering routes Routers and Routes There are a few key differences between Starlite's and Starlette's Router class: The Starlite version is not an ASGI app The Starlite version does not include decorators: Use route handlers . The Starlite version does not support lifecycle hooks: Those have to be handled on the application layer. See lifecycle hooks If you are using Starlette's Route s, you will need to replace these with route handlers . Host based routing Host based routing class is intentionally unsupported. If your application relies on Host you will have to separate the logic into different services and handle this part of request dispatching with a proxy server like nginx or traefik . Dependency Injection The Starlite dependency injection system is different from the one used by FastAPI. You can read about it in the dependency injection section of the documentation. In FastAPI you declare dependencies either as a list of functions passed to the Router or FastAPI instances, or as a default function argument value wrapped in an instance of the Depends class. In Starlite dependencies are always declared using a dictionary with a string key and the value wrapped in an instance of the Provide class. This also allows to transparently override dependencies on every level of the application, and to easily access dependencies from higher levels. FastAPI Starlite from fastapi import FastAPI , Depends , APIRouter async def route_dependency () -> bool : ... async def nested_dependency () -> str : ... async def router_dependency () -> int : ... async def app_dependency ( data : str = Depends ( nested_dependency )) -> int : ... router = APIRouter ( dependencies = [ Depends ( router_dependency )]) app = FastAPI ( dependencies = [ Depends ( nested_dependency )]) app . include_router ( router ) @app . get ( \"/\" ) async def handler ( val_route : bool = Depends ( route_dependency ), val_router : int = Depends ( router_dependency ), val_nested : str = Depends ( nested_dependency ), val_app : int = Depends ( app_dependency ), ) -> None : ... from starlite import Starlite , Provide , get , Router async def route_dependency () -> bool : ... async def nested_dependency () -> str : ... async def router_dependency () -> int : ... async def app_dependency ( nested : str ) -> int : ... @get ( \"/\" , dependencies = { \"val_route\" : Provide ( route_dependency )}) async def handler ( val_route : bool , val_router : int , val_nested : str , val_app : int ) -> None : ... router = Router ( dependencies = { \"val_router\" : Provide ( router_dependency )}) app = Starlite ( route_handlers = [ handler ], dependencies = { \"val_app\" : Provide ( app_dependency ), \"val_nested\" : Provide ( nested_dependency ), }, ) Learn more To learn more about dependency injection, check out this chapter in the documentation: Dependency injection Authentication FastAPI promotes a pattern of using dependency injection for authentication. You can do the same in Starlite, but the preferred way of handling this is extending AbstractAuthenticationMiddleware . FastAPI Starlite from fastapi import FastAPI , Depends , Request async def authenticate ( request : Request ) -> None : ... app = FastAPI () @app . get ( \"/\" , dependencies = [ Depends ( authenticate )]) async def index () -> dict [ str , str ]: ... from starlite import Starlite , get , ASGIConnection , BaseRouteHandler async def authenticate ( connection : ASGIConnection , route_handler : BaseRouteHandler ) -> None : ... @get ( \"/\" , guards = [ authenticate ]) async def index () -> dict [ str , str ]: ... Learn more To learn more about security and authentication, check out this chapter in the documentation: Security Dependency overrides While FastAPI includes a mechanism to override dependencies on an existing application object, Starlite promotes architecular solutions to the issue this is aimed to solve. Therefore, overriding dependencies in Starlite is strictly supported at definition time, i.e. when you're defining handlers, controllers, routers and applications. Dependency overrides are fundamentally the same idea as mocking and should be approached with the same caution and used sparingly instead of being the default. To achieve the same effect there are three general approaches: Structuring the application with different environments in mind. This could mean for example connecting to a different database depending on the environment, which in turn is set via and env-variable. This is sufficient and most cases and designing your application around this principle is a general good practice since it facilitates configurability and integration-testing capabilities Isolating tests for unit testing and using create_test_client Resort to mocking if none of the above approaches can be made to work Middleware Pure ASGI middleware is fully compatible, and can be used with any ASGI framework. Middlewares that make use of FastAPI/Starlette specific middleware features such as Starlette's BaseHTTPMiddleware are not compatible, but can be easily replaced by making use of AbstractMiddleware From Flask ASGI vs WSGI Flask is a WSGI framework, whereas Starlite is built using the modern ASGI standard. A key difference is that ASGI is built with async in mind. While Flask has added support for async/await , it remains synchronous at its core; The async support in Flask is limited to individual endpoints. What this means is that while you can use async def to define endpoints in Flask, they will not run concurrently - requests will still be processed one at a time. Flask handles asynchronous endpoints by creating an event loop for each request, run the endpoint function in it and then return its result. ASGI on the other hand does the exact opposite; It runs everything in a central event loop. Starlite then adds support for synchronous functions by running them in a non-blocking way on the event loop . What this means is that synchronous and asynchronous code both run concurrently. Routing Flask Starlite from flask import Flask app = Flask ( __name__ ) @app . route ( \"/\" ) def index (): return \"Index Page\" @app . route ( \"/hello\" ) def hello (): return \"Hello, World\" from starlite import Starlite , get @get ( \"/\" ) def index () -> str : return \"Index Page\" @get ( \"/hello\" ) def hello () -> str : return \"Hello, World\" app = Starlite ([ index , hello ]) Path parameters Flask Starlite from flask import Flask app = Flask ( __name__ ) @app . route ( \"/user/<username>\" ) def show_user_profile ( username ): return f \"User { username } \" @app . route ( \"/post/<int:post_id>\" ) def show_post ( post_id ): return f \"Post { post_id } \" @app . route ( \"/path/<path:subpath>\" ) def show_subpath ( subpath ): return f \"Subpath { subpath } \" from starlite import Starlite , get from pathlib import Path @get ( \"/user/{username:str}\" ) def show_user_profile ( username : str ) -> str : return f \"User { username } \" @get ( \"/post/{post_id:int}\" ) def show_post ( post_id : int ) -> str : return f \"Post { post_id } \" @get ( \"/path/{subpath:path}\" ) def show_subpath ( subpath : Path ) -> str : return f \"Subpath { subpath } \" app = Starlite ([ show_user_profile , show_post , show_subpath ]) Learn more To learn more about path parameters, check out this chapter in the documentation: Path parameters Request object In Flask, the current request can be accessed through a global request variable. In Starlite, the request can be accessed through an optional parameter in the handler function. Flask Starlite from flask import Flask , request app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): print ( request . method ) from starlite import Starlite , get , Request @get ( \"/\" ) def index ( request : Request ) -> None : print ( request . method ) Request methods Flask Starlite request.args request.query_params request.base_url request.base_url request.authorization request.auth request.cache_control request.headers.get(\"cache-control\") request.content_encoding request.headers.get(\"content-encoding\") request.content_length request.headers.get(\"content-length\") request.content_md5 - request.content_type request.content_type request.cookies request.cookies request.data request.body() request.date request.headers.get(\"date\") request.endpoint request.route_handler request.environ request.scope request.files Use UploadFile request.form request.form() , prefer Body request.get_json request.json() , prefer the data keyword argument request.headers request.headers request.host - request.host_url - request.if_match request.headers.get(\"if-match\") request.if_modified_since request.headers.get(\"if_modified_since\") request.if_none_match request.headers.get(\"if_none_match\") request.if_range request.headers.get(\"if_range\") request.if_unmodified_since request.headers.get(\"if_unmodified_since\") request.method request.method request.mimetype - request.mimetype_params - request.origin - request.path request.scope[\"path\"] request.query_string request.scope[\"query_string\"] request.range request.headers.get(\"range\") request.referrer request.headers.get(\"referrer\") request.remote_addr - request.remote_user - request.root_path request.scope[\"root_path\"] request.server request.scope[\"server\"] request.stream request.stream request.url request.url request.url_charset - request.user_agent request.headers.get(\"user-agent\") request.user_agent request.headers.get(\"user-agent\") Read more To learn more about requests,, check out these chapters in the documentation: Request data Request reference Static files Like Flask, Starlite also has capabilities for serving static files, but while Flask will automatically serve files from a static folder, this has to be configured explicitly in Starlite. from starlite import Starlite , StaticFilesConfig app = Starlite ( [], static_files_config = StaticFilesConfig ( path = \"/static\" , directories = [ \"static\" ]) ) Read more To learn more about static files, check out this chapter in the documentation: Static files Templates Flask comes with the Jinja templating engine built-in. You can use Jinja with Starlite as well, but you'll need to install it explicitly. You can do by installing Starlite with pip install starlite[jinja] . In addition to Jinja, Starlite supports Mako templates as well. Flask Starlite from flask import Flask , render_template app = Flask ( __name__ ) @app . route ( \"/hello/<name>\" ) def hello ( name ): return render_template ( \"hello.html\" , name = name ) from starlite import Starlite , get , TemplateConfig , Template from starlite.contrib.jinja import JinjaTemplateEngine @get ( \"/hello/{name:str}\" ) def hello ( name : str ) -> Template : return Template ( name = \"hello.html\" , context = { \"name\" : name }) app = Starlite ( [ hello ], template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine ), ) Read more To learn more about templates, check out this chapter in the documentation: Template engines Setting cookies and headers Flask Starlite from flask import Flask , make_response app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): response = make_response ( \"hello\" ) response . set_cookie ( \"my-cookie\" , \"cookie-value\" ) response . headers [ \"my-header\" ] = \"header-value\" return response from starlite import Starlite , get , ResponseHeader , Cookie , Response @get ( \"/static\" , response_headers = { \"my-header\" : ResponseHeader ( value = \"header-value\" )}, response_cookies = [ Cookie ( \"my-cookie\" , \"cookie-value\" )], ) def static () -> str : # you can set headers and cookies when defining handlers ... @get ( \"/dynamic\" ) def dynamic () -> Response [ str ]: # or dynamically, by returning an instance of Response return Response ( \"hello\" , headers = { \"my-header\" : \"header-value\" }, cookies = [ Cookie ( \"my-cookie\" , \"cookie-value\" )], ) Read more To learn more about response headers and cookies, check out these chapters in the documentation: Response headers Response cookies Redirects For redirects, instead of redirect use Redirect : Flask Starlite from flask import Flask , redirect , url_for app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): return \"hello\" @app . get ( \"/hello\" ) def hello (): return redirect ( url_for ( \"index\" )) from starlite import Starlite , get , Redirect @get ( \"/\" ) def index () -> str : return \"hello\" @get ( \"/hello\" ) def hello () -> Redirect : return Redirect ( path = \"index\" ) app = Starlite ([ index , hello ]) Raising HTTP errors Instead of using the abort function, raise an HTTPException : Flask Starlite from flask import Flask , abort app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): abort ( 400 , \"this did not work\" ) from starlite import Starlite , get , HTTPException @get ( \"/\" ) def index () -> None : raise HTTPException ( status_code = 400 , detail = \"this did not work\" ) app = Starlite ([ index ]) Learn more To learn more about exceptions, check out this chapter in the documentation: Exceptions Setting status codes Flask Starlite from flask import Flask app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): return \"not found\" , 404 from starlite import Starlite , get , Response @get ( \"/static\" , status_code = 404 ) def static_status () -> str : return \"not found\" @get ( \"/dynamic\" ) def dynamic_status () -> Response [ str ]: return Response ( \"not found\" , status_code = 404 ) app = Starlite ([ static_status , dynamic_status ]) Serialization Flask uses a mix of explicit conversion (such as jsonify ) and inference (i.e. the type of the returned data) to determine how data should be serialized. Starlite instead assumes the data returned is intended to be serialized into JSON and will do so unless told otherwise. Flask Starlite from flask import Flask , Response app = Flask ( __name__ ) @app . get ( \"/json\" ) def get_json (): return { \"hello\" : \"world\" } @app . get ( \"/text\" ) def get_text (): return \"hello, world!\" @app . get ( \"/html\" ) def get_html (): return Response ( \"<strong>hello, world</strong>\" , mimetype = \"text/html\" ) from starlite import Starlite , get , MediaType @get ( \"/json\" ) def get_json () -> dict [ str , str ]: return { \"hello\" : \"world\" } @get ( \"/text\" , media_type = MediaType . TEXT ) def get_text () -> str : return \"hello, world\" @get ( \"/html\" , media_type = MediaType . HTML ) def get_html () -> str : return \"<strong>hello, world</strong>\" app = Starlite ([ get_json , get_text , get_html ]) Error handling Flask Starlite from flask import Flask from werkzeug.exceptions import HTTPException app = Flask ( __name__ ) @app . errorhandler ( HTTPException ) def handle_exception ( e ): ... from starlite import Starlite , HTTPException , Request , Response def handle_exception ( request : Request , exception : Exception ) -> Response : ... app = Starlite ([], exception_handlers = { HTTPException : handle_exception }) Learn more To learn more about exception handling, check out this chapter in the documentation: Exception handling","title":"Migrating to Starlite"},{"location":"migration/#migrating-to-starlite","text":"Migrating from Starlette or FastAPI to Starlite is straightforward, as they are both ASGI frameworks and as such build on the same fundamental principles. The following sections can help to navigate a migration from either framework by introducing Starlite-equivalents to common functionalities.","title":"Migrating to Starlite"},{"location":"migration/#from-starlette-fastapi","text":"","title":"From Starlette / FastAPI"},{"location":"migration/#routing-decorators","text":"Starlite does not include any decorator as part of the Router or Starlite instances. Instead, all routes are declared using route handlers , either as standalone functions or controller methods. The handler can then be registered on an application or router instance. FastAPI Starlette Starlite from fastapi import FastAPI app = FastAPI () @app . get ( \"/\" ) async def index () -> dict [ str , str ]: ... from starlette.applications import Starlette from starlette.routing import Route async def index ( request ): ... routes = [ Route ( \"/\" , endpoint = index )] app = Starlette ( routes = routes ) from starlite import Starlite , get @get ( \"/\" ) async def index () -> dict [ str , str ]: ... app = Starlite ([ get ]) Learn more To learn more about registering routes, check out this chapter in the documentation: registering routes","title":"Routing Decorators"},{"location":"migration/#routers-and-routes","text":"There are a few key differences between Starlite's and Starlette's Router class: The Starlite version is not an ASGI app The Starlite version does not include decorators: Use route handlers . The Starlite version does not support lifecycle hooks: Those have to be handled on the application layer. See lifecycle hooks If you are using Starlette's Route s, you will need to replace these with route handlers .","title":"Routers and Routes"},{"location":"migration/#host-based-routing","text":"Host based routing class is intentionally unsupported. If your application relies on Host you will have to separate the logic into different services and handle this part of request dispatching with a proxy server like nginx or traefik .","title":"Host based routing"},{"location":"migration/#dependency-injection","text":"The Starlite dependency injection system is different from the one used by FastAPI. You can read about it in the dependency injection section of the documentation. In FastAPI you declare dependencies either as a list of functions passed to the Router or FastAPI instances, or as a default function argument value wrapped in an instance of the Depends class. In Starlite dependencies are always declared using a dictionary with a string key and the value wrapped in an instance of the Provide class. This also allows to transparently override dependencies on every level of the application, and to easily access dependencies from higher levels. FastAPI Starlite from fastapi import FastAPI , Depends , APIRouter async def route_dependency () -> bool : ... async def nested_dependency () -> str : ... async def router_dependency () -> int : ... async def app_dependency ( data : str = Depends ( nested_dependency )) -> int : ... router = APIRouter ( dependencies = [ Depends ( router_dependency )]) app = FastAPI ( dependencies = [ Depends ( nested_dependency )]) app . include_router ( router ) @app . get ( \"/\" ) async def handler ( val_route : bool = Depends ( route_dependency ), val_router : int = Depends ( router_dependency ), val_nested : str = Depends ( nested_dependency ), val_app : int = Depends ( app_dependency ), ) -> None : ... from starlite import Starlite , Provide , get , Router async def route_dependency () -> bool : ... async def nested_dependency () -> str : ... async def router_dependency () -> int : ... async def app_dependency ( nested : str ) -> int : ... @get ( \"/\" , dependencies = { \"val_route\" : Provide ( route_dependency )}) async def handler ( val_route : bool , val_router : int , val_nested : str , val_app : int ) -> None : ... router = Router ( dependencies = { \"val_router\" : Provide ( router_dependency )}) app = Starlite ( route_handlers = [ handler ], dependencies = { \"val_app\" : Provide ( app_dependency ), \"val_nested\" : Provide ( nested_dependency ), }, ) Learn more To learn more about dependency injection, check out this chapter in the documentation: Dependency injection","title":"Dependency Injection"},{"location":"migration/#authentication","text":"FastAPI promotes a pattern of using dependency injection for authentication. You can do the same in Starlite, but the preferred way of handling this is extending AbstractAuthenticationMiddleware . FastAPI Starlite from fastapi import FastAPI , Depends , Request async def authenticate ( request : Request ) -> None : ... app = FastAPI () @app . get ( \"/\" , dependencies = [ Depends ( authenticate )]) async def index () -> dict [ str , str ]: ... from starlite import Starlite , get , ASGIConnection , BaseRouteHandler async def authenticate ( connection : ASGIConnection , route_handler : BaseRouteHandler ) -> None : ... @get ( \"/\" , guards = [ authenticate ]) async def index () -> dict [ str , str ]: ... Learn more To learn more about security and authentication, check out this chapter in the documentation: Security","title":"Authentication"},{"location":"migration/#dependency-overrides","text":"While FastAPI includes a mechanism to override dependencies on an existing application object, Starlite promotes architecular solutions to the issue this is aimed to solve. Therefore, overriding dependencies in Starlite is strictly supported at definition time, i.e. when you're defining handlers, controllers, routers and applications. Dependency overrides are fundamentally the same idea as mocking and should be approached with the same caution and used sparingly instead of being the default. To achieve the same effect there are three general approaches: Structuring the application with different environments in mind. This could mean for example connecting to a different database depending on the environment, which in turn is set via and env-variable. This is sufficient and most cases and designing your application around this principle is a general good practice since it facilitates configurability and integration-testing capabilities Isolating tests for unit testing and using create_test_client Resort to mocking if none of the above approaches can be made to work","title":"Dependency overrides"},{"location":"migration/#middleware","text":"Pure ASGI middleware is fully compatible, and can be used with any ASGI framework. Middlewares that make use of FastAPI/Starlette specific middleware features such as Starlette's BaseHTTPMiddleware are not compatible, but can be easily replaced by making use of AbstractMiddleware","title":"Middleware"},{"location":"migration/#from-flask","text":"","title":"From Flask"},{"location":"migration/#asgi-vs-wsgi","text":"Flask is a WSGI framework, whereas Starlite is built using the modern ASGI standard. A key difference is that ASGI is built with async in mind. While Flask has added support for async/await , it remains synchronous at its core; The async support in Flask is limited to individual endpoints. What this means is that while you can use async def to define endpoints in Flask, they will not run concurrently - requests will still be processed one at a time. Flask handles asynchronous endpoints by creating an event loop for each request, run the endpoint function in it and then return its result. ASGI on the other hand does the exact opposite; It runs everything in a central event loop. Starlite then adds support for synchronous functions by running them in a non-blocking way on the event loop . What this means is that synchronous and asynchronous code both run concurrently.","title":"ASGI vs WSGI"},{"location":"migration/#routing","text":"Flask Starlite from flask import Flask app = Flask ( __name__ ) @app . route ( \"/\" ) def index (): return \"Index Page\" @app . route ( \"/hello\" ) def hello (): return \"Hello, World\" from starlite import Starlite , get @get ( \"/\" ) def index () -> str : return \"Index Page\" @get ( \"/hello\" ) def hello () -> str : return \"Hello, World\" app = Starlite ([ index , hello ])","title":"Routing"},{"location":"migration/#path-parameters","text":"Flask Starlite from flask import Flask app = Flask ( __name__ ) @app . route ( \"/user/<username>\" ) def show_user_profile ( username ): return f \"User { username } \" @app . route ( \"/post/<int:post_id>\" ) def show_post ( post_id ): return f \"Post { post_id } \" @app . route ( \"/path/<path:subpath>\" ) def show_subpath ( subpath ): return f \"Subpath { subpath } \" from starlite import Starlite , get from pathlib import Path @get ( \"/user/{username:str}\" ) def show_user_profile ( username : str ) -> str : return f \"User { username } \" @get ( \"/post/{post_id:int}\" ) def show_post ( post_id : int ) -> str : return f \"Post { post_id } \" @get ( \"/path/{subpath:path}\" ) def show_subpath ( subpath : Path ) -> str : return f \"Subpath { subpath } \" app = Starlite ([ show_user_profile , show_post , show_subpath ]) Learn more To learn more about path parameters, check out this chapter in the documentation: Path parameters","title":"Path parameters"},{"location":"migration/#request-object","text":"In Flask, the current request can be accessed through a global request variable. In Starlite, the request can be accessed through an optional parameter in the handler function. Flask Starlite from flask import Flask , request app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): print ( request . method ) from starlite import Starlite , get , Request @get ( \"/\" ) def index ( request : Request ) -> None : print ( request . method )","title":"Request object"},{"location":"migration/#request-methods","text":"Flask Starlite request.args request.query_params request.base_url request.base_url request.authorization request.auth request.cache_control request.headers.get(\"cache-control\") request.content_encoding request.headers.get(\"content-encoding\") request.content_length request.headers.get(\"content-length\") request.content_md5 - request.content_type request.content_type request.cookies request.cookies request.data request.body() request.date request.headers.get(\"date\") request.endpoint request.route_handler request.environ request.scope request.files Use UploadFile request.form request.form() , prefer Body request.get_json request.json() , prefer the data keyword argument request.headers request.headers request.host - request.host_url - request.if_match request.headers.get(\"if-match\") request.if_modified_since request.headers.get(\"if_modified_since\") request.if_none_match request.headers.get(\"if_none_match\") request.if_range request.headers.get(\"if_range\") request.if_unmodified_since request.headers.get(\"if_unmodified_since\") request.method request.method request.mimetype - request.mimetype_params - request.origin - request.path request.scope[\"path\"] request.query_string request.scope[\"query_string\"] request.range request.headers.get(\"range\") request.referrer request.headers.get(\"referrer\") request.remote_addr - request.remote_user - request.root_path request.scope[\"root_path\"] request.server request.scope[\"server\"] request.stream request.stream request.url request.url request.url_charset - request.user_agent request.headers.get(\"user-agent\") request.user_agent request.headers.get(\"user-agent\") Read more To learn more about requests,, check out these chapters in the documentation: Request data Request reference","title":"Request methods"},{"location":"migration/#static-files","text":"Like Flask, Starlite also has capabilities for serving static files, but while Flask will automatically serve files from a static folder, this has to be configured explicitly in Starlite. from starlite import Starlite , StaticFilesConfig app = Starlite ( [], static_files_config = StaticFilesConfig ( path = \"/static\" , directories = [ \"static\" ]) ) Read more To learn more about static files, check out this chapter in the documentation: Static files","title":"Static files"},{"location":"migration/#templates","text":"Flask comes with the Jinja templating engine built-in. You can use Jinja with Starlite as well, but you'll need to install it explicitly. You can do by installing Starlite with pip install starlite[jinja] . In addition to Jinja, Starlite supports Mako templates as well. Flask Starlite from flask import Flask , render_template app = Flask ( __name__ ) @app . route ( \"/hello/<name>\" ) def hello ( name ): return render_template ( \"hello.html\" , name = name ) from starlite import Starlite , get , TemplateConfig , Template from starlite.contrib.jinja import JinjaTemplateEngine @get ( \"/hello/{name:str}\" ) def hello ( name : str ) -> Template : return Template ( name = \"hello.html\" , context = { \"name\" : name }) app = Starlite ( [ hello ], template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine ), ) Read more To learn more about templates, check out this chapter in the documentation: Template engines","title":"Templates"},{"location":"migration/#setting-cookies-and-headers","text":"Flask Starlite from flask import Flask , make_response app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): response = make_response ( \"hello\" ) response . set_cookie ( \"my-cookie\" , \"cookie-value\" ) response . headers [ \"my-header\" ] = \"header-value\" return response from starlite import Starlite , get , ResponseHeader , Cookie , Response @get ( \"/static\" , response_headers = { \"my-header\" : ResponseHeader ( value = \"header-value\" )}, response_cookies = [ Cookie ( \"my-cookie\" , \"cookie-value\" )], ) def static () -> str : # you can set headers and cookies when defining handlers ... @get ( \"/dynamic\" ) def dynamic () -> Response [ str ]: # or dynamically, by returning an instance of Response return Response ( \"hello\" , headers = { \"my-header\" : \"header-value\" }, cookies = [ Cookie ( \"my-cookie\" , \"cookie-value\" )], ) Read more To learn more about response headers and cookies, check out these chapters in the documentation: Response headers Response cookies","title":"Setting cookies and headers"},{"location":"migration/#redirects","text":"For redirects, instead of redirect use Redirect : Flask Starlite from flask import Flask , redirect , url_for app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): return \"hello\" @app . get ( \"/hello\" ) def hello (): return redirect ( url_for ( \"index\" )) from starlite import Starlite , get , Redirect @get ( \"/\" ) def index () -> str : return \"hello\" @get ( \"/hello\" ) def hello () -> Redirect : return Redirect ( path = \"index\" ) app = Starlite ([ index , hello ])","title":"Redirects"},{"location":"migration/#raising-http-errors","text":"Instead of using the abort function, raise an HTTPException : Flask Starlite from flask import Flask , abort app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): abort ( 400 , \"this did not work\" ) from starlite import Starlite , get , HTTPException @get ( \"/\" ) def index () -> None : raise HTTPException ( status_code = 400 , detail = \"this did not work\" ) app = Starlite ([ index ]) Learn more To learn more about exceptions, check out this chapter in the documentation: Exceptions","title":"Raising HTTP errors"},{"location":"migration/#setting-status-codes","text":"Flask Starlite from flask import Flask app = Flask ( __name__ ) @app . get ( \"/\" ) def index (): return \"not found\" , 404 from starlite import Starlite , get , Response @get ( \"/static\" , status_code = 404 ) def static_status () -> str : return \"not found\" @get ( \"/dynamic\" ) def dynamic_status () -> Response [ str ]: return Response ( \"not found\" , status_code = 404 ) app = Starlite ([ static_status , dynamic_status ])","title":"Setting status codes"},{"location":"migration/#serialization","text":"Flask uses a mix of explicit conversion (such as jsonify ) and inference (i.e. the type of the returned data) to determine how data should be serialized. Starlite instead assumes the data returned is intended to be serialized into JSON and will do so unless told otherwise. Flask Starlite from flask import Flask , Response app = Flask ( __name__ ) @app . get ( \"/json\" ) def get_json (): return { \"hello\" : \"world\" } @app . get ( \"/text\" ) def get_text (): return \"hello, world!\" @app . get ( \"/html\" ) def get_html (): return Response ( \"<strong>hello, world</strong>\" , mimetype = \"text/html\" ) from starlite import Starlite , get , MediaType @get ( \"/json\" ) def get_json () -> dict [ str , str ]: return { \"hello\" : \"world\" } @get ( \"/text\" , media_type = MediaType . TEXT ) def get_text () -> str : return \"hello, world\" @get ( \"/html\" , media_type = MediaType . HTML ) def get_html () -> str : return \"<strong>hello, world</strong>\" app = Starlite ([ get_json , get_text , get_html ])","title":"Serialization"},{"location":"migration/#error-handling","text":"Flask Starlite from flask import Flask from werkzeug.exceptions import HTTPException app = Flask ( __name__ ) @app . errorhandler ( HTTPException ) def handle_exception ( e ): ... from starlite import Starlite , HTTPException , Request , Response def handle_exception ( request : Request , exception : Exception ) -> Response : ... app = Starlite ([], exception_handlers = { HTTPException : handle_exception }) Learn more To learn more about exception handling, check out this chapter in the documentation: Exception handling","title":"Error handling"},{"location":"reference/0-api-reference-intro/","text":"API Reference The API references offer detailed documentation of the public API of Starlite , and semantic versioning guarantees apply to the interfaces defined within. Any undocumented interfaces are subject to change. However, users should feel free to open GitHub discussions / issues, or reach out via our Discord server to discuss the stability of any undocumented interface.","title":"API Reference"},{"location":"reference/0-api-reference-intro/#api-reference","text":"The API references offer detailed documentation of the public API of Starlite , and semantic versioning guarantees apply to the interfaces defined within. Any undocumented interfaces are subject to change. However, users should feel free to open GitHub discussions / issues, or reach out via our Discord server to discuss the stability of any undocumented interface.","title":"API Reference"},{"location":"reference/1-app/","text":"The Starlite Application starlite.app.Starlite Bases: Router The Starlite application. Starlite is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. Inherits from the Router class route_handler_method_view property route_handler_method_view : Dict [ str , List [ str ]] Map route handlers to paths. Returns: Type Description Dict [ str , List [ str ]] A dictionary of router handlers and lists of paths as strings __init__ __init__ ( route_handlers , * , after_exception = None , after_request = None , after_response = None , after_shutdown = None , after_startup = None , allowed_hosts = None , before_request = None , before_send = None , before_shutdown = None , before_startup = None , cache_config = DEFAULT_CACHE_CONFIG , cache_control = None , compression_config = None , cors_config = None , csrf_config = None , debug = False , dependencies = None , etag = None , exception_handlers = None , guards = None , initial_state = None , logging_config = None , middleware = None , on_app_init = None , on_shutdown = None , on_startup = None , openapi_config = DEFAULT_OPENAPI_CONFIG , opt = None , parameters = None , plugins = None , request_class = None , response_class = None , response_cookies = None , response_headers = None , security = None , static_files_config = None , tags = None , template_config = None , websocket_class = None ) Initialize a Starlite application. Parameters: Name Type Description Default after_exception Optional [ SingleOrList[AfterExceptionHookHandler] ] An application level exception hook handler or list thereof.This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.). None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None after_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called. None after_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called. None allowed_hosts Optional [ Union [ List [ str ], AllowedHostsConfig ]] A list of allowed hosts - enables the builtin allowed hosts middleware. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the Request instance and any non- None return value is used for the response, bypassing the route handler. None before_send Optional [ SingleOrList[BeforeMessageSendHookHandler] ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called. None before_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called. None before_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called. None cache_config CacheConfig Configures caching behavior of the application. DEFAULT_CACHE_CONFIG cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this app. Can be overridden by route handlers. None compression_config Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware. None cors_config Optional [ CORSConfig ] If set this enables the builtin CORS middleware. None csrf_config Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware. None debug bool If True , app errors rendered as HTML with a stack trace. False dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag to add to route handlers of this app. Can be overridden by route handlers. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None initial_state Optional [ Union [ ImmutableState , Dict [ str , Any ], Iterable [ Tuple [ str , Any ]]]] An object from which to initialize the app state. None logging_config Optional [ BaseLoggingConfig ] A subclass of BaseLoggingConfig . None middleware Optional [ List [ Middleware ]] A list of Middleware . None on_app_init Optional [ List [ OnAppInitHandler ]] A sequence of OnAppInitHandler instances. Handlers receive an instance of AppConfig that will have been initially populated with the parameters passed to Starlite , and must return an instance of same. If more than one handler is registered they are called in the order they are provided. None on_shutdown Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application shutdown. None on_startup Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application startup. None openapi_config Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG DEFAULT_OPENAPI_CONFIG opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None plugins Optional [ List [ PluginProtocol ]] List of plugins. None request_class Optional [ Type [ Request ]] An optional subclass of Request to use for http connections. None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None route_handlers List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required security Optional [ List [ SecurityRequirement ]] A list of dictionaries that will be added to the schema of all route handlers in the application. See SecurityRequirement for details. None static_files_config Optional [ Union [ StaticFilesConfig , List [ StaticFilesConfig ]]] An instance or list of StaticFilesConfig None tags Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the application. None template_config Optional [ TemplateConfig ] An instance of TemplateConfig None websocket_class Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections. None __call__ async __call__ ( scope , receive , send ) Application entry point. Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used Parameters: Name Type Description Default scope Union [ Scope , LifeSpanScope ] The ASGI connection scope. required receive Union [ Receive , LifeSpanReceive ] The ASGI receive function. required send Union [ Send , LifeSpanSend ] The ASGI send function. required Returns: Type Description None None get_handler_index_by_name get_handler_index_by_name ( name ) Receives a route handler name and returns an optional dictionary containing the route handler instance and list of paths sorted lexically. Examples: from starlite import Starlite , get @get ( \"/\" , name = \"my-handler\" ) def handler () -> None : pass app = Starlite ( route_handlers = [ handler ]) handler_index = app . get_handler_index_by_name ( \"my-handler\" ) # { \"paths\": [\"/\"], \"handler\" ... } Parameters: Name Type Description Default name str A route handler unique name. required Returns: Type Description Optional [ HandlerIndex ] A HandlerIndex instance or None. register register ( value , add_to_openapi_schema = False ) Register a route handler on the app. This method can be used to dynamically add endpoints to an application. Parameters: Name Type Description Default value ControllerRouterHandler an instance of Router , a subclass of Controller or any function decorated by the route handler decorators. required add_to_openapi_schema bool Whether to add the registered route to the OpenAPI Schema. This affects only HTTP route handlers. False Returns: Type Description None None route_reverse route_reverse ( name , ** path_parameters ) Receives a route handler name, path parameter values and returns url path to the handler with filled path parameters. Examples: from starlite import Starlite , get @get ( \"/group/{group_id:int}/user/{user_id:int}\" , name = \"get_membership_details\" ) def get_membership_details ( group_id : int , user_id : int ) -> None : pass app = Starlite ( route_handlers = [ get_membership_details ]) path = app . route_reverse ( \"get_membership_details\" , user_id = 100 , group_id = 10 ) # /group/10/user/100 Parameters: Name Type Description Default name str A route handler unique name. required **path_parameters Any Actual values for path parameters in the route. {} Raises: Type Description NoRouteMatchFoundException If route with 'name' does not exist, path parameters are missing in **path_parameters or have wrong type. Returns: Type Description str A fully formatted url path. url_for_static_asset url_for_static_asset ( name , file_path ) Receives a static files handler name, an asset file path and returns resolved url path to the asset. Examples: from starlite import Starlite , StaticFilesConfig app = Starlite ( static_files_config = StaticFilesConfig ( directories = [ \"css\" ], path = \"/static/css\" ) ) path = app . url_for_static_asset ( \"css\" , \"main.css\" ) # /static/css/main.css Parameters: Name Type Description Default name str A static handler unique name. required file_path str a string containing path to an asset. required Raises: Type Description NoRouteMatchFoundException If static files handler with 'name' does not exist. Returns: Type Description str A url path to the asset. starlite.app.HandlerIndex Bases: TypedDict Map route handler names to a mapping of paths + route handler. It's returned from the 'get_handler_index_by_name' utility method. paths class-attribute paths : List [ str ] Full route paths to the route handler. handler class-attribute handler : RouteHandlerType Route handler instance. identifier class-attribute identifier : str Unique identifier of the handler. Either equal to the 'name' attribute or the str value of the handler. starlite.app.DEFAULT_OPENAPI_CONFIG module-attribute starlite . app . DEFAULT_OPENAPI_CONFIG = OpenAPIConfig ( title = 'Starlite API' , version = '1.0.0' ) The default OpenAPI config used if not configuration is explicitly passed to the Starlite instance constructor. starlite.app.DEFAULT_CACHE_CONFIG module-attribute starlite . app . DEFAULT_CACHE_CONFIG = CacheConfig () The default cache config used if not configuration is explicitly passed to the Starlite instance constructor.","title":"The Starlite Application"},{"location":"reference/1-app/#the-starlite-application","text":"","title":"The Starlite Application"},{"location":"reference/1-app/#starlite.app.Starlite","text":"Bases: Router The Starlite application. Starlite is the root level of the app - it has the base path of \"/\" and all root level Controllers, Routers and Route Handlers should be registered on it. Inherits from the Router class","title":"Starlite"},{"location":"reference/1-app/#starlite.app.Starlite.route_handler_method_view","text":"route_handler_method_view : Dict [ str , List [ str ]] Map route handlers to paths. Returns: Type Description Dict [ str , List [ str ]] A dictionary of router handlers and lists of paths as strings","title":"route_handler_method_view"},{"location":"reference/1-app/#starlite.app.Starlite.__init__","text":"__init__ ( route_handlers , * , after_exception = None , after_request = None , after_response = None , after_shutdown = None , after_startup = None , allowed_hosts = None , before_request = None , before_send = None , before_shutdown = None , before_startup = None , cache_config = DEFAULT_CACHE_CONFIG , cache_control = None , compression_config = None , cors_config = None , csrf_config = None , debug = False , dependencies = None , etag = None , exception_handlers = None , guards = None , initial_state = None , logging_config = None , middleware = None , on_app_init = None , on_shutdown = None , on_startup = None , openapi_config = DEFAULT_OPENAPI_CONFIG , opt = None , parameters = None , plugins = None , request_class = None , response_class = None , response_cookies = None , response_headers = None , security = None , static_files_config = None , tags = None , template_config = None , websocket_class = None ) Initialize a Starlite application. Parameters: Name Type Description Default after_exception Optional [ SingleOrList[AfterExceptionHookHandler] ] An application level exception hook handler or list thereof.This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.). None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None after_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called. None after_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called. None allowed_hosts Optional [ Union [ List [ str ], AllowedHostsConfig ]] A list of allowed hosts - enables the builtin allowed hosts middleware. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the Request instance and any non- None return value is used for the response, bypassing the route handler. None before_send Optional [ SingleOrList[BeforeMessageSendHookHandler] ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called. None before_shutdown Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called. None before_startup Optional [ SingleOrList[LifeSpanHookHandler] ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called. None cache_config CacheConfig Configures caching behavior of the application. DEFAULT_CACHE_CONFIG cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this app. Can be overridden by route handlers. None compression_config Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware. None cors_config Optional [ CORSConfig ] If set this enables the builtin CORS middleware. None csrf_config Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware. None debug bool If True , app errors rendered as HTML with a stack trace. False dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag to add to route handlers of this app. Can be overridden by route handlers. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None initial_state Optional [ Union [ ImmutableState , Dict [ str , Any ], Iterable [ Tuple [ str , Any ]]]] An object from which to initialize the app state. None logging_config Optional [ BaseLoggingConfig ] A subclass of BaseLoggingConfig . None middleware Optional [ List [ Middleware ]] A list of Middleware . None on_app_init Optional [ List [ OnAppInitHandler ]] A sequence of OnAppInitHandler instances. Handlers receive an instance of AppConfig that will have been initially populated with the parameters passed to Starlite , and must return an instance of same. If more than one handler is registered they are called in the order they are provided. None on_shutdown Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application shutdown. None on_startup Optional [ List [ LifeSpanHandler ]] A list of LifeSpanHandler called during application startup. None openapi_config Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG DEFAULT_OPENAPI_CONFIG opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None plugins Optional [ List [ PluginProtocol ]] List of plugins. None request_class Optional [ Type [ Request ]] An optional subclass of Request to use for http connections. None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None route_handlers List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required security Optional [ List [ SecurityRequirement ]] A list of dictionaries that will be added to the schema of all route handlers in the application. See SecurityRequirement for details. None static_files_config Optional [ Union [ StaticFilesConfig , List [ StaticFilesConfig ]]] An instance or list of StaticFilesConfig None tags Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the application. None template_config Optional [ TemplateConfig ] An instance of TemplateConfig None websocket_class Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections. None","title":"__init__()"},{"location":"reference/1-app/#starlite.app.Starlite.__call__","text":"__call__ ( scope , receive , send ) Application entry point. Lifespan events (startup / shutdown) are sent to the lifespan handler, otherwise the ASGI handler is used Parameters: Name Type Description Default scope Union [ Scope , LifeSpanScope ] The ASGI connection scope. required receive Union [ Receive , LifeSpanReceive ] The ASGI receive function. required send Union [ Send , LifeSpanSend ] The ASGI send function. required Returns: Type Description None None","title":"__call__()"},{"location":"reference/1-app/#starlite.app.Starlite.get_handler_index_by_name","text":"get_handler_index_by_name ( name ) Receives a route handler name and returns an optional dictionary containing the route handler instance and list of paths sorted lexically. Examples: from starlite import Starlite , get @get ( \"/\" , name = \"my-handler\" ) def handler () -> None : pass app = Starlite ( route_handlers = [ handler ]) handler_index = app . get_handler_index_by_name ( \"my-handler\" ) # { \"paths\": [\"/\"], \"handler\" ... } Parameters: Name Type Description Default name str A route handler unique name. required Returns: Type Description Optional [ HandlerIndex ] A HandlerIndex instance or None.","title":"get_handler_index_by_name()"},{"location":"reference/1-app/#starlite.app.Starlite.register","text":"register ( value , add_to_openapi_schema = False ) Register a route handler on the app. This method can be used to dynamically add endpoints to an application. Parameters: Name Type Description Default value ControllerRouterHandler an instance of Router , a subclass of Controller or any function decorated by the route handler decorators. required add_to_openapi_schema bool Whether to add the registered route to the OpenAPI Schema. This affects only HTTP route handlers. False Returns: Type Description None None","title":"register()"},{"location":"reference/1-app/#starlite.app.Starlite.route_reverse","text":"route_reverse ( name , ** path_parameters ) Receives a route handler name, path parameter values and returns url path to the handler with filled path parameters. Examples: from starlite import Starlite , get @get ( \"/group/{group_id:int}/user/{user_id:int}\" , name = \"get_membership_details\" ) def get_membership_details ( group_id : int , user_id : int ) -> None : pass app = Starlite ( route_handlers = [ get_membership_details ]) path = app . route_reverse ( \"get_membership_details\" , user_id = 100 , group_id = 10 ) # /group/10/user/100 Parameters: Name Type Description Default name str A route handler unique name. required **path_parameters Any Actual values for path parameters in the route. {} Raises: Type Description NoRouteMatchFoundException If route with 'name' does not exist, path parameters are missing in **path_parameters or have wrong type. Returns: Type Description str A fully formatted url path.","title":"route_reverse()"},{"location":"reference/1-app/#starlite.app.Starlite.url_for_static_asset","text":"url_for_static_asset ( name , file_path ) Receives a static files handler name, an asset file path and returns resolved url path to the asset. Examples: from starlite import Starlite , StaticFilesConfig app = Starlite ( static_files_config = StaticFilesConfig ( directories = [ \"css\" ], path = \"/static/css\" ) ) path = app . url_for_static_asset ( \"css\" , \"main.css\" ) # /static/css/main.css Parameters: Name Type Description Default name str A static handler unique name. required file_path str a string containing path to an asset. required Raises: Type Description NoRouteMatchFoundException If static files handler with 'name' does not exist. Returns: Type Description str A url path to the asset.","title":"url_for_static_asset()"},{"location":"reference/1-app/#starlite.app.HandlerIndex","text":"Bases: TypedDict Map route handler names to a mapping of paths + route handler. It's returned from the 'get_handler_index_by_name' utility method.","title":"HandlerIndex"},{"location":"reference/1-app/#starlite.app.HandlerIndex.paths","text":"paths : List [ str ] Full route paths to the route handler.","title":"paths"},{"location":"reference/1-app/#starlite.app.HandlerIndex.handler","text":"handler : RouteHandlerType Route handler instance.","title":"handler"},{"location":"reference/1-app/#starlite.app.HandlerIndex.identifier","text":"identifier : str Unique identifier of the handler. Either equal to the 'name' attribute or the str value of the handler.","title":"identifier"},{"location":"reference/1-app/#starlite.app.DEFAULT_OPENAPI_CONFIG","text":"starlite . app . DEFAULT_OPENAPI_CONFIG = OpenAPIConfig ( title = 'Starlite API' , version = '1.0.0' ) The default OpenAPI config used if not configuration is explicitly passed to the Starlite instance constructor.","title":"DEFAULT_OPENAPI_CONFIG"},{"location":"reference/1-app/#starlite.app.DEFAULT_CACHE_CONFIG","text":"starlite . app . DEFAULT_CACHE_CONFIG = CacheConfig () The default cache config used if not configuration is explicitly passed to the Starlite instance constructor.","title":"DEFAULT_CACHE_CONFIG"},{"location":"reference/2-router/","text":"Router starlite.router.Router The Starlite Router class. A Router instance is used to group controller, routers and route handler functions under a shared path fragment __init__ __init__ ( path , * , after_request = None , after_response = None , before_request = None , cache_control = None , dependencies = None , etag = None , exception_handlers = None , guards = None , middleware = None , opt = None , parameters = None , response_class = None , response_cookies = None , response_headers = None , route_handlers , security = None , tags = None ) Initialize a Router . Parameters: Name Type Description Default after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this router. Can be overridden by route handlers. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag to add to route handlers of this router. Can be overridden by route handlers. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None middleware Optional [ List [ Middleware ]] A list of Middleware . None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None path str A path fragment that is prefixed to all route handlers, controllers and other routers associated with the router instance. required response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the default for all route handlers, controllers and other routers associated with the router instance. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None route_handlers List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required security Optional [ List [ SecurityRequirement ]] A list of dictionaries that will be added to the schema of all route handlers under the router. None tags Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the router. None register register ( value ) Register a Controller, Route instance or RouteHandler on the router. Parameters: Name Type Description Default value ControllerRouterHandler a subclass or instance of Controller, an instance of Router or a function/method that has been decorated by any of the routing decorators, e.g. get , post . required Returns: Type Description List [ BaseRoute ] Collection of handlers added to the router.","title":"Router"},{"location":"reference/2-router/#router","text":"","title":"Router"},{"location":"reference/2-router/#starlite.router.Router","text":"The Starlite Router class. A Router instance is used to group controller, routers and route handler functions under a shared path fragment","title":"Router"},{"location":"reference/2-router/#starlite.router.Router.__init__","text":"__init__ ( path , * , after_request = None , after_response = None , before_request = None , cache_control = None , dependencies = None , etag = None , exception_handlers = None , guards = None , middleware = None , opt = None , parameters = None , response_class = None , response_cookies = None , response_headers = None , route_handlers , security = None , tags = None ) Initialize a Router . Parameters: Name Type Description Default after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this router. Can be overridden by route handlers. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag to add to route handlers of this router. Can be overridden by route handlers. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None middleware Optional [ List [ Middleware ]] A list of Middleware . None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None parameters Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. None path str A path fragment that is prefixed to all route handlers, controllers and other routers associated with the router instance. required response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the default for all route handlers, controllers and other routers associated with the router instance. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None route_handlers List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of Controller or any function decorated by the route handler decorators. required security Optional [ List [ SecurityRequirement ]] A list of dictionaries that will be added to the schema of all route handlers under the router. None tags Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the router. None","title":"__init__()"},{"location":"reference/2-router/#starlite.router.Router.register","text":"register ( value ) Register a Controller, Route instance or RouteHandler on the router. Parameters: Name Type Description Default value ControllerRouterHandler a subclass or instance of Controller, an instance of Router or a function/method that has been decorated by any of the routing decorators, e.g. get , post . required Returns: Type Description List [ BaseRoute ] Collection of handlers added to the router.","title":"register()"},{"location":"reference/3-controller/","text":"Controller starlite.controller.Controller The Starlite Controller class. Subclass this class to create 'view' like components and utilize OOP. after_request class-attribute after_request : Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. after_response class-attribute after_response : Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request instance and should not return any values. before_request class-attribute before_request : Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. It receives the Request instance and any non- None return value is used for the response, bypassing the route handler. cache_control class-attribute cache_control : Optional [ CacheControlHeader ] A CacheControlHeader header to add to route handlers of this controller. Can be overridden by route handlers. dependencies class-attribute dependencies : Optional [ Dependencies ] dependencies: A string keyed dictionary of dependency Provider instances. exception_handlers class-attribute exception_handlers : Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. guards class-attribute guards : Optional [ List [ Guard ]] A list of Guard callables. middleware class-attribute middleware : Optional [ List [ Middleware ]] A list of Middleware . owner instance-attribute owner = owner parameters class-attribute parameters : Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths. path instance-attribute path = normalize_path ( self . path or '/' ) response_class class-attribute response_class : Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the default response for all route handlers under the controller. response_cookies class-attribute response_cookies : Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. response_headers class-attribute response_headers : Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. security class-attribute security : Optional [ List [ SecurityRequirement ]] A list of dictionaries that to the schema of all route handlers under the controller. tags class-attribute tags : Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the controller.","title":"Controller"},{"location":"reference/3-controller/#controller","text":"","title":"Controller"},{"location":"reference/3-controller/#starlite.controller.Controller","text":"The Starlite Controller class. Subclass this class to create 'view' like components and utilize OOP.","title":"Controller"},{"location":"reference/3-controller/#starlite.controller.Controller.after_request","text":"after_request : Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used.","title":"after_request"},{"location":"reference/3-controller/#starlite.controller.Controller.after_response","text":"after_response : Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request instance and should not return any values.","title":"after_response"},{"location":"reference/3-controller/#starlite.controller.Controller.before_request","text":"before_request : Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. It receives the Request instance and any non- None return value is used for the response, bypassing the route handler.","title":"before_request"},{"location":"reference/3-controller/#starlite.controller.Controller.cache_control","text":"cache_control : Optional [ CacheControlHeader ] A CacheControlHeader header to add to route handlers of this controller. Can be overridden by route handlers.","title":"cache_control"},{"location":"reference/3-controller/#starlite.controller.Controller.dependencies","text":"dependencies : Optional [ Dependencies ] dependencies: A string keyed dictionary of dependency Provider instances.","title":"dependencies"},{"location":"reference/3-controller/#starlite.controller.Controller.exception_handlers","text":"exception_handlers : Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types.","title":"exception_handlers"},{"location":"reference/3-controller/#starlite.controller.Controller.guards","text":"guards : Optional [ List [ Guard ]] A list of Guard callables.","title":"guards"},{"location":"reference/3-controller/#starlite.controller.Controller.middleware","text":"middleware : Optional [ List [ Middleware ]] A list of Middleware .","title":"middleware"},{"location":"reference/3-controller/#starlite.controller.Controller.owner","text":"owner = owner","title":"owner"},{"location":"reference/3-controller/#starlite.controller.Controller.parameters","text":"parameters : Optional [ ParametersMap ] A mapping of Parameter definitions available to all application paths.","title":"parameters"},{"location":"reference/3-controller/#starlite.controller.Controller.path","text":"path = normalize_path ( self . path or '/' )","title":"path"},{"location":"reference/3-controller/#starlite.controller.Controller.response_class","text":"response_class : Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the default response for all route handlers under the controller.","title":"response_class"},{"location":"reference/3-controller/#starlite.controller.Controller.response_cookies","text":"response_cookies : Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances.","title":"response_cookies"},{"location":"reference/3-controller/#starlite.controller.Controller.response_headers","text":"response_headers : Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances.","title":"response_headers"},{"location":"reference/3-controller/#starlite.controller.Controller.security","text":"security : Optional [ List [ SecurityRequirement ]] A list of dictionaries that to the schema of all route handlers under the controller.","title":"security"},{"location":"reference/3-controller/#starlite.controller.Controller.tags","text":"tags : Optional [ List [ str ]] A list of string tags that will be appended to the schema of all route handlers under the controller.","title":"tags"},{"location":"reference/5-dto/","text":"DTO starlite.dto.DTO Bases: GenericModel , Generic [ T ] Data Transfer Object. from_model_instance classmethod from_model_instance ( model_instance ) Given an instance of the source model, create an instance of the given DTO subclass. Parameters: Name Type Description Default model_instance T instance of source model. required Returns: Type Description DTO[T] Instance of the DTO subclass. from_model_instance_async async classmethod from_model_instance_async ( model_instance ) Given an instance of the source model, create an instance of the given DTO subclass asynchronously. Parameters: Name Type Description Default model_instance T instance of source model. required Returns: Type Description DTO[T] Instance of the DTO subclass. to_model_instance to_model_instance () Convert the DTO instance into an instance of the original class from which the DTO was created. Returns: Type Description T Instance of source model type. starlite.dto.DTOFactory Create DTO type. Pydantic models, TypedDict and dataclasses are natively supported. Other types supported via plugins. __init__ __init__ ( plugins = None ) Initialize DTOFactory Parameters: Name Type Description Default plugins Optional [ List [ PluginProtocol ]] Plugins used to support DTO construction from arbitrary types. None __call__ __call__ ( name , source , exclude = None , field_mapping = None , field_definitions = None , base = DTO ) Given a supported model class - either pydantic, TypedDict , dataclass or a class supported via plugins, create a DTO pydantic model class. An instance of the factory must first be created, passing any plugins to it. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes specifies in the 'exclude' list and remap field names and/or field types. For example, given a pydantic model class MyClass ( BaseModel ): first : int second : int MyClassDTO = DTOFactory ()( MyClass , exclude = [ \"first\" ], field_mapping = { \"second\" : ( \"third\" , float )} ) MyClassDTO is now equal to this: class MyClassDTO ( BaseModel ): third : float It can be used as a regular pydantic model: @post ( path = \"/my-path\" ) def create_obj ( data : MyClassDTO ) -> MyClass : ... This will affect parsing, validation and how OpenAPI schema is generated exactly like when using a pydantic model. Note: Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently not possible to extend editor auto-complete for the DTO properties - it will be typed as a Pydantic BaseModel, but no attributes will be inferred in the editor. Parameters: Name Type Description Default name str This becomes the name of the generated pydantic model. required source type [ T ] A type that is either a subclass of BaseModel , TypedDict , a dataclass or any other type with a plugin registered. required exclude list [ str ] | None Names of attributes on source . Named Attributes will not have a field generated on the resultant pydantic model. None field_mapping dict [ str , str | tuple [ str , Any ]] | None Keys are names of attributes on source . Values are either a str to rename an attribute, or tuple (str, Any) to remap both name and type of the attribute. None field_definitions dict [ str , tuple [ Any , Any ]] | None Add fields to the model that don't exist on source . These are passed as kwargs to pydantic.create_model() . None Returns: Type Description Type [ DTO [ T ]] Type[DTO[T]] Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] If source is not a pydantic model, TypedDict or dataclass, and there is no plugin registered for its type.","title":"DTO"},{"location":"reference/5-dto/#dto","text":"","title":"DTO"},{"location":"reference/5-dto/#starlite.dto.DTO","text":"Bases: GenericModel , Generic [ T ] Data Transfer Object.","title":"DTO"},{"location":"reference/5-dto/#starlite.dto.DTO.from_model_instance","text":"from_model_instance ( model_instance ) Given an instance of the source model, create an instance of the given DTO subclass. Parameters: Name Type Description Default model_instance T instance of source model. required Returns: Type Description DTO[T] Instance of the DTO subclass.","title":"from_model_instance()"},{"location":"reference/5-dto/#starlite.dto.DTO.from_model_instance_async","text":"from_model_instance_async ( model_instance ) Given an instance of the source model, create an instance of the given DTO subclass asynchronously. Parameters: Name Type Description Default model_instance T instance of source model. required Returns: Type Description DTO[T] Instance of the DTO subclass.","title":"from_model_instance_async()"},{"location":"reference/5-dto/#starlite.dto.DTO.to_model_instance","text":"to_model_instance () Convert the DTO instance into an instance of the original class from which the DTO was created. Returns: Type Description T Instance of source model type.","title":"to_model_instance()"},{"location":"reference/5-dto/#starlite.dto.DTOFactory","text":"Create DTO type. Pydantic models, TypedDict and dataclasses are natively supported. Other types supported via plugins.","title":"DTOFactory"},{"location":"reference/5-dto/#starlite.dto.DTOFactory.__init__","text":"__init__ ( plugins = None ) Initialize DTOFactory Parameters: Name Type Description Default plugins Optional [ List [ PluginProtocol ]] Plugins used to support DTO construction from arbitrary types. None","title":"__init__()"},{"location":"reference/5-dto/#starlite.dto.DTOFactory.__call__","text":"__call__ ( name , source , exclude = None , field_mapping = None , field_definitions = None , base = DTO ) Given a supported model class - either pydantic, TypedDict , dataclass or a class supported via plugins, create a DTO pydantic model class. An instance of the factory must first be created, passing any plugins to it. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes specifies in the 'exclude' list and remap field names and/or field types. For example, given a pydantic model class MyClass ( BaseModel ): first : int second : int MyClassDTO = DTOFactory ()( MyClass , exclude = [ \"first\" ], field_mapping = { \"second\" : ( \"third\" , float )} ) MyClassDTO is now equal to this: class MyClassDTO ( BaseModel ): third : float It can be used as a regular pydantic model: @post ( path = \"/my-path\" ) def create_obj ( data : MyClassDTO ) -> MyClass : ... This will affect parsing, validation and how OpenAPI schema is generated exactly like when using a pydantic model. Note: Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently not possible to extend editor auto-complete for the DTO properties - it will be typed as a Pydantic BaseModel, but no attributes will be inferred in the editor. Parameters: Name Type Description Default name str This becomes the name of the generated pydantic model. required source type [ T ] A type that is either a subclass of BaseModel , TypedDict , a dataclass or any other type with a plugin registered. required exclude list [ str ] | None Names of attributes on source . Named Attributes will not have a field generated on the resultant pydantic model. None field_mapping dict [ str , str | tuple [ str , Any ]] | None Keys are names of attributes on source . Values are either a str to rename an attribute, or tuple (str, Any) to remap both name and type of the attribute. None field_definitions dict [ str , tuple [ Any , Any ]] | None Add fields to the model that don't exist on source . These are passed as kwargs to pydantic.create_model() . None Returns: Type Description Type [ DTO [ T ]] Type[DTO[T]] Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] If source is not a pydantic model, TypedDict or dataclass, and there is no plugin registered for its type.","title":"__call__()"},{"location":"reference/6-enums/","text":"Enums starlite.enums.HttpMethod Bases: str , Enum An Enum for HTTP methods. DELETE class-attribute DELETE = 'DELETE' GET class-attribute GET = 'GET' HEAD class-attribute HEAD = 'HEAD' OPTIONS class-attribute OPTIONS = 'OPTIONS' PATCH class-attribute PATCH = 'PATCH' POST class-attribute POST = 'POST' PUT class-attribute PUT = 'PUT' starlite.enums.MediaType Bases: str , Enum An Enum for 'Content-Type' header values. HTML class-attribute HTML = 'text/html' JSON class-attribute JSON = 'application/json' TEXT class-attribute TEXT = 'text/plain' MESSAGEPACK class-attribute MESSAGEPACK = 'application/x-msgpack' CSS class-attribute CSS = 'text/css' XML class-attribute XML = 'application/xml' starlite.enums.OpenAPIMediaType Bases: str , Enum An Enum for OpenAPI specific response 'Content-Type' header values. OPENAPI_JSON class-attribute OPENAPI_JSON = 'application/vnd.oai.openapi+json' OPENAPI_YAML class-attribute OPENAPI_YAML = 'application/vnd.oai.openapi' starlite.enums.RequestEncodingType Bases: str , Enum An Enum for request 'Content-Type' header values designating encoding formats. JSON class-attribute JSON = 'application/json' MULTI_PART class-attribute MULTI_PART = 'multipart/form-data' URL_ENCODED class-attribute URL_ENCODED = 'application/x-www-form-urlencoded' starlite.enums.ScopeType Bases: str , Enum An Enum for the 'http' key stored under Scope. Notes 'asgi' is used by Starlite internally and is not part of the specification. HTTP class-attribute HTTP = 'http' WEBSOCKET class-attribute WEBSOCKET = 'websocket' ASGI class-attribute ASGI = 'asgi' starlite.enums.ParamType Bases: str , Enum An Enum for the types of parameters a request can receive. PATH class-attribute PATH = 'path' QUERY class-attribute QUERY = 'query' COOKIE class-attribute COOKIE = 'cookie' HEADER class-attribute HEADER = 'header' starlite.enums.CompressionEncoding Bases: str , Enum An Enum for supported compression encodings. GZIP class-attribute GZIP = 'gzip' BROTLI class-attribute BROTLI = 'br'","title":"Enums"},{"location":"reference/6-enums/#enums","text":"","title":"Enums"},{"location":"reference/6-enums/#starlite.enums.HttpMethod","text":"Bases: str , Enum An Enum for HTTP methods.","title":"HttpMethod"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.DELETE","text":"DELETE = 'DELETE'","title":"DELETE"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.GET","text":"GET = 'GET'","title":"GET"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.HEAD","text":"HEAD = 'HEAD'","title":"HEAD"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.OPTIONS","text":"OPTIONS = 'OPTIONS'","title":"OPTIONS"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.PATCH","text":"PATCH = 'PATCH'","title":"PATCH"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.POST","text":"POST = 'POST'","title":"POST"},{"location":"reference/6-enums/#starlite.enums.HttpMethod.PUT","text":"PUT = 'PUT'","title":"PUT"},{"location":"reference/6-enums/#starlite.enums.MediaType","text":"Bases: str , Enum An Enum for 'Content-Type' header values.","title":"MediaType"},{"location":"reference/6-enums/#starlite.enums.MediaType.HTML","text":"HTML = 'text/html'","title":"HTML"},{"location":"reference/6-enums/#starlite.enums.MediaType.JSON","text":"JSON = 'application/json'","title":"JSON"},{"location":"reference/6-enums/#starlite.enums.MediaType.TEXT","text":"TEXT = 'text/plain'","title":"TEXT"},{"location":"reference/6-enums/#starlite.enums.MediaType.MESSAGEPACK","text":"MESSAGEPACK = 'application/x-msgpack'","title":"MESSAGEPACK"},{"location":"reference/6-enums/#starlite.enums.MediaType.CSS","text":"CSS = 'text/css'","title":"CSS"},{"location":"reference/6-enums/#starlite.enums.MediaType.XML","text":"XML = 'application/xml'","title":"XML"},{"location":"reference/6-enums/#starlite.enums.OpenAPIMediaType","text":"Bases: str , Enum An Enum for OpenAPI specific response 'Content-Type' header values.","title":"OpenAPIMediaType"},{"location":"reference/6-enums/#starlite.enums.OpenAPIMediaType.OPENAPI_JSON","text":"OPENAPI_JSON = 'application/vnd.oai.openapi+json'","title":"OPENAPI_JSON"},{"location":"reference/6-enums/#starlite.enums.OpenAPIMediaType.OPENAPI_YAML","text":"OPENAPI_YAML = 'application/vnd.oai.openapi'","title":"OPENAPI_YAML"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType","text":"Bases: str , Enum An Enum for request 'Content-Type' header values designating encoding formats.","title":"RequestEncodingType"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType.JSON","text":"JSON = 'application/json'","title":"JSON"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType.MULTI_PART","text":"MULTI_PART = 'multipart/form-data'","title":"MULTI_PART"},{"location":"reference/6-enums/#starlite.enums.RequestEncodingType.URL_ENCODED","text":"URL_ENCODED = 'application/x-www-form-urlencoded'","title":"URL_ENCODED"},{"location":"reference/6-enums/#starlite.enums.ScopeType","text":"Bases: str , Enum An Enum for the 'http' key stored under Scope. Notes 'asgi' is used by Starlite internally and is not part of the specification.","title":"ScopeType"},{"location":"reference/6-enums/#starlite.enums.ScopeType.HTTP","text":"HTTP = 'http'","title":"HTTP"},{"location":"reference/6-enums/#starlite.enums.ScopeType.WEBSOCKET","text":"WEBSOCKET = 'websocket'","title":"WEBSOCKET"},{"location":"reference/6-enums/#starlite.enums.ScopeType.ASGI","text":"ASGI = 'asgi'","title":"ASGI"},{"location":"reference/6-enums/#starlite.enums.ParamType","text":"Bases: str , Enum An Enum for the types of parameters a request can receive.","title":"ParamType"},{"location":"reference/6-enums/#starlite.enums.ParamType.PATH","text":"PATH = 'path'","title":"PATH"},{"location":"reference/6-enums/#starlite.enums.ParamType.QUERY","text":"QUERY = 'query'","title":"QUERY"},{"location":"reference/6-enums/#starlite.enums.ParamType.COOKIE","text":"COOKIE = 'cookie'","title":"COOKIE"},{"location":"reference/6-enums/#starlite.enums.ParamType.HEADER","text":"HEADER = 'header'","title":"HEADER"},{"location":"reference/6-enums/#starlite.enums.CompressionEncoding","text":"Bases: str , Enum An Enum for supported compression encodings.","title":"CompressionEncoding"},{"location":"reference/6-enums/#starlite.enums.CompressionEncoding.GZIP","text":"GZIP = 'gzip'","title":"GZIP"},{"location":"reference/6-enums/#starlite.enums.CompressionEncoding.BROTLI","text":"BROTLI = 'br'","title":"BROTLI"},{"location":"reference/cache/0-base-cache/","text":"Cache Backend Protocol starlite.cache.CacheBackendProtocol Bases: Protocol Protocol for cache backends. get async get ( key ) Retrieve a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None . set async set ( key , value , expiration ) Set a value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description Any Any delete async delete ( key ) Delete a value from the cache and remove the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description Any Any starlite.cache.Cache Wrapper for a provided CacheBackend that ensures it is called in an async and thread-safe fashion. This enables the use of normal sync libraries (such as the standard Redis python client) for caching responses. __init__ __init__ ( backend , default_expiration , cache_key_builder ) Initialize Cache . Parameters: Name Type Description Default backend CacheBackendProtocol A class instance fulfilling the Starlite CacheBackendProtocol . required default_expiration int Default value (in seconds) for cache expiration. required cache_key_builder CacheKeyBuilder A function that receives a request object and returns a unique cache key. required get async get ( key ) Proxy 'self.backend.get'. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None . set async set ( key , value , expiration = None ) Proxy 'self.backend.set'. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration Optional [ int ] expiration of cached value in seconds. None Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description Any Any delete async delete ( key ) Proxy 'self.backend.delete'. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description Any Any build_cache_key build_cache_key ( request , cache_key_builder ) Construct a unique cache key from the request instance. Parameters: Name Type Description Default request Request A Request instance. required cache_key_builder Optional [ CacheKeyBuilder ] An optional CacheKeyBuilder function. required Returns: Type Description str A unique cache key string.","title":"Cache Backend Protocol"},{"location":"reference/cache/0-base-cache/#cache-backend-protocol","text":"","title":"Cache Backend Protocol"},{"location":"reference/cache/0-base-cache/#starlite.cache.CacheBackendProtocol","text":"Bases: Protocol Protocol for cache backends.","title":"CacheBackendProtocol"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.CacheBackendProtocol.get","text":"get ( key ) Retrieve a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None .","title":"get()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.CacheBackendProtocol.set","text":"set ( key , value , expiration ) Set a value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description Any Any","title":"set()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.CacheBackendProtocol.delete","text":"delete ( key ) Delete a value from the cache and remove the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description Any Any","title":"delete()"},{"location":"reference/cache/0-base-cache/#starlite.cache.Cache","text":"Wrapper for a provided CacheBackend that ensures it is called in an async and thread-safe fashion. This enables the use of normal sync libraries (such as the standard Redis python client) for caching responses.","title":"Cache"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.__init__","text":"__init__ ( backend , default_expiration , cache_key_builder ) Initialize Cache . Parameters: Name Type Description Default backend CacheBackendProtocol A class instance fulfilling the Starlite CacheBackendProtocol . required default_expiration int Default value (in seconds) for cache expiration. required cache_key_builder CacheKeyBuilder A function that receives a request object and returns a unique cache key. required","title":"__init__()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.get","text":"get ( key ) Proxy 'self.backend.get'. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None .","title":"get()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.set","text":"set ( key , value , expiration = None ) Proxy 'self.backend.set'. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration Optional [ int ] expiration of cached value in seconds. None Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description Any Any","title":"set()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.delete","text":"delete ( key ) Proxy 'self.backend.delete'. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description Any Any","title":"delete()"},{"location":"reference/cache/0-base-cache/#starlite.cache.base.Cache.build_cache_key","text":"build_cache_key ( request , cache_key_builder ) Construct a unique cache key from the request instance. Parameters: Name Type Description Default request Request A Request instance. required cache_key_builder Optional [ CacheKeyBuilder ] An optional CacheKeyBuilder function. required Returns: Type Description str A unique cache key string.","title":"build_cache_key()"},{"location":"reference/cache/1-simple-cache/","text":"Simple Cache Backend starlite.cache.SimpleCacheBackend Bases: CacheBackendProtocol In-memory cache backend. __init__ __init__ () Initialize SimpleCacheBackend get async get ( key ) Retrieve value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value or None . set async set ( key , value , expiration ) Set a value in cache for a given key with a given expiration in seconds. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Returns: Type Description None None delete async delete ( key ) Remove a value from the cache for a given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Returns: Type Description None None","title":"Simple Cache Backend"},{"location":"reference/cache/1-simple-cache/#simple-cache-backend","text":"","title":"Simple Cache Backend"},{"location":"reference/cache/1-simple-cache/#starlite.cache.SimpleCacheBackend","text":"Bases: CacheBackendProtocol In-memory cache backend.","title":"SimpleCacheBackend"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.__init__","text":"__init__ () Initialize SimpleCacheBackend","title":"__init__()"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.get","text":"get ( key ) Retrieve value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value or None .","title":"get()"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.set","text":"set ( key , value , expiration ) Set a value in cache for a given key with a given expiration in seconds. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Returns: Type Description None None","title":"set()"},{"location":"reference/cache/1-simple-cache/#starlite.cache.simple_cache_backend.SimpleCacheBackend.delete","text":"delete ( key ) Remove a value from the cache for a given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Returns: Type Description None None","title":"delete()"},{"location":"reference/cache/2-redis-cache/","text":"Redis Cache Backend starlite.cache.redis_cache_backend.RedisCacheBackend Bases: CacheBackendProtocol Redis-based cache backend. __init__ __init__ ( config ) Initialize RedisCacheBackend Parameters: Name Type Description Default config RedisCacheBackendConfig required configuration to connect to Redis. required get async get ( key ) Retrieve a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None . set async set ( key , value , expiration ) Set a value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description None None delete async delete ( key ) Delete a value from the cache and removes the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description None None starlite.cache.redis_cache_backend.RedisCacheBackendConfig Bases: BaseModel Redis cache backend configuration. url class-attribute url : str Redis connection URL. db class-attribute db : Optional [ int ] = None Redis DB ID (optional) port class-attribute port : Optional [ int ] = None Redis port (optional) username class-attribute username : Optional [ str ] = None A username to use when connecting to Redis (optional) password class-attribute password : Optional [ str ] = None A password to use when connecting to Redis (optional)","title":"Redis Cache Backend"},{"location":"reference/cache/2-redis-cache/#redis-cache-backend","text":"","title":"Redis Cache Backend"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend","text":"Bases: CacheBackendProtocol Redis-based cache backend.","title":"RedisCacheBackend"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.__init__","text":"__init__ ( config ) Initialize RedisCacheBackend Parameters: Name Type Description Default config RedisCacheBackendConfig required configuration to connect to Redis. required","title":"__init__()"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.get","text":"get ( key ) Retrieve a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None .","title":"get()"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.set","text":"set ( key , value , expiration ) Set a value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description None None","title":"set()"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackend.delete","text":"delete ( key ) Delete a value from the cache and removes the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description None None","title":"delete()"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig","text":"Bases: BaseModel Redis cache backend configuration.","title":"RedisCacheBackendConfig"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.url","text":"url : str Redis connection URL.","title":"url"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.db","text":"db : Optional [ int ] = None Redis DB ID (optional)","title":"db"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.port","text":"port : Optional [ int ] = None Redis port (optional)","title":"port"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.username","text":"username : Optional [ str ] = None A username to use when connecting to Redis (optional)","title":"username"},{"location":"reference/cache/2-redis-cache/#starlite.cache.redis_cache_backend.RedisCacheBackendConfig.password","text":"password : Optional [ str ] = None A password to use when connecting to Redis (optional)","title":"password"},{"location":"reference/cache/3-memcached-cache/","text":"Memcached Cache Backend starlite.cache.memcached_cache_backend.MemcachedCacheBackend Bases: CacheBackendProtocol Memcached-based cache backend. __init__ __init__ ( config ) Initialize MemcachedCacheBackend . Parameters: Name Type Description Default config MemcachedCacheBackendConfig required configuration to connect to memcached. required get async get ( key ) Retrieve a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None . set async set ( key , value , expiration ) Set sa value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description None None delete async delete ( key ) Delete a value from the cache and remove the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description None None starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig Bases: BaseModel Memcached cache backend configuration. host class-attribute host : str Memcached host. port class-attribute port : Optional [ int ] = None memcached port (optional, defaults to 11211) pool_size class-attribute pool_size : Optional [ int ] = None Maximum number of memcached open connections (optional, defaults to 2) pool_minsize class-attribute pool_minsize : Optional [ int ] = None memcached minimum pool size (optional, by default set to pool_size ) serialize class-attribute serialize : Callable [[ Any ], bytes ] = pickle . dumps A callable to serialize data that goes into the cache from an object to bytes, defaults to pickle.dumps deserialize class-attribute deserialize : Callable [[ bytes ], Any ] = pickle . loads A callable to deserialize data coming from the cache from bytes to an object, defaults to pickle.loads","title":"Memcached Cache Backend"},{"location":"reference/cache/3-memcached-cache/#memcached-cache-backend","text":"","title":"Memcached Cache Backend"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend","text":"Bases: CacheBackendProtocol Memcached-based cache backend.","title":"MemcachedCacheBackend"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.__init__","text":"__init__ ( config ) Initialize MemcachedCacheBackend . Parameters: Name Type Description Default config MemcachedCacheBackendConfig required configuration to connect to memcached. required","title":"__init__()"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.get","text":"get ( key ) Retrieve a value from cache corresponding to the given key. Parameters: Name Type Description Default key str name of cached value. required Returns: Type Description Any Cached value if existing else None .","title":"get()"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.set","text":"set ( key , value , expiration ) Set sa value in cache for a given key for a duration determined by expiration. Parameters: Name Type Description Default key str key to cache value under. required value Any the value to be cached. required expiration int expiration of cached value in seconds. required Notes expiration is in seconds. return value is not used by Starlite internally. Returns: Type Description None None","title":"set()"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackend.delete","text":"delete ( key ) Delete a value from the cache and remove the given key. Parameters: Name Type Description Default key str key to be deleted from the cache. required Notes return value is not used by Starlite internally. Returns: Type Description None None","title":"delete()"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig","text":"Bases: BaseModel Memcached cache backend configuration.","title":"MemcachedCacheBackendConfig"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.host","text":"host : str Memcached host.","title":"host"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.port","text":"port : Optional [ int ] = None memcached port (optional, defaults to 11211)","title":"port"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.pool_size","text":"pool_size : Optional [ int ] = None Maximum number of memcached open connections (optional, defaults to 2)","title":"pool_size"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.pool_minsize","text":"pool_minsize : Optional [ int ] = None memcached minimum pool size (optional, by default set to pool_size )","title":"pool_minsize"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.serialize","text":"serialize : Callable [[ Any ], bytes ] = pickle . dumps A callable to serialize data that goes into the cache from an object to bytes, defaults to pickle.dumps","title":"serialize"},{"location":"reference/cache/3-memcached-cache/#starlite.cache.memcached_cache_backend.MemcachedCacheBackendConfig.deserialize","text":"deserialize : Callable [[ bytes ], Any ] = pickle . loads A callable to deserialize data coming from the cache from bytes to an object, defaults to pickle.loads","title":"deserialize"},{"location":"reference/config/0-app-config/","text":"App Config starlite.config.app.AppConfig Bases: BaseModel The parameters provided to the Starlite app are used to instantiate an instance, and then the instance is passed to any callbacks registered to on_app_init in the order they are provided. The final attribute values are used to instantiate the application object. after_exception class-attribute after_exception : SingleOrList [ AfterExceptionHookHandler ] An application level exception hook handler or list thereof. This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.). after_request class-attribute after_request : Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object which may be any subclass of Response . after_response class-attribute after_response : Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the. Request object and should not return any values. after_shutdown class-attribute after_shutdown : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called. after_startup class-attribute after_startup : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called. allowed_hosts class-attribute allowed_hosts : Optional [ Union [ List [ str ], AllowedHostsConfig ]] If set enables the builtin allowed hosts middleware. before_request class-attribute before_request : Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the. Request instance and any non- None return value is used for the response, bypassing the route handler. before_send class-attribute before_send : SingleOrList [ BeforeMessageSendHookHandler ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called. before_shutdown class-attribute before_shutdown : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called. before_startup class-attribute before_startup : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called. cache_config class-attribute cache_config : CacheConfig Configures caching behavior of the application. cache_control class-attribute cache_control : Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this app. Can be overridden by route handlers. compression_config class-attribute compression_config : Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware. cors_config class-attribute cors_config : Optional [ CORSConfig ] If set this enables the builtin CORS middleware. csrf_config class-attribute csrf_config : Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware. debug class-attribute debug : bool If True , app errors rendered as HTML with a stack trace. dependencies class-attribute dependencies : Dict [ str , Provide ] A string keyed dictionary of dependency Provider instances. etag class-attribute etag : Optional [ ETag ] An etag header of type ETag to add to route handlers of this app. Can be overridden by route handlers. exception_handlers class-attribute exception_handlers : ExceptionHandlersMap A dictionary that maps handler functions to status codes and/or exception types. guards class-attribute guards : List [ Guard ] A list of Guard callables. logging_config class-attribute logging_config : Optional [ BaseLoggingConfig ] An instance of BaseLoggingConfig subclass. middleware class-attribute middleware : List [ Middleware ] A list of Middleware . on_shutdown class-attribute on_shutdown : List [ LifeSpanHandler ] A list of LifeSpanHandler called during application shutdown. on_startup class-attribute on_startup : List [ LifeSpanHandler ] A list of LifeSpanHandler called during application startup. openapi_config class-attribute openapi_config : Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG opt class-attribute opt : Dict [ str , Any ] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . Can be overridden by routers and router handlers. parameters class-attribute parameters : ParametersMap A mapping of Parameter definitions available to all application paths. plugins class-attribute plugins : List [ PluginProtocol ] List of PluginProtocol . request_class class-attribute request_class : Optional [ Type [ Request ]] An optional subclass of Request to use for http connections. response_class class-attribute response_class : Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response. response_cookies class-attribute response_cookies : ResponseCookies A list of [Cookie](starlite.datastructures.Cookie] instances. response_headers class-attribute response_headers : ResponseHeadersMap A string keyed dictionary mapping ResponseHeader instances. route_handlers class-attribute route_handlers : List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of. Controller or any function decorated by the route handler decorators. security class-attribute security : List [ SecurityRequirement ] A list of dictionaries that will be added to the schema of all route handlers in the application. See. SecurityRequirement for details. static_files_config class-attribute static_files_config : SingleOrList [ StaticFilesConfig ] An instance or list of StaticFilesConfig . tags class-attribute tags : List [ str ] A list of string tags that will be appended to the schema of all route handlers under the application. template_config class-attribute template_config : Optional [ TemplateConfig ] An instance of TemplateConfig . websocket_class class-attribute websocket_class : Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections.","title":"App Config"},{"location":"reference/config/0-app-config/#app-config","text":"","title":"App Config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig","text":"Bases: BaseModel The parameters provided to the Starlite app are used to instantiate an instance, and then the instance is passed to any callbacks registered to on_app_init in the order they are provided. The final attribute values are used to instantiate the application object.","title":"AppConfig"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_exception","text":"after_exception : SingleOrList [ AfterExceptionHookHandler ] An application level exception hook handler or list thereof. This hook is called after an exception occurs. In difference to exception handlers, it is not meant to return a response - only to process the exception (e.g. log it, send it to Sentry etc.).","title":"after_exception"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_request","text":"after_request : Optional [ AfterRequestHookHandler ] A sync or async function executed after the route handler function returned and the response object has been resolved. Receives the response object which may be any subclass of Response .","title":"after_request"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_response","text":"after_response : Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the. Request object and should not return any values.","title":"after_response"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_shutdown","text":"after_shutdown : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, after all callables in the 'on_shutdown' list have been called.","title":"after_shutdown"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.after_startup","text":"after_startup : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, after all callables in the 'on_startup' list have been called.","title":"after_startup"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.allowed_hosts","text":"allowed_hosts : Optional [ Union [ List [ str ], AllowedHostsConfig ]] If set enables the builtin allowed hosts middleware.","title":"allowed_hosts"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_request","text":"before_request : Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the. Request instance and any non- None return value is used for the response, bypassing the route handler.","title":"before_request"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_send","text":"before_send : SingleOrList [ BeforeMessageSendHookHandler ] An application level before send hook handler or list thereof. This hook is called when the ASGI send function is called.","title":"before_send"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_shutdown","text":"before_shutdown : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI shutdown, before any callables in the 'on_shutdown' list have been called.","title":"before_shutdown"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.before_startup","text":"before_startup : SingleOrList [ LifeSpanHookHandler ] An application level life-span hook handler or list thereof. This hook is called during the ASGI startup, before any callables in the 'on_startup' list have been called.","title":"before_startup"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.cache_config","text":"cache_config : CacheConfig Configures caching behavior of the application.","title":"cache_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.cache_control","text":"cache_control : Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader to add to route handlers of this app. Can be overridden by route handlers.","title":"cache_control"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.compression_config","text":"compression_config : Optional [ CompressionConfig ] Configures compression behaviour of the application, this enabled a builtin or user defined Compression middleware.","title":"compression_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.cors_config","text":"cors_config : Optional [ CORSConfig ] If set this enables the builtin CORS middleware.","title":"cors_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.csrf_config","text":"csrf_config : Optional [ CSRFConfig ] If set this enables the builtin CSRF middleware.","title":"csrf_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.debug","text":"debug : bool If True , app errors rendered as HTML with a stack trace.","title":"debug"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.dependencies","text":"dependencies : Dict [ str , Provide ] A string keyed dictionary of dependency Provider instances.","title":"dependencies"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.etag","text":"etag : Optional [ ETag ] An etag header of type ETag to add to route handlers of this app. Can be overridden by route handlers.","title":"etag"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.exception_handlers","text":"exception_handlers : ExceptionHandlersMap A dictionary that maps handler functions to status codes and/or exception types.","title":"exception_handlers"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.guards","text":"guards : List [ Guard ] A list of Guard callables.","title":"guards"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.logging_config","text":"logging_config : Optional [ BaseLoggingConfig ] An instance of BaseLoggingConfig subclass.","title":"logging_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.middleware","text":"middleware : List [ Middleware ] A list of Middleware .","title":"middleware"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.on_shutdown","text":"on_shutdown : List [ LifeSpanHandler ] A list of LifeSpanHandler called during application shutdown.","title":"on_shutdown"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.on_startup","text":"on_startup : List [ LifeSpanHandler ] A list of LifeSpanHandler called during application startup.","title":"on_startup"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.openapi_config","text":"openapi_config : Optional [ OpenAPIConfig ] Defaults to DEFAULT_OPENAPI_CONFIG","title":"openapi_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.opt","text":"opt : Dict [ str , Any ] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . Can be overridden by routers and router handlers.","title":"opt"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.parameters","text":"parameters : ParametersMap A mapping of Parameter definitions available to all application paths.","title":"parameters"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.plugins","text":"plugins : List [ PluginProtocol ] List of PluginProtocol .","title":"plugins"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.request_class","text":"request_class : Optional [ Type [ Request ]] An optional subclass of Request to use for http connections.","title":"request_class"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.response_class","text":"response_class : Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as the app's default response.","title":"response_class"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.response_cookies","text":"response_cookies : ResponseCookies A list of [Cookie](starlite.datastructures.Cookie] instances.","title":"response_cookies"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.response_headers","text":"response_headers : ResponseHeadersMap A string keyed dictionary mapping ResponseHeader instances.","title":"response_headers"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.route_handlers","text":"route_handlers : List [ ControllerRouterHandler ] A required list of route handlers, which can include instances of Router , subclasses of. Controller or any function decorated by the route handler decorators.","title":"route_handlers"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.security","text":"security : List [ SecurityRequirement ] A list of dictionaries that will be added to the schema of all route handlers in the application. See. SecurityRequirement for details.","title":"security"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.static_files_config","text":"static_files_config : SingleOrList [ StaticFilesConfig ] An instance or list of StaticFilesConfig .","title":"static_files_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.tags","text":"tags : List [ str ] A list of string tags that will be appended to the schema of all route handlers under the application.","title":"tags"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.template_config","text":"template_config : Optional [ TemplateConfig ] An instance of TemplateConfig .","title":"template_config"},{"location":"reference/config/0-app-config/#starlite.config.app.AppConfig.websocket_class","text":"websocket_class : Optional [ Type [ WebSocket ]] An optional subclass of WebSocket to use for websocket connections.","title":"websocket_class"},{"location":"reference/config/1-cache-config/","text":"Cache Config starlite.config.cache.CacheConfig Bases: BaseModel Configuration for response caching. To enable response caching, pass an instance of this class to the Starlite constructor using the 'cache_config' key. backend class-attribute backend : Optional [ CacheBackendProtocol ] = None Instance conforming to CacheBackendProtocol , default. SimpleCacheBackend() expiration class-attribute expiration : int = 60 Default cache expiration in seconds. cache_key_builder class-attribute cache_key_builder : CacheKeyBuilder = default_cache_key_builder CacheKeyBuilder , default_cache_key_builder if not provided to_cache to_cache () Create a cache wrapper from the config. Returns: Type Description Cache An instance of Cache starlite.config.cache.default_cache_key_builder starlite . config . cache . default_cache_key_builder ( request ) Given a request object, returns a cache key by combining the path with the sorted query params. Parameters: Name Type Description Default request Request request used to generate cache key. required Returns: Name Type Description str str combination of url path and query parameters","title":"Cache Config"},{"location":"reference/config/1-cache-config/#cache-config","text":"","title":"Cache Config"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig","text":"Bases: BaseModel Configuration for response caching. To enable response caching, pass an instance of this class to the Starlite constructor using the 'cache_config' key.","title":"CacheConfig"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.backend","text":"backend : Optional [ CacheBackendProtocol ] = None Instance conforming to CacheBackendProtocol , default. SimpleCacheBackend()","title":"backend"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.expiration","text":"expiration : int = 60 Default cache expiration in seconds.","title":"expiration"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.cache_key_builder","text":"cache_key_builder : CacheKeyBuilder = default_cache_key_builder CacheKeyBuilder , default_cache_key_builder if not provided","title":"cache_key_builder"},{"location":"reference/config/1-cache-config/#starlite.config.cache.CacheConfig.to_cache","text":"to_cache () Create a cache wrapper from the config. Returns: Type Description Cache An instance of Cache","title":"to_cache()"},{"location":"reference/config/1-cache-config/#starlite.config.cache.default_cache_key_builder","text":"starlite . config . cache . default_cache_key_builder ( request ) Given a request object, returns a cache key by combining the path with the sorted query params. Parameters: Name Type Description Default request Request request used to generate cache key. required Returns: Name Type Description str str combination of url path and query parameters","title":"default_cache_key_builder()"},{"location":"reference/config/2-cors-config/","text":"CORS Config starlite.config.cors.CORSConfig Bases: BaseModel Configuration for CORS (Cross-Origin Resource Sharing). To enable CORS, pass an instance of this class to the Starlite constructor using the 'cors_config' key. allow_origins class-attribute allow_origins : List [ str ] = [ '*' ] List of origins that are allowed. Can use ' ' in any component of the path, e.g. 'domain. '. Sets the 'Access-Control-Allow-Origin' header. allow_methods class-attribute allow_methods : List [ Union [ Literal [ '*' ], Method ]] = [ '*' ] List of allowed HTTP methods. Sets the 'Access-Control-Allow-Methods' header. allow_headers class-attribute allow_headers : List [ str ] = [ '*' ] List of allowed headers. Sets the 'Access-Control-Allow-Headers' header. allow_credentials class-attribute allow_credentials : bool = False Boolean dictating whether or not to set the 'Access-Control-Allow-Credentials' header. allow_origin_regex class-attribute allow_origin_regex : Optional [ str ] = None Regex to match origins against. expose_headers class-attribute expose_headers : List [ str ] = [] List of headers that are exposed via the 'Access-Control-Expose-Headers' header. max_age class-attribute max_age : int = 600 Response caching TTL in seconds, defaults to 600. Sets the 'Access-Control-Max-Age' header.","title":"CORS Config"},{"location":"reference/config/2-cors-config/#cors-config","text":"","title":"CORS Config"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig","text":"Bases: BaseModel Configuration for CORS (Cross-Origin Resource Sharing). To enable CORS, pass an instance of this class to the Starlite constructor using the 'cors_config' key.","title":"CORSConfig"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_origins","text":"allow_origins : List [ str ] = [ '*' ] List of origins that are allowed. Can use ' ' in any component of the path, e.g. 'domain. '. Sets the 'Access-Control-Allow-Origin' header.","title":"allow_origins"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_methods","text":"allow_methods : List [ Union [ Literal [ '*' ], Method ]] = [ '*' ] List of allowed HTTP methods. Sets the 'Access-Control-Allow-Methods' header.","title":"allow_methods"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_headers","text":"allow_headers : List [ str ] = [ '*' ] List of allowed headers. Sets the 'Access-Control-Allow-Headers' header.","title":"allow_headers"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_credentials","text":"allow_credentials : bool = False Boolean dictating whether or not to set the 'Access-Control-Allow-Credentials' header.","title":"allow_credentials"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.allow_origin_regex","text":"allow_origin_regex : Optional [ str ] = None Regex to match origins against.","title":"allow_origin_regex"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.expose_headers","text":"expose_headers : List [ str ] = [] List of headers that are exposed via the 'Access-Control-Expose-Headers' header.","title":"expose_headers"},{"location":"reference/config/2-cors-config/#starlite.config.cors.CORSConfig.max_age","text":"max_age : int = 600 Response caching TTL in seconds, defaults to 600. Sets the 'Access-Control-Max-Age' header.","title":"max_age"},{"location":"reference/config/3-csrf-config/","text":"CSRF Config starlite.config.csrf.CSRFConfig Bases: BaseModel Configuration for CSRF (Cross Site Request Forgery) protection. To enable CSRF protection, pass an instance of this class to the Starlite constructor using the 'csrf_config' key. cookie_domain class-attribute cookie_domain : Optional [ str ] = None Specifies which hosts can receive the cookie. cookie_httponly class-attribute cookie_httponly : bool = False A boolean value indicating whether to set the HttpOnly attribute on the cookie. cookie_name class-attribute cookie_name : str = 'csrftoken' The CSRF cookie name. cookie_path class-attribute cookie_path : str = '/' The CSRF cookie path. cookie_samesite class-attribute cookie_samesite : Literal [ 'lax' , 'strict' , 'none' ] = 'lax' The value to set in the SameSite attribute of the cookie. cookie_secure class-attribute cookie_secure : bool = False A boolean value indicating whether to set the Secure attribute on the cookie. exclude class-attribute exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the CSRF middleware. exclude_from_csrf_key class-attribute exclude_from_csrf_key : str = 'exclude_from_csrf' An identifier to use on routes to disable CSRF for a particular route. header_name class-attribute header_name : str = 'x-csrftoken' The header that will be expected in each request. safe_methods class-attribute safe_methods : Set [ Method ] = { 'GET' , 'HEAD' } A set of \"safe methods\" that can set the cookie. secret class-attribute secret : str A string that is used to create an HMAC to sign the CSRF token.","title":"CSRF Config"},{"location":"reference/config/3-csrf-config/#csrf-config","text":"","title":"CSRF Config"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig","text":"Bases: BaseModel Configuration for CSRF (Cross Site Request Forgery) protection. To enable CSRF protection, pass an instance of this class to the Starlite constructor using the 'csrf_config' key.","title":"CSRFConfig"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_domain","text":"cookie_domain : Optional [ str ] = None Specifies which hosts can receive the cookie.","title":"cookie_domain"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_httponly","text":"cookie_httponly : bool = False A boolean value indicating whether to set the HttpOnly attribute on the cookie.","title":"cookie_httponly"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_name","text":"cookie_name : str = 'csrftoken' The CSRF cookie name.","title":"cookie_name"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_path","text":"cookie_path : str = '/' The CSRF cookie path.","title":"cookie_path"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_samesite","text":"cookie_samesite : Literal [ 'lax' , 'strict' , 'none' ] = 'lax' The value to set in the SameSite attribute of the cookie.","title":"cookie_samesite"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.cookie_secure","text":"cookie_secure : bool = False A boolean value indicating whether to set the Secure attribute on the cookie.","title":"cookie_secure"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.exclude","text":"exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the CSRF middleware.","title":"exclude"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.exclude_from_csrf_key","text":"exclude_from_csrf_key : str = 'exclude_from_csrf' An identifier to use on routes to disable CSRF for a particular route.","title":"exclude_from_csrf_key"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.header_name","text":"header_name : str = 'x-csrftoken' The header that will be expected in each request.","title":"header_name"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.safe_methods","text":"safe_methods : Set [ Method ] = { 'GET' , 'HEAD' } A set of \"safe methods\" that can set the cookie.","title":"safe_methods"},{"location":"reference/config/3-csrf-config/#starlite.config.csrf.CSRFConfig.secret","text":"secret : str A string that is used to create an HMAC to sign the CSRF token.","title":"secret"},{"location":"reference/config/4-compression-config/","text":"Compression Config starlite.config.compression.CompressionConfig Bases: BaseModel Configuration for response compression. To enable response compression, pass an instance of this class to the Starlite constructor using the 'compression_config' key. backend class-attribute backend : Literal [ 'gzip' , 'brotli' ] Literal of \"gzip\" or \"brotli\". brotli_gzip_fallback class-attribute brotli_gzip_fallback : bool = True Use GZIP if Brotli is not supported. brotli_lgblock class-attribute brotli_lgblock : Literal [ 0 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 ] = 0 Base 2 logarithm of the maximum input block size. Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0. brotli_lgwin class-attribute brotli_lgwin : conint ( ge = 10 , le = 24 ) = 22 Base 2 logarithm of size. Range is 10 to 24. Defaults to 22. brotli_mode class-attribute brotli_mode : Literal [ 'generic' , 'text' , 'font' ] = 'text' MODE_GENERIC, MODE_TEXT (for UTF-8 format text input, default) or MODE_FONT (for WOFF 2.0). brotli_quality class-attribute brotli_quality : conint ( ge = 0 , le = 11 ) = 5 Range [0-11], Controls the compression-speed vs compression-density tradeoff. The higher the quality, the slower the compression. exclude class-attribute exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the compression middleware. exclude_opt_key class-attribute exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable compression for a particular route. gzip_compress_level class-attribute gzip_compress_level : conint ( ge = 0 , le = 9 ) = 9 Range [0-9], see official docs . middleware_class class-attribute middleware_class : Type [ CompressionMiddleware ] = CompressionMiddleware Middleware class to use, should be a subclass of CompressionMiddleware. minimum_size class-attribute minimum_size : conint ( gt = 0 ) = 500 Minimum response size (bytes) to enable compression, affects all backends.","title":"Compression Config"},{"location":"reference/config/4-compression-config/#compression-config","text":"","title":"Compression Config"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig","text":"Bases: BaseModel Configuration for response compression. To enable response compression, pass an instance of this class to the Starlite constructor using the 'compression_config' key.","title":"CompressionConfig"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.backend","text":"backend : Literal [ 'gzip' , 'brotli' ] Literal of \"gzip\" or \"brotli\".","title":"backend"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_gzip_fallback","text":"brotli_gzip_fallback : bool = True Use GZIP if Brotli is not supported.","title":"brotli_gzip_fallback"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_lgblock","text":"brotli_lgblock : Literal [ 0 , 16 , 17 , 18 , 19 , 20 , 21 , 22 , 23 , 24 ] = 0 Base 2 logarithm of the maximum input block size. Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0.","title":"brotli_lgblock"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_lgwin","text":"brotli_lgwin : conint ( ge = 10 , le = 24 ) = 22 Base 2 logarithm of size. Range is 10 to 24. Defaults to 22.","title":"brotli_lgwin"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_mode","text":"brotli_mode : Literal [ 'generic' , 'text' , 'font' ] = 'text' MODE_GENERIC, MODE_TEXT (for UTF-8 format text input, default) or MODE_FONT (for WOFF 2.0).","title":"brotli_mode"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.brotli_quality","text":"brotli_quality : conint ( ge = 0 , le = 11 ) = 5 Range [0-11], Controls the compression-speed vs compression-density tradeoff. The higher the quality, the slower the compression.","title":"brotli_quality"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.exclude","text":"exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the compression middleware.","title":"exclude"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.exclude_opt_key","text":"exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable compression for a particular route.","title":"exclude_opt_key"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.gzip_compress_level","text":"gzip_compress_level : conint ( ge = 0 , le = 9 ) = 9 Range [0-9], see official docs .","title":"gzip_compress_level"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.middleware_class","text":"middleware_class : Type [ CompressionMiddleware ] = CompressionMiddleware Middleware class to use, should be a subclass of CompressionMiddleware.","title":"middleware_class"},{"location":"reference/config/4-compression-config/#starlite.config.compression.CompressionConfig.minimum_size","text":"minimum_size : conint ( gt = 0 ) = 500 Minimum response size (bytes) to enable compression, affects all backends.","title":"minimum_size"},{"location":"reference/config/5-openapi-config/","text":"OpenAPI Config starlite.config.openapi.OpenAPIConfig Bases: BaseModel Configuration for OpenAPI. To enable OpenAPI schema generation and serving, pass an instance of this class to the Starlite constructor using the 'openapi_config' kwargs. by_alias class-attribute by_alias : bool = True Render pydantic model schema using field aliases, if defined. contact class-attribute contact : Optional [ Contact ] = None API contact information, should be an Contact instance. create_examples class-attribute create_examples : bool = False Generate examples using the pydantic-factories library. description class-attribute description : Optional [ str ] = None API description. enabled_endpoints class-attribute enabled_endpoints : Set [ str ] = { 'redoc' , 'swagger' , 'elements' , 'openapi.json' , 'openapi.yaml' } A set of the enabled documentation sites and schema download endpoints. external_docs class-attribute external_docs : Optional [ ExternalDocumentation ] = None Links to external documentation. Should be an instance of ExternalDocumentation . license class-attribute license : Optional [ License ] = None API Licensing information. Should be an instance of License . openapi_controller class-attribute openapi_controller : Type [ OpenAPIController ] = OpenAPIController Controller for generating OpenAPI routes. Must be subclass of OpenAPIController . root_schema_site class-attribute root_schema_site : Literal [ 'redoc' , 'swagger' , 'elements' ] = 'redoc' The static schema generator to use for the \"root\" path of /schema/ . security class-attribute security : Optional [ List [ SecurityRequirement ]] = None API Security requirements information. Should be an instance of SecurityRequirement . servers class-attribute servers : List [ Server ] = [ Server ( url = '/' )] A list of Server instances. summary class-attribute summary : Optional [ str ] = None A summary text. tags class-attribute tags : Optional [ List [ Tag ]] = None A list of Tag instances. terms_of_service class-attribute terms_of_service : Optional [ AnyUrl ] = None URL to page that contains terms of service. title class-attribute title : str Title of API documentation. use_handler_docstrings class-attribute use_handler_docstrings : bool = False Draw operation description from route handler docstring if not otherwise provided. version class-attribute version : str API version, e.g. '1.0.0'. webhooks class-attribute webhooks : Optional [ Dict [ str , Union [ PathItem , Reference ]]] = None A mapping of key to either PathItem or. Reference objects.","title":"OpenAPI Config"},{"location":"reference/config/5-openapi-config/#openapi-config","text":"","title":"OpenAPI Config"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig","text":"Bases: BaseModel Configuration for OpenAPI. To enable OpenAPI schema generation and serving, pass an instance of this class to the Starlite constructor using the 'openapi_config' kwargs.","title":"OpenAPIConfig"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.by_alias","text":"by_alias : bool = True Render pydantic model schema using field aliases, if defined.","title":"by_alias"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.contact","text":"contact : Optional [ Contact ] = None API contact information, should be an Contact instance.","title":"contact"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.create_examples","text":"create_examples : bool = False Generate examples using the pydantic-factories library.","title":"create_examples"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.description","text":"description : Optional [ str ] = None API description.","title":"description"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.enabled_endpoints","text":"enabled_endpoints : Set [ str ] = { 'redoc' , 'swagger' , 'elements' , 'openapi.json' , 'openapi.yaml' } A set of the enabled documentation sites and schema download endpoints.","title":"enabled_endpoints"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.external_docs","text":"external_docs : Optional [ ExternalDocumentation ] = None Links to external documentation. Should be an instance of ExternalDocumentation .","title":"external_docs"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.license","text":"license : Optional [ License ] = None API Licensing information. Should be an instance of License .","title":"license"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.openapi_controller","text":"openapi_controller : Type [ OpenAPIController ] = OpenAPIController Controller for generating OpenAPI routes. Must be subclass of OpenAPIController .","title":"openapi_controller"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.root_schema_site","text":"root_schema_site : Literal [ 'redoc' , 'swagger' , 'elements' ] = 'redoc' The static schema generator to use for the \"root\" path of /schema/ .","title":"root_schema_site"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.security","text":"security : Optional [ List [ SecurityRequirement ]] = None API Security requirements information. Should be an instance of SecurityRequirement .","title":"security"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.servers","text":"servers : List [ Server ] = [ Server ( url = '/' )] A list of Server instances.","title":"servers"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.summary","text":"summary : Optional [ str ] = None A summary text.","title":"summary"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.tags","text":"tags : Optional [ List [ Tag ]] = None A list of Tag instances.","title":"tags"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.terms_of_service","text":"terms_of_service : Optional [ AnyUrl ] = None URL to page that contains terms of service.","title":"terms_of_service"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.title","text":"title : str Title of API documentation.","title":"title"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.use_handler_docstrings","text":"use_handler_docstrings : bool = False Draw operation description from route handler docstring if not otherwise provided.","title":"use_handler_docstrings"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.version","text":"version : str API version, e.g. '1.0.0'.","title":"version"},{"location":"reference/config/5-openapi-config/#starlite.config.openapi.OpenAPIConfig.webhooks","text":"webhooks : Optional [ Dict [ str , Union [ PathItem , Reference ]]] = None A mapping of key to either PathItem or. Reference objects.","title":"webhooks"},{"location":"reference/config/6-static-files-config/","text":"Static-Files Config starlite.config.static_files.StaticFilesConfig Bases: BaseModel Configuration for static file service. To enable static files, pass an instance of this class to the Starlite constructor using the 'static_files_config' key. directories class-attribute directories : List [ DirectoryPath ] A list of directories to serve files from. exception_handlers class-attribute exception_handlers : Optional [ ExceptionHandlersMap ] = None A dictionary that maps handler functions to status codes and/or exception types. file_system class-attribute file_system : Any = BaseLocalFileSystem () The file_system spec to use for serving files. Notes A file_system is a class that adheres to the FileSystemProtocol . You can use any of the file systems exported from the fsspec library for this purpose. guards class-attribute guards : Optional [ List [ Guard ]] = None A list of Guard callables. html_mode class-attribute html_mode : bool = False Flag dictating whether serving html. If true, the default file will be 'index.html'. name class-attribute name : Optional [ str ] = None An optional string identifying the static files handler. opt class-attribute opt : Optional [ Dict [ str , Any ]] = None A string key dictionary of arbitrary values that will be added to the static files handler. path class-attribute path : constr ( min_length = 1 ) Path to serve static files from. Note that the path cannot contain path parameters. send_as_attachment class-attribute send_as_attachment : bool = False Whether to send the file as an attachment.","title":"Static-Files Config"},{"location":"reference/config/6-static-files-config/#static-files-config","text":"","title":"Static-Files Config"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig","text":"Bases: BaseModel Configuration for static file service. To enable static files, pass an instance of this class to the Starlite constructor using the 'static_files_config' key.","title":"StaticFilesConfig"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.directories","text":"directories : List [ DirectoryPath ] A list of directories to serve files from.","title":"directories"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.exception_handlers","text":"exception_handlers : Optional [ ExceptionHandlersMap ] = None A dictionary that maps handler functions to status codes and/or exception types.","title":"exception_handlers"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.file_system","text":"file_system : Any = BaseLocalFileSystem () The file_system spec to use for serving files. Notes A file_system is a class that adheres to the FileSystemProtocol . You can use any of the file systems exported from the fsspec library for this purpose.","title":"file_system"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.guards","text":"guards : Optional [ List [ Guard ]] = None A list of Guard callables.","title":"guards"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.html_mode","text":"html_mode : bool = False Flag dictating whether serving html. If true, the default file will be 'index.html'.","title":"html_mode"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.name","text":"name : Optional [ str ] = None An optional string identifying the static files handler.","title":"name"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.opt","text":"opt : Optional [ Dict [ str , Any ]] = None A string key dictionary of arbitrary values that will be added to the static files handler.","title":"opt"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.path","text":"path : constr ( min_length = 1 ) Path to serve static files from. Note that the path cannot contain path parameters.","title":"path"},{"location":"reference/config/6-static-files-config/#starlite.config.static_files.StaticFilesConfig.send_as_attachment","text":"send_as_attachment : bool = False Whether to send the file as an attachment.","title":"send_as_attachment"},{"location":"reference/config/7-template-config/","text":"Template Config starlite.config.template.TemplateConfig Bases: Generic [ T ] , GenericModel Configuration for Templating. To enable templating, pass an instance of this class to the Starlite constructor using the 'template_config' key. directory class-attribute directory : Optional [ Union [ DirectoryPath , List [ DirectoryPath ]]] = None A directory or list of directories from which to serve templates. engine class-attribute engine : Union [ Type [ T ], T ] A template engine adhering to the TemplateEngineProtocol . engine_callback class-attribute engine_callback : Optional [ Callable [[ T ], None ]] = None A callback function that allows modifying the instantiated templating protocol. engine_instance property engine_instance : T Return the template engine instance. to_engine to_engine () Instantiate the template engine.","title":"Template Config"},{"location":"reference/config/7-template-config/#template-config","text":"","title":"Template Config"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig","text":"Bases: Generic [ T ] , GenericModel Configuration for Templating. To enable templating, pass an instance of this class to the Starlite constructor using the 'template_config' key.","title":"TemplateConfig"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.directory","text":"directory : Optional [ Union [ DirectoryPath , List [ DirectoryPath ]]] = None A directory or list of directories from which to serve templates.","title":"directory"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.engine","text":"engine : Union [ Type [ T ], T ] A template engine adhering to the TemplateEngineProtocol .","title":"engine"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.engine_callback","text":"engine_callback : Optional [ Callable [[ T ], None ]] = None A callback function that allows modifying the instantiated templating protocol.","title":"engine_callback"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.engine_instance","text":"engine_instance : T Return the template engine instance.","title":"engine_instance"},{"location":"reference/config/7-template-config/#starlite.config.template.TemplateConfig.to_engine","text":"to_engine () Instantiate the template engine.","title":"to_engine()"},{"location":"reference/config/8-logging-config/","text":"Logging Config starlite.config.logging.BaseLoggingConfig Bases: ABC Abstract class that should be extended by logging configs. configure abstractmethod configure () Return logger with the given configuration. Returns: Type Description GetLogger A 'logging.getLogger' like function. starlite.config.logging.LoggingConfig Bases: BaseLoggingConfig , BaseModel Configuration class for standard logging. Notes If 'picologging' is installed it will be used by default. disable_existing_loggers class-attribute disable_existing_loggers : bool = False Whether any existing non-root loggers are to be disabled. filters class-attribute filters : Optional [ Dict [ str , Dict [ str , Any ]]] = None A dict in which each key is a filter id and each value is a dict describing how to configure the corresponding Filter instance. formatters class-attribute formatters : Dict [ str , Dict [ str , Any ]] = { \"standard\" : { \"format\" : \" %(levelname)s - %(asctime)s - %(name)s - %(module)s - %(message)s \" } } handlers class-attribute handlers : Dict [ str , Dict [ str , Any ]] = Field ( default_factory = get_default_handlers ) A dict in which each key is a handler id and each value is a dict describing how to configure the corresponding Handler instance. incremental class-attribute incremental : bool = False Whether the configuration is to be interpreted as incremental to the existing configuration. Notes This option is ignored for 'picologging' loggers class-attribute loggers : Dict [ str , Dict [ str , Any ]] = { \"starlite\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ], \"propagate\" : False } } A dict in which each key is a logger name and each value is a dict describing how to configure the corresponding Logger instance. propagate class-attribute propagate : bool = True If messages must propagate to handlers higher up the logger hierarchy from this logger. root class-attribute root : Dict [ str , Union [ Dict [ str , Any ], List [ Any ], str ]] = { \"handlers\" : [ \"queue_listener\" ], \"level\" : \"INFO\" , } This will be the configuration for the root logger. Processing of the configuration will be as for any logger, except that the propagate setting will not be applicable. starlite.config.logging.StructLoggingConfig Bases: BaseLoggingConfig , BaseModel Configuration class for structlog. Notes requires 'structlog' to be installed. cache_logger_on_first_use class-attribute cache_logger_on_first_use : bool = True Whether to cache the logger configuration and reuse. context_class class-attribute context_class : Optional [ Dict [ str , Any ]] = None Context class (a 'contextvar' context) for the logger. logger_factory class-attribute logger_factory : Optional [ Callable [ ... , WrappedLogger ]] = Field ( default_factory = default_logger_factory ) Logger factory to use. processors class-attribute processors : Optional [ List [ Processor ]] = Field ( default_factory = default_structlog_processors ) Iterable of structlog logging processors. wrapper_class class-attribute wrapper_class : Optional [ Type [ BindableLogger ]] = Field ( default_factory = default_wrapper_class ) Structlog bindable logger.","title":"Logging Config"},{"location":"reference/config/8-logging-config/#logging-config","text":"","title":"Logging Config"},{"location":"reference/config/8-logging-config/#starlite.config.logging.BaseLoggingConfig","text":"Bases: ABC Abstract class that should be extended by logging configs.","title":"BaseLoggingConfig"},{"location":"reference/config/8-logging-config/#starlite.config.logging.BaseLoggingConfig.configure","text":"configure () Return logger with the given configuration. Returns: Type Description GetLogger A 'logging.getLogger' like function.","title":"configure()"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig","text":"Bases: BaseLoggingConfig , BaseModel Configuration class for standard logging. Notes If 'picologging' is installed it will be used by default.","title":"LoggingConfig"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.disable_existing_loggers","text":"disable_existing_loggers : bool = False Whether any existing non-root loggers are to be disabled.","title":"disable_existing_loggers"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.filters","text":"filters : Optional [ Dict [ str , Dict [ str , Any ]]] = None A dict in which each key is a filter id and each value is a dict describing how to configure the corresponding Filter instance.","title":"filters"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.formatters","text":"formatters : Dict [ str , Dict [ str , Any ]] = { \"standard\" : { \"format\" : \" %(levelname)s - %(asctime)s - %(name)s - %(module)s - %(message)s \" } }","title":"formatters"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.handlers","text":"handlers : Dict [ str , Dict [ str , Any ]] = Field ( default_factory = get_default_handlers ) A dict in which each key is a handler id and each value is a dict describing how to configure the corresponding Handler instance.","title":"handlers"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.incremental","text":"incremental : bool = False Whether the configuration is to be interpreted as incremental to the existing configuration. Notes This option is ignored for 'picologging'","title":"incremental"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.loggers","text":"loggers : Dict [ str , Dict [ str , Any ]] = { \"starlite\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ], \"propagate\" : False } } A dict in which each key is a logger name and each value is a dict describing how to configure the corresponding Logger instance.","title":"loggers"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.propagate","text":"propagate : bool = True If messages must propagate to handlers higher up the logger hierarchy from this logger.","title":"propagate"},{"location":"reference/config/8-logging-config/#starlite.config.logging.LoggingConfig.root","text":"root : Dict [ str , Union [ Dict [ str , Any ], List [ Any ], str ]] = { \"handlers\" : [ \"queue_listener\" ], \"level\" : \"INFO\" , } This will be the configuration for the root logger. Processing of the configuration will be as for any logger, except that the propagate setting will not be applicable.","title":"root"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig","text":"Bases: BaseLoggingConfig , BaseModel Configuration class for structlog. Notes requires 'structlog' to be installed.","title":"StructLoggingConfig"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.cache_logger_on_first_use","text":"cache_logger_on_first_use : bool = True Whether to cache the logger configuration and reuse.","title":"cache_logger_on_first_use"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.context_class","text":"context_class : Optional [ Dict [ str , Any ]] = None Context class (a 'contextvar' context) for the logger.","title":"context_class"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.logger_factory","text":"logger_factory : Optional [ Callable [ ... , WrappedLogger ]] = Field ( default_factory = default_logger_factory ) Logger factory to use.","title":"logger_factory"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.processors","text":"processors : Optional [ List [ Processor ]] = Field ( default_factory = default_structlog_processors ) Iterable of structlog logging processors.","title":"processors"},{"location":"reference/config/8-logging-config/#starlite.config.logging.StructLoggingConfig.wrapper_class","text":"wrapper_class : Optional [ Type [ BindableLogger ]] = Field ( default_factory = default_wrapper_class ) Structlog bindable logger.","title":"wrapper_class"},{"location":"reference/config/9-allowed-hosts-config/","text":"Allowed Hosts Config starlite.config.AllowedHostsConfig Bases: BaseModel Configuration for allowed hosts protection. To enable allowed hosts protection, pass an instance of this class to the Starlite constructor using the 'allowed_hosts' key. allowed_hosts class-attribute allowed_hosts : List [ str ] = [ '*' ] A list of trusted hosts. Use ' ' to allow all hosts, or prefix domains with ' .' to allow all sub domains. exclude class-attribute exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the Allowed Hosts middleware. exclude_opt_key class-attribute exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable hosts check for a particular route. scopes class-attribute scopes : Optional [ Scopes ] = None ASGI scopes processed by the middleware, if None both 'http' and 'websocket' will be processed. www_redirect class-attribute www_redirect : bool = True A boolean dictating whether to redirect requests that start with 'www.' and otherwise match a trusted host.","title":"Allowed Hosts Config"},{"location":"reference/config/9-allowed-hosts-config/#allowed-hosts-config","text":"","title":"Allowed Hosts Config"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.AllowedHostsConfig","text":"Bases: BaseModel Configuration for allowed hosts protection. To enable allowed hosts protection, pass an instance of this class to the Starlite constructor using the 'allowed_hosts' key.","title":"AllowedHostsConfig"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.allowed_hosts","text":"allowed_hosts : List [ str ] = [ '*' ] A list of trusted hosts. Use ' ' to allow all hosts, or prefix domains with ' .' to allow all sub domains.","title":"allowed_hosts"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.exclude","text":"exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the Allowed Hosts middleware.","title":"exclude"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.exclude_opt_key","text":"exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable hosts check for a particular route.","title":"exclude_opt_key"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.scopes","text":"scopes : Optional [ Scopes ] = None ASGI scopes processed by the middleware, if None both 'http' and 'websocket' will be processed.","title":"scopes"},{"location":"reference/config/9-allowed-hosts-config/#starlite.config.allowed_hosts.AllowedHostsConfig.www_redirect","text":"www_redirect : bool = True A boolean dictating whether to redirect requests that start with 'www.' and otherwise match a trusted host.","title":"www_redirect"},{"location":"reference/connection/0-asgi-connection/","text":"ASGI Connection starlite.connection.base.User module-attribute starlite . connection . base . User = TypeVar ( 'User' ) starlite.connection.base.Auth module-attribute starlite . connection . base . Auth = TypeVar ( 'Auth' ) starlite.connection.base.Handler module-attribute starlite . connection . base . Handler = TypeVar ( 'Handler' ) starlite.connection.base.ASGIConnection Bases: Generic [ Handler , User , Auth ] The base ASGI connection container. app property app : Starlite Return the app for this connection. Returns: Type Description Starlite The Starlite application instance auth property auth : Auth Return the auth data of this connection's Scope . Raises: Type Description ImproperlyConfiguredException If 'auth' is not set in scope via an 'AuthMiddleware', raises an exception Returns: Type Description Auth A type correlating to the generic variable Auth. base_url property base_url : URL Return the base URL of this connection's Scope . Returns: Type Description URL A URL instance constructed from the request's scope, representing only the base part URL (host + domain + prefix) of the request. cache property cache : Cache Return the Cache for this connection. Returns: Type Description Cache A 'Cache' instance. client property client : Optional [ Address ] Return the client data of this connection's Scope . Returns: Type Description Optional [ Address ] A two tuple of the host name and port number. cookies property cookies : Dict [ str , str ] Return the cookies of this connection's Scope . Returns: Type Description Dict [ str , str ] Returns any cookies stored in the header as a parsed dictionary. headers property headers : Headers Return the headers of this connection's Scope . Returns: Type Description Headers A Headers instance with the request's scope[\"headers\"] value. logger property logger : Logger Return the Logger instance for this connection. Returns: Type Description Logger A 'Logger' instance. Raises: Type Description ImproperlyConfiguredException if 'log_config' has not been passed to the Starlite constructor. path_params property path_params : Dict [ str , Any ] Return the path_params of this connection's Scope . Returns: Type Description Dict [ str , Any ] A string keyed dictionary of path parameter values. query_params property query_params : MultiDict Return the query parameters of this connection's Scope . Returns: Type Description MultiDict A normalized dict of query parameters. Multiple values for the same key are returned as a list. receive instance-attribute receive = receive route_handler property route_handler : Handler Return the route_handler for this connection. Returns: Type Description Handler The target route handler instance. scope instance-attribute scope = scope send instance-attribute send = send session property session : Dict [ str , Any ] Return the session for this connection if a session was previously set in the Scope Returns: Type Description Dict [ str , Any ] A dictionary representing the session value - if existing. Raises: Type Description ImproperlyConfiguredException if session is not set in scope. state property state : State Return the State of this connection. Returns: Type Description State A State instance constructed from the scope[\"state\"] value. url property url : URL Return the URL of this connection's Scope . Returns: Type Description URL A URL instance constructed from the request's scope. user property user : User Return the user data of this connection's Scope . Raises: Type Description ImproperlyConfiguredException If 'user' is not set in scope via an 'AuthMiddleware', raises an exception Returns: Type Description User A type correlating to the generic variable User. __init__ __init__ ( scope , receive = empty_receive , send = empty_send ) Initialize ASGIConnection . Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send clear_session clear_session () Remove the session from the connection's Scope . If the Starlite SessionMiddleware is enabled, this will cause the session data to be cleared. Returns: Type Description None None. set_session set_session ( value ) Set the session in the connection's Scope . If the Starlite SessionMiddleware is enabled, the session will be added to the response as a cookie header. Parameters: Name Type Description Default value Union [ Dict [ str , Any ], BaseModel , EmptyType ] Dictionary or pydantic model instance for the session data. required Returns: Type Description None None. url_for url_for ( name , ** path_parameters ) Return the url for a given route handler name. Parameters: Name Type Description Default name str The 'name' of the request route handler. required **path_parameters Dict [ str , Any ] Values for path parameters in the route {} Raises: Type Description NoRouteMatchFoundException If route with 'name' does not exist, path parameters are missing or have a wrong type. Returns: Type Description str A string representing the absolute url of the route handler. url_for_static_asset url_for_static_asset ( name , file_path ) Receives a static files handler name, an asset file path and returns resolved absolute url to the asset. Parameters: Name Type Description Default name str A static handler unique name. required file_path str a string containing path to an asset. required Raises: Type Description NoRouteMatchFoundException If static files handler with 'name' does not exist. Returns: Type Description str A string representing absolute url to the asset.","title":"ASGI Connection"},{"location":"reference/connection/0-asgi-connection/#asgi-connection","text":"","title":"ASGI Connection"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.User","text":"starlite . connection . base . User = TypeVar ( 'User' )","title":"User"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.Auth","text":"starlite . connection . base . Auth = TypeVar ( 'Auth' )","title":"Auth"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.Handler","text":"starlite . connection . base . Handler = TypeVar ( 'Handler' )","title":"Handler"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection","text":"Bases: Generic [ Handler , User , Auth ] The base ASGI connection container.","title":"ASGIConnection"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.app","text":"app : Starlite Return the app for this connection. Returns: Type Description Starlite The Starlite application instance","title":"app"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.auth","text":"auth : Auth Return the auth data of this connection's Scope . Raises: Type Description ImproperlyConfiguredException If 'auth' is not set in scope via an 'AuthMiddleware', raises an exception Returns: Type Description Auth A type correlating to the generic variable Auth.","title":"auth"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.base_url","text":"base_url : URL Return the base URL of this connection's Scope . Returns: Type Description URL A URL instance constructed from the request's scope, representing only the base part URL (host + domain + prefix) of the request.","title":"base_url"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.cache","text":"cache : Cache Return the Cache for this connection. Returns: Type Description Cache A 'Cache' instance.","title":"cache"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.client","text":"client : Optional [ Address ] Return the client data of this connection's Scope . Returns: Type Description Optional [ Address ] A two tuple of the host name and port number.","title":"client"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.cookies","text":"cookies : Dict [ str , str ] Return the cookies of this connection's Scope . Returns: Type Description Dict [ str , str ] Returns any cookies stored in the header as a parsed dictionary.","title":"cookies"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.headers","text":"headers : Headers Return the headers of this connection's Scope . Returns: Type Description Headers A Headers instance with the request's scope[\"headers\"] value.","title":"headers"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.logger","text":"logger : Logger Return the Logger instance for this connection. Returns: Type Description Logger A 'Logger' instance. Raises: Type Description ImproperlyConfiguredException if 'log_config' has not been passed to the Starlite constructor.","title":"logger"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.path_params","text":"path_params : Dict [ str , Any ] Return the path_params of this connection's Scope . Returns: Type Description Dict [ str , Any ] A string keyed dictionary of path parameter values.","title":"path_params"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.query_params","text":"query_params : MultiDict Return the query parameters of this connection's Scope . Returns: Type Description MultiDict A normalized dict of query parameters. Multiple values for the same key are returned as a list.","title":"query_params"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.receive","text":"receive = receive","title":"receive"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.route_handler","text":"route_handler : Handler Return the route_handler for this connection. Returns: Type Description Handler The target route handler instance.","title":"route_handler"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.scope","text":"scope = scope","title":"scope"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.send","text":"send = send","title":"send"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.session","text":"session : Dict [ str , Any ] Return the session for this connection if a session was previously set in the Scope Returns: Type Description Dict [ str , Any ] A dictionary representing the session value - if existing. Raises: Type Description ImproperlyConfiguredException if session is not set in scope.","title":"session"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.state","text":"state : State Return the State of this connection. Returns: Type Description State A State instance constructed from the scope[\"state\"] value.","title":"state"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.url","text":"url : URL Return the URL of this connection's Scope . Returns: Type Description URL A URL instance constructed from the request's scope.","title":"url"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.user","text":"user : User Return the user data of this connection's Scope . Raises: Type Description ImproperlyConfiguredException If 'user' is not set in scope via an 'AuthMiddleware', raises an exception Returns: Type Description User A type correlating to the generic variable User.","title":"user"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.__init__","text":"__init__ ( scope , receive = empty_receive , send = empty_send ) Initialize ASGIConnection . Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send","title":"__init__()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.clear_session","text":"clear_session () Remove the session from the connection's Scope . If the Starlite SessionMiddleware is enabled, this will cause the session data to be cleared. Returns: Type Description None None.","title":"clear_session()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.set_session","text":"set_session ( value ) Set the session in the connection's Scope . If the Starlite SessionMiddleware is enabled, the session will be added to the response as a cookie header. Parameters: Name Type Description Default value Union [ Dict [ str , Any ], BaseModel , EmptyType ] Dictionary or pydantic model instance for the session data. required Returns: Type Description None None.","title":"set_session()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.url_for","text":"url_for ( name , ** path_parameters ) Return the url for a given route handler name. Parameters: Name Type Description Default name str The 'name' of the request route handler. required **path_parameters Dict [ str , Any ] Values for path parameters in the route {} Raises: Type Description NoRouteMatchFoundException If route with 'name' does not exist, path parameters are missing or have a wrong type. Returns: Type Description str A string representing the absolute url of the route handler.","title":"url_for()"},{"location":"reference/connection/0-asgi-connection/#starlite.connection.base.ASGIConnection.url_for_static_asset","text":"url_for_static_asset ( name , file_path ) Receives a static files handler name, an asset file path and returns resolved absolute url to the asset. Parameters: Name Type Description Default name str A static handler unique name. required file_path str a string containing path to an asset. required Raises: Type Description NoRouteMatchFoundException If static files handler with 'name' does not exist. Returns: Type Description str A string representing absolute url to the asset.","title":"url_for_static_asset()"},{"location":"reference/connection/1-request/","text":"Request starlite.connection.request.Request Bases: Generic [ User , Auth ] , ASGIConnection [ HTTPRouteHandler , User , Auth ] The Starlite Request class. content_type property content_type : Tuple [ str , Dict [ str , str ]] Parse the request's 'Content-Type' header, returning the header value and any options as a dictionary. Returns: Type Description Tuple [ str , Dict [ str , str ]] A tuple with the parsed value and a dictionary containing any options send in it. method property method : Method Return the request method. Returns: Type Description Method The request Method receive class-attribute receive : Receive The ASGI receive function. scope class-attribute scope : HTTPScope The ASGI scope attached to the connection. send class-attribute send : Send The ASGI send function. __init__ __init__ ( scope , receive = empty_receive , send = empty_send ) Initialize Request . Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send body async body () Return the body of the request. Returns: Type Description bytes A byte-string representing the body of the request. form async form () Retrieve form data from the request. If the request is either a 'multipart/form-data' or an 'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the request, otherwise, an empty instance. Returns: Type Description FormMultiDict A FormMultiDict instance json async json () Retrieve the json request body from the request. Returns: Type Description Any An arbitrary value msgpack async msgpack () Retrieve the MessagePack request body from the request. Returns: Type Description Any An arbitrary value send_push_promise async send_push_promise ( path ) Send a push promise. This method requires the http.response.push extension to be sent from the ASGI server. Parameters: Name Type Description Default path str Path to send the promise to. required Returns: Type Description None None stream async stream () Return an async generator that streams chunks of bytes. Returns: Type Description AsyncGenerator [ bytes , None] An async generator. Raises: Type Description RuntimeError if the stream is already consumed","title":"Request"},{"location":"reference/connection/1-request/#request","text":"","title":"Request"},{"location":"reference/connection/1-request/#starlite.connection.request.Request","text":"Bases: Generic [ User , Auth ] , ASGIConnection [ HTTPRouteHandler , User , Auth ] The Starlite Request class.","title":"Request"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.content_type","text":"content_type : Tuple [ str , Dict [ str , str ]] Parse the request's 'Content-Type' header, returning the header value and any options as a dictionary. Returns: Type Description Tuple [ str , Dict [ str , str ]] A tuple with the parsed value and a dictionary containing any options send in it.","title":"content_type"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.method","text":"method : Method Return the request method. Returns: Type Description Method The request Method","title":"method"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.receive","text":"receive : Receive The ASGI receive function.","title":"receive"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.scope","text":"scope : HTTPScope The ASGI scope attached to the connection.","title":"scope"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.send","text":"send : Send The ASGI send function.","title":"send"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.__init__","text":"__init__ ( scope , receive = empty_receive , send = empty_send ) Initialize Request . Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send","title":"__init__()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.body","text":"body () Return the body of the request. Returns: Type Description bytes A byte-string representing the body of the request.","title":"body()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.form","text":"form () Retrieve form data from the request. If the request is either a 'multipart/form-data' or an 'application/x-www-form- urlencoded', return a FormMultiDict instance populated with the values sent in the request, otherwise, an empty instance. Returns: Type Description FormMultiDict A FormMultiDict instance","title":"form()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.json","text":"json () Retrieve the json request body from the request. Returns: Type Description Any An arbitrary value","title":"json()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.msgpack","text":"msgpack () Retrieve the MessagePack request body from the request. Returns: Type Description Any An arbitrary value","title":"msgpack()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.send_push_promise","text":"send_push_promise ( path ) Send a push promise. This method requires the http.response.push extension to be sent from the ASGI server. Parameters: Name Type Description Default path str Path to send the promise to. required Returns: Type Description None None","title":"send_push_promise()"},{"location":"reference/connection/1-request/#starlite.connection.request.Request.stream","text":"stream () Return an async generator that streams chunks of bytes. Returns: Type Description AsyncGenerator [ bytes , None] An async generator. Raises: Type Description RuntimeError if the stream is already consumed","title":"stream()"},{"location":"reference/connection/2-websocket/","text":"WebSocket starlite.connection.websocket.WebSocket Bases: Generic [ User , Auth ] , ASGIConnection [ WebsocketRouteHandler , User , Auth ] The Starlite WebSocket class. receive class-attribute receive : Receive The ASGI receive function. scope class-attribute scope : WebSocketScope The ASGI scope attached to the connection. send class-attribute send : Send The ASGI send function. __init__ __init__ ( scope , receive = empty_receive , send = empty_send ) Initialize WebSocket . Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send accept async accept ( subprotocols = None , headers = None ) Accept the incoming connection. This method should be called before receiving data. Parameters: Name Type Description Default subprotocols Optional [ str ] Websocket sub-protocol to use. None headers Optional [ Union [ Headers , Dict [ str , Any ], List [ Tuple [ bytes , bytes ]]]] Headers to set on the data sent. None Returns: Type Description None None close async close ( code = WS_1000_NORMAL_CLOSURE , reason = None ) Send an 'websocket.close' event. Parameters: Name Type Description Default code int Status code. WS_1000_NORMAL_CLOSURE reason Optional [ str ] Reason for closing the connection None Returns: Type Description None None receive_bytes async receive_bytes () Receive data as bytes. Returns: Type Description bytes A byte-string. receive_data async receive_data ( mode ) Receive an 'websocket.receive' event and returns the data stored on it. Parameters: Name Type Description Default mode Literal ['binary', 'text'] The respective event key to use. required Returns: Type Description Union [ str , bytes ] The event's data. receive_json async receive_json ( mode = 'text' ) Receive data and loads it into JSON using orson. Parameters: Name Type Description Default mode Literal ['text', 'binary'] Either 'text' or 'binary'. 'text' Returns: Type Description Any An arbitrary value receive_text async receive_text () Receive data as text. Returns: Type Description str A string. send_bytes async send_bytes ( data , encoding = 'utf-8' ) Send data using the 'bytes' key of the send event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send required encoding str Encoding to use for binary data. 'utf-8' Returns: Type Description None None send_data async send_data ( data , mode = 'text' , encoding = 'utf-8' ) Send a 'websocket.send' event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send. required mode Literal ['text', 'binary'] The respective event key to use. 'text' encoding str Encoding to use when converting bytes / str. 'utf-8' Returns: Type Description None None send_json async send_json ( data , mode = 'text' , encoding = 'utf-8' , serializer = default_serializer ) Send data as JSON. Parameters: Name Type Description Default data Any A value to serialize. required mode Literal ['text', 'binary'] Either 'text' or 'binary'. 'text' encoding str Encoding to use for binary data. 'utf-8' serializer Serializer A serializer function. default_serializer Returns: Type Description None None send_text async send_text ( data , encoding = 'utf-8' ) Send data using the 'text' key of the send event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send required encoding str Encoding to use for binary data. 'utf-8' Returns: Type Description None None","title":"WebSocket"},{"location":"reference/connection/2-websocket/#websocket","text":"","title":"WebSocket"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket","text":"Bases: Generic [ User , Auth ] , ASGIConnection [ WebsocketRouteHandler , User , Auth ] The Starlite WebSocket class.","title":"WebSocket"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive","text":"receive : Receive The ASGI receive function.","title":"receive"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.scope","text":"scope : WebSocketScope The ASGI scope attached to the connection.","title":"scope"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send","text":"send : Send The ASGI send function.","title":"send"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.__init__","text":"__init__ ( scope , receive = empty_receive , send = empty_send ) Initialize WebSocket . Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. empty_receive send Send The ASGI send function. empty_send","title":"__init__()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.accept","text":"accept ( subprotocols = None , headers = None ) Accept the incoming connection. This method should be called before receiving data. Parameters: Name Type Description Default subprotocols Optional [ str ] Websocket sub-protocol to use. None headers Optional [ Union [ Headers , Dict [ str , Any ], List [ Tuple [ bytes , bytes ]]]] Headers to set on the data sent. None Returns: Type Description None None","title":"accept()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.close","text":"close ( code = WS_1000_NORMAL_CLOSURE , reason = None ) Send an 'websocket.close' event. Parameters: Name Type Description Default code int Status code. WS_1000_NORMAL_CLOSURE reason Optional [ str ] Reason for closing the connection None Returns: Type Description None None","title":"close()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_bytes","text":"receive_bytes () Receive data as bytes. Returns: Type Description bytes A byte-string.","title":"receive_bytes()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_data","text":"receive_data ( mode ) Receive an 'websocket.receive' event and returns the data stored on it. Parameters: Name Type Description Default mode Literal ['binary', 'text'] The respective event key to use. required Returns: Type Description Union [ str , bytes ] The event's data.","title":"receive_data()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_json","text":"receive_json ( mode = 'text' ) Receive data and loads it into JSON using orson. Parameters: Name Type Description Default mode Literal ['text', 'binary'] Either 'text' or 'binary'. 'text' Returns: Type Description Any An arbitrary value","title":"receive_json()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.receive_text","text":"receive_text () Receive data as text. Returns: Type Description str A string.","title":"receive_text()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_bytes","text":"send_bytes ( data , encoding = 'utf-8' ) Send data using the 'bytes' key of the send event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send required encoding str Encoding to use for binary data. 'utf-8' Returns: Type Description None None","title":"send_bytes()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_data","text":"send_data ( data , mode = 'text' , encoding = 'utf-8' ) Send a 'websocket.send' event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send. required mode Literal ['text', 'binary'] The respective event key to use. 'text' encoding str Encoding to use when converting bytes / str. 'utf-8' Returns: Type Description None None","title":"send_data()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_json","text":"send_json ( data , mode = 'text' , encoding = 'utf-8' , serializer = default_serializer ) Send data as JSON. Parameters: Name Type Description Default data Any A value to serialize. required mode Literal ['text', 'binary'] Either 'text' or 'binary'. 'text' encoding str Encoding to use for binary data. 'utf-8' serializer Serializer A serializer function. default_serializer Returns: Type Description None None","title":"send_json()"},{"location":"reference/connection/2-websocket/#starlite.connection.websocket.WebSocket.send_text","text":"send_text ( data , encoding = 'utf-8' ) Send data using the 'text' key of the send event. Parameters: Name Type Description Default data Union [ str , bytes ] Data to send required encoding str Encoding to use for binary data. 'utf-8' Returns: Type Description None None","title":"send_text()"},{"location":"reference/contrib/jinja/","text":"Jinja Template Engine starlite.contrib.jinja.JinjaTemplateEngine Bases: TemplateEngineProtocol [ JinjaTemplate ] The engine instance. __init__ __init__ ( directory ) Jinja2 based TemplateEngine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required get_template get_template ( template_name ) Retrieve a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description JinjaTemplate JinjaTemplate instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found. register_template_callable register_template_callable ( key , template_callable ) Register a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"Jinja Template Engine"},{"location":"reference/contrib/jinja/#jinja-template-engine","text":"","title":"Jinja Template Engine"},{"location":"reference/contrib/jinja/#starlite.contrib.jinja.JinjaTemplateEngine","text":"Bases: TemplateEngineProtocol [ JinjaTemplate ] The engine instance.","title":"JinjaTemplateEngine"},{"location":"reference/contrib/jinja/#starlite.contrib.jinja.JinjaTemplateEngine.__init__","text":"__init__ ( directory ) Jinja2 based TemplateEngine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required","title":"__init__()"},{"location":"reference/contrib/jinja/#starlite.contrib.jinja.JinjaTemplateEngine.get_template","text":"get_template ( template_name ) Retrieve a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description JinjaTemplate JinjaTemplate instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found.","title":"get_template()"},{"location":"reference/contrib/jinja/#starlite.contrib.jinja.JinjaTemplateEngine.register_template_callable","text":"register_template_callable ( key , template_callable ) Register a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"register_template_callable()"},{"location":"reference/contrib/jwt/","text":"JWT Security Backend starlite.contrib.jwt.JWTAuth Bases: Generic [ UserType ] , AbstractSecurityConfig [ UserType , Token ] JWT Authentication Configuration. This class is the main entry point to the library, and it includes methods to create the middleware, provide login functionality, and create OpenAPI documentation. algorithm class-attribute algorithm : str = 'HS256' Algorithm to use for JWT hashing. auth_header class-attribute auth_header : str = 'Authorization' Request header key from which to retrieve the token. E.g. 'Authorization' or 'X-Api-Key'. authentication_middleware_class class-attribute authentication_middleware_class : Type [ JWTAuthenticationMiddleware ] = JWTAuthenticationMiddleware The authentication middleware class to use. Must inherit from JWTAuthenticationMiddleware default_token_expiration class-attribute default_token_expiration : timedelta = timedelta ( days = 1 ) The default value for token expiration. description class-attribute description : str = 'JWT api-key authentication and authorization.' Description for the OpenAPI security scheme. middleware property middleware : DefineMiddleware Create JWTAuthenticationMiddleware wrapped in Starlite's DefineMiddleware . Returns: Type Description DefineMiddleware An instance of DefineMiddleware . openapi_components property openapi_components : Components Create OpenAPI documentation for the JWT auth schema used. Returns: Type Description Components An Components instance. openapi_security_scheme_name class-attribute openapi_security_scheme_name : str = 'BearerToken' The value to use for the OpenAPI security scheme and security requirements. security_requirement property security_requirement : SecurityRequirement Return OpenAPI 3.1. SecurityRequirement Returns: Type Description SecurityRequirement An OpenAPI 3.1 SecurityRequirement dictionary. token_secret class-attribute token_secret : str Key with which to generate the token hash. Notes This value should be kept as a secret and the standard practice is to inject it into the environment. login login ( identifier , * , response_body = None , response_media_type = MediaType . JSON , response_status_code = HTTP_201_CREATED , token_expiration = None , token_issuer = None , token_audience = None , token_unique_jwt_id = None ) Create a response with a JWT header. Calls the 'JWTAuth.store_token_handler' to persist the token 'sub'. Parameters: Name Type Description Default identifier str Unique identifier of the token subject. Usually this is a user ID or equivalent kind of value. required response_body Optional [ Any ] An optional response body to send. None response_media_type Union [ str , MediaType ] An optional 'Content-Type'. Defaults to 'application/json'. MediaType.JSON response_status_code int An optional status code for the response. Defaults to '201 Created'. HTTP_201_CREATED token_expiration Optional [ timedelta ] An optional timedelta for the token expiration. None token_issuer Optional [ str ] An optional value of the token 'iss' field. None token_audience Optional [ str ] An optional value for the token 'aud' field. None token_unique_jwt_id Optional [ str ] An optional value for the token 'jti' field. None Returns: Type Description Response [ Any ] A Response instance. starlite.contrib.jwt.JWTCookieAuth Bases: Generic [ UserType ] , JWTAuth [ UserType ] JWT Cookie Authentication Configuration. This class is an alternate entry point to the library, and it includes all the functionality of the JWTAuth class and adds support for passing JWT tokens HttpOnly cookies. authentication_middleware_class class-attribute authentication_middleware_class : Type [ JWTCookieAuthenticationMiddleware ] = JWTCookieAuthenticationMiddleware The authentication middleware class to use. Must inherit from JWTCookieAuthenticationMiddleware description class-attribute description : str = 'JWT cookie-based authentication and authorization.' Description for the OpenAPI security scheme. domain class-attribute domain : Optional [ str ] = None Domain for which the cookie is valid. key class-attribute key : str = 'token' Key for the cookie. middleware property middleware : DefineMiddleware Create JWTCookieAuthenticationMiddleware wrapped in Starlite's DefineMiddleware . Returns: Type Description DefineMiddleware An instance of DefineMiddleware . openapi_components property openapi_components : Components Create OpenAPI documentation for the JWT Cookie auth scheme. Returns: Type Description Components An Components instance. path class-attribute path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'. samesite class-attribute samesite : Literal [ 'lax' , 'strict' , 'none' ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'. secure class-attribute secure : Optional [ bool ] = None Https is required for the cookie. login login ( identifier , * , response_body = None , response_media_type = MediaType . JSON , response_status_code = HTTP_201_CREATED , token_expiration = None , token_issuer = None , token_audience = None , token_unique_jwt_id = None ) Create a response with a JWT header. Calls the 'JWTAuth.store_token_handler' to persist the token 'sub'. Parameters: Name Type Description Default identifier str Unique identifier of the token subject. Usually this is a user ID or equivalent kind of value. required response_body Optional [ Any ] An optional response body to send. None response_media_type Union [ str , MediaType ] An optional 'Content-Type'. Defaults to 'application/json'. MediaType.JSON response_status_code int An optional status code for the response. Defaults to '201 Created'. HTTP_201_CREATED token_expiration Optional [ timedelta ] An optional timedelta for the token expiration. None token_issuer Optional [ str ] An optional value of the token 'iss' field. None token_audience Optional [ str ] An optional value for the token 'aud' field. None token_unique_jwt_id Optional [ str ] An optional value for the token 'jti' field. None Returns: Type Description Response [ Any ] A Response instance. starlite.contrib.jwt.OAuth2PasswordBearerAuth Bases: Generic [ UserType ] , JWTCookieAuth [ UserType ] OAUTH2 Schema for Password Bearer Authentication. This class implements an OAUTH2 authentication flow entry point to the library, and it includes all the functionality of the JWTAuth class and adds support for passing JWT tokens HttpOnly cookies. token_url is the only additional argument that is required, and it should point at your login route description class-attribute description : str = 'OAUTH2 password bearer authentication and authorization.' Description for the OpenAPI security scheme. oauth_scopes class-attribute oauth_scopes : Optional [ Dict [ str , str ]] = None Oauth Scopes available for the token. openapi_components property openapi_components : Components Create OpenAPI documentation for the OAUTH2 Password bearer auth scheme. Returns: Type Description Components An Components instance. token_url class-attribute token_url : str The URL for retrieving a new token. starlite.contrib.jwt.Token Bases: BaseModel JWT Token DTO. exp class-attribute exp : datetime Expiration - datetime for token expiration. iat class-attribute iat : datetime = Field ( default_factory = lambda : _normalize_datetime ( datetime . now ( timezone . utc ))) Issued at - should always be current now. sub class-attribute sub : constr ( min_length = 1 ) Subject - usually a unique identifier of the user or equivalent entity. iss class-attribute iss : Optional [ str ] = None Issuer - optional unique identifier for the issuer. aud class-attribute aud : Optional [ str ] = None Audience - intended audience. jti class-attribute jti : Optional [ str ] = None JWT ID - a unique identifier of the JWT between different issuers. decode staticmethod decode ( encoded_token , secret , algorithm ) Decode a passed in token string and returns a Token instance. Parameters: Name Type Description Default encoded_token str A base64 string containing an encoded JWT. required secret Union [ str , Dict [ str , str ]] The secret with which the JWT is encoded. It may optionally be an individual JWK or JWS set dict required algorithm str The algorithm used to encode the JWT. required Returns: Type Description Token A decoded Token instance. Raises: Type Description [ NotAuthorizedException ][ starlite . exceptions . NotAuthorizedException ] If token is invalid. encode encode ( secret , algorithm ) Encode the token instance into a string. Parameters: Name Type Description Default secret str The secret with which the JWT is encoded. required algorithm str The algorithm used to encode the JWT. required Returns: Type Description str An encoded token string. Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] If encoding fails. starlite.contrib.jwt.JWTAuthenticationMiddleware Bases: AbstractAuthenticationMiddleware JWT Authentication middleware. This class provides JWT authentication functionalities. __init__ __init__ ( app , algorithm , auth_header , exclude , exclude_opt_key , retrieve_user_handler , scopes , token_secret , ) Check incoming requests for an encoded token in the auth header specified, and if present retrieve the user from persistence using the provided function. Parameters: Name Type Description Default algorithm str JWT hashing algorithm to use. required app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required auth_header str Request header key from which to retrieve the token. E.g. 'Authorization' or 'X-Api-Key'. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip. required exclude_opt_key str An identifier to use on routes to disable authentication for a particular route. required retrieve_user_handler AsyncCallable[[Token, ASGIConnection[Any, Any, Any]], Awaitable[Any]] A function that receives an instance of 'Token' and returns a user, which can be any arbitrary value. required scopes Scopes ASGI scopes processed by the authentication middleware. required token_secret str Secret for decoding the JWT token. This value should be equivalent to the secret used to encode it. required starlite.contrib.jwt.JWTCookieAuthenticationMiddleware Bases: JWTAuthenticationMiddleware Cookie based JWT authentication middleware. __init__ __init__ ( algorithm , app , auth_cookie_key , auth_header , exclude , exclude_opt_key , retrieve_user_handler , scopes , token_secret , ) Check incoming requests for an encoded token in the auth header or cookie name specified, and if present retrieves the user from persistence using the provided function. Parameters: Name Type Description Default algorithm str JWT hashing algorithm to use. required app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required auth_cookie_key str Cookie name from which to retrieve the token. E.g. 'token' or 'accessToken'. required auth_header str Request header key from which to retrieve the token. E.g. 'Authorization' or 'X-Api-Key'. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip. required exclude_opt_key str An identifier to use on routes to disable authentication for a particular route. required retrieve_user_handler AsyncCallable[[Token, ASGIConnection[Any, Any, Any]], Awaitable[Any]] A function that receives an instance of 'Token' and returns a user, which can be any arbitrary value. required scopes Scopes ASGI scopes processed by the authentication middleware. required token_secret str Secret for decoding the JWT token. This value should be equivalent to the secret used to encode it. required","title":"JWT Security Backend"},{"location":"reference/contrib/jwt/#jwt-security-backend","text":"","title":"JWT Security Backend"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.JWTAuth","text":"Bases: Generic [ UserType ] , AbstractSecurityConfig [ UserType , Token ] JWT Authentication Configuration. This class is the main entry point to the library, and it includes methods to create the middleware, provide login functionality, and create OpenAPI documentation.","title":"JWTAuth"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.algorithm","text":"algorithm : str = 'HS256' Algorithm to use for JWT hashing.","title":"algorithm"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.auth_header","text":"auth_header : str = 'Authorization' Request header key from which to retrieve the token. E.g. 'Authorization' or 'X-Api-Key'.","title":"auth_header"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.authentication_middleware_class","text":"authentication_middleware_class : Type [ JWTAuthenticationMiddleware ] = JWTAuthenticationMiddleware The authentication middleware class to use. Must inherit from JWTAuthenticationMiddleware","title":"authentication_middleware_class"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.default_token_expiration","text":"default_token_expiration : timedelta = timedelta ( days = 1 ) The default value for token expiration.","title":"default_token_expiration"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.description","text":"description : str = 'JWT api-key authentication and authorization.' Description for the OpenAPI security scheme.","title":"description"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.middleware","text":"middleware : DefineMiddleware Create JWTAuthenticationMiddleware wrapped in Starlite's DefineMiddleware . Returns: Type Description DefineMiddleware An instance of DefineMiddleware .","title":"middleware"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.openapi_components","text":"openapi_components : Components Create OpenAPI documentation for the JWT auth schema used. Returns: Type Description Components An Components instance.","title":"openapi_components"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.openapi_security_scheme_name","text":"openapi_security_scheme_name : str = 'BearerToken' The value to use for the OpenAPI security scheme and security requirements.","title":"openapi_security_scheme_name"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.security_requirement","text":"security_requirement : SecurityRequirement Return OpenAPI 3.1. SecurityRequirement Returns: Type Description SecurityRequirement An OpenAPI 3.1 SecurityRequirement dictionary.","title":"security_requirement"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.token_secret","text":"token_secret : str Key with which to generate the token hash. Notes This value should be kept as a secret and the standard practice is to inject it into the environment.","title":"token_secret"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTAuth.login","text":"login ( identifier , * , response_body = None , response_media_type = MediaType . JSON , response_status_code = HTTP_201_CREATED , token_expiration = None , token_issuer = None , token_audience = None , token_unique_jwt_id = None ) Create a response with a JWT header. Calls the 'JWTAuth.store_token_handler' to persist the token 'sub'. Parameters: Name Type Description Default identifier str Unique identifier of the token subject. Usually this is a user ID or equivalent kind of value. required response_body Optional [ Any ] An optional response body to send. None response_media_type Union [ str , MediaType ] An optional 'Content-Type'. Defaults to 'application/json'. MediaType.JSON response_status_code int An optional status code for the response. Defaults to '201 Created'. HTTP_201_CREATED token_expiration Optional [ timedelta ] An optional timedelta for the token expiration. None token_issuer Optional [ str ] An optional value of the token 'iss' field. None token_audience Optional [ str ] An optional value for the token 'aud' field. None token_unique_jwt_id Optional [ str ] An optional value for the token 'jti' field. None Returns: Type Description Response [ Any ] A Response instance.","title":"login()"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.JWTCookieAuth","text":"Bases: Generic [ UserType ] , JWTAuth [ UserType ] JWT Cookie Authentication Configuration. This class is an alternate entry point to the library, and it includes all the functionality of the JWTAuth class and adds support for passing JWT tokens HttpOnly cookies.","title":"JWTCookieAuth"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.authentication_middleware_class","text":"authentication_middleware_class : Type [ JWTCookieAuthenticationMiddleware ] = JWTCookieAuthenticationMiddleware The authentication middleware class to use. Must inherit from JWTCookieAuthenticationMiddleware","title":"authentication_middleware_class"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.description","text":"description : str = 'JWT cookie-based authentication and authorization.' Description for the OpenAPI security scheme.","title":"description"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.domain","text":"domain : Optional [ str ] = None Domain for which the cookie is valid.","title":"domain"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.key","text":"key : str = 'token' Key for the cookie.","title":"key"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.middleware","text":"middleware : DefineMiddleware Create JWTCookieAuthenticationMiddleware wrapped in Starlite's DefineMiddleware . Returns: Type Description DefineMiddleware An instance of DefineMiddleware .","title":"middleware"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.openapi_components","text":"openapi_components : Components Create OpenAPI documentation for the JWT Cookie auth scheme. Returns: Type Description Components An Components instance.","title":"openapi_components"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.path","text":"path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'.","title":"path"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.samesite","text":"samesite : Literal [ 'lax' , 'strict' , 'none' ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'.","title":"samesite"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.secure","text":"secure : Optional [ bool ] = None Https is required for the cookie.","title":"secure"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.JWTCookieAuth.login","text":"login ( identifier , * , response_body = None , response_media_type = MediaType . JSON , response_status_code = HTTP_201_CREATED , token_expiration = None , token_issuer = None , token_audience = None , token_unique_jwt_id = None ) Create a response with a JWT header. Calls the 'JWTAuth.store_token_handler' to persist the token 'sub'. Parameters: Name Type Description Default identifier str Unique identifier of the token subject. Usually this is a user ID or equivalent kind of value. required response_body Optional [ Any ] An optional response body to send. None response_media_type Union [ str , MediaType ] An optional 'Content-Type'. Defaults to 'application/json'. MediaType.JSON response_status_code int An optional status code for the response. Defaults to '201 Created'. HTTP_201_CREATED token_expiration Optional [ timedelta ] An optional timedelta for the token expiration. None token_issuer Optional [ str ] An optional value of the token 'iss' field. None token_audience Optional [ str ] An optional value for the token 'aud' field. None token_unique_jwt_id Optional [ str ] An optional value for the token 'jti' field. None Returns: Type Description Response [ Any ] A Response instance.","title":"login()"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.OAuth2PasswordBearerAuth","text":"Bases: Generic [ UserType ] , JWTCookieAuth [ UserType ] OAUTH2 Schema for Password Bearer Authentication. This class implements an OAUTH2 authentication flow entry point to the library, and it includes all the functionality of the JWTAuth class and adds support for passing JWT tokens HttpOnly cookies. token_url is the only additional argument that is required, and it should point at your login route","title":"OAuth2PasswordBearerAuth"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.OAuth2PasswordBearerAuth.description","text":"description : str = 'OAUTH2 password bearer authentication and authorization.' Description for the OpenAPI security scheme.","title":"description"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.OAuth2PasswordBearerAuth.oauth_scopes","text":"oauth_scopes : Optional [ Dict [ str , str ]] = None Oauth Scopes available for the token.","title":"oauth_scopes"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.OAuth2PasswordBearerAuth.openapi_components","text":"openapi_components : Components Create OpenAPI documentation for the OAUTH2 Password bearer auth scheme. Returns: Type Description Components An Components instance.","title":"openapi_components"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_auth.OAuth2PasswordBearerAuth.token_url","text":"token_url : str The URL for retrieving a new token.","title":"token_url"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.Token","text":"Bases: BaseModel JWT Token DTO.","title":"Token"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.exp","text":"exp : datetime Expiration - datetime for token expiration.","title":"exp"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.iat","text":"iat : datetime = Field ( default_factory = lambda : _normalize_datetime ( datetime . now ( timezone . utc ))) Issued at - should always be current now.","title":"iat"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.sub","text":"sub : constr ( min_length = 1 ) Subject - usually a unique identifier of the user or equivalent entity.","title":"sub"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.iss","text":"iss : Optional [ str ] = None Issuer - optional unique identifier for the issuer.","title":"iss"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.aud","text":"aud : Optional [ str ] = None Audience - intended audience.","title":"aud"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.jti","text":"jti : Optional [ str ] = None JWT ID - a unique identifier of the JWT between different issuers.","title":"jti"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.decode","text":"decode ( encoded_token , secret , algorithm ) Decode a passed in token string and returns a Token instance. Parameters: Name Type Description Default encoded_token str A base64 string containing an encoded JWT. required secret Union [ str , Dict [ str , str ]] The secret with which the JWT is encoded. It may optionally be an individual JWK or JWS set dict required algorithm str The algorithm used to encode the JWT. required Returns: Type Description Token A decoded Token instance. Raises: Type Description [ NotAuthorizedException ][ starlite . exceptions . NotAuthorizedException ] If token is invalid.","title":"decode()"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.jwt_token.Token.encode","text":"encode ( secret , algorithm ) Encode the token instance into a string. Parameters: Name Type Description Default secret str The secret with which the JWT is encoded. required algorithm str The algorithm used to encode the JWT. required Returns: Type Description str An encoded token string. Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] If encoding fails.","title":"encode()"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.JWTAuthenticationMiddleware","text":"Bases: AbstractAuthenticationMiddleware JWT Authentication middleware. This class provides JWT authentication functionalities.","title":"JWTAuthenticationMiddleware"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.middleware.JWTAuthenticationMiddleware.__init__","text":"__init__ ( app , algorithm , auth_header , exclude , exclude_opt_key , retrieve_user_handler , scopes , token_secret , ) Check incoming requests for an encoded token in the auth header specified, and if present retrieve the user from persistence using the provided function. Parameters: Name Type Description Default algorithm str JWT hashing algorithm to use. required app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required auth_header str Request header key from which to retrieve the token. E.g. 'Authorization' or 'X-Api-Key'. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip. required exclude_opt_key str An identifier to use on routes to disable authentication for a particular route. required retrieve_user_handler AsyncCallable[[Token, ASGIConnection[Any, Any, Any]], Awaitable[Any]] A function that receives an instance of 'Token' and returns a user, which can be any arbitrary value. required scopes Scopes ASGI scopes processed by the authentication middleware. required token_secret str Secret for decoding the JWT token. This value should be equivalent to the secret used to encode it. required","title":"__init__()"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.JWTCookieAuthenticationMiddleware","text":"Bases: JWTAuthenticationMiddleware Cookie based JWT authentication middleware.","title":"JWTCookieAuthenticationMiddleware"},{"location":"reference/contrib/jwt/#starlite.contrib.jwt.middleware.JWTCookieAuthenticationMiddleware.__init__","text":"__init__ ( algorithm , app , auth_cookie_key , auth_header , exclude , exclude_opt_key , retrieve_user_handler , scopes , token_secret , ) Check incoming requests for an encoded token in the auth header or cookie name specified, and if present retrieves the user from persistence using the provided function. Parameters: Name Type Description Default algorithm str JWT hashing algorithm to use. required app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required auth_cookie_key str Cookie name from which to retrieve the token. E.g. 'token' or 'accessToken'. required auth_header str Request header key from which to retrieve the token. E.g. 'Authorization' or 'X-Api-Key'. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip. required exclude_opt_key str An identifier to use on routes to disable authentication for a particular route. required retrieve_user_handler AsyncCallable[[Token, ASGIConnection[Any, Any, Any]], Awaitable[Any]] A function that receives an instance of 'Token' and returns a user, which can be any arbitrary value. required scopes Scopes ASGI scopes processed by the authentication middleware. required token_secret str Secret for decoding the JWT token. This value should be equivalent to the secret used to encode it. required","title":"__init__()"},{"location":"reference/contrib/mako/","text":"Mako Template Engine starlite.contrib.mako.MakoTemplateEngine Bases: TemplateEngineProtocol [ MakoTemplate ] Mako based TemplateEngine. __init__ __init__ ( directory ) Initialize template engine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required get_template get_template ( template_name ) Retrieve a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description MakoTemplate MakoTemplate instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found. register_template_callable register_template_callable ( key , template_callable ) Register a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"Mako Template Engine"},{"location":"reference/contrib/mako/#mako-template-engine","text":"","title":"Mako Template Engine"},{"location":"reference/contrib/mako/#starlite.contrib.mako.MakoTemplateEngine","text":"Bases: TemplateEngineProtocol [ MakoTemplate ] Mako based TemplateEngine.","title":"MakoTemplateEngine"},{"location":"reference/contrib/mako/#starlite.contrib.mako.MakoTemplateEngine.__init__","text":"__init__ ( directory ) Initialize template engine. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required","title":"__init__()"},{"location":"reference/contrib/mako/#starlite.contrib.mako.MakoTemplateEngine.get_template","text":"get_template ( template_name ) Retrieve a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description MakoTemplate MakoTemplate instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found.","title":"get_template()"},{"location":"reference/contrib/mako/#starlite.contrib.mako.MakoTemplateEngine.register_template_callable","text":"register_template_callable ( key , template_callable ) Register a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"register_template_callable()"},{"location":"reference/contrib/opentelemetry/","text":"OpenTelemetry starlite.contrib.opentelemetry.OpenTelemetryConfig Bases: BaseModel Configuration class for the OpenTelemetry middleware. Consult the OpenTelemetry ASGI documentation for more info about the configuration options. client_request_hook_handler class-attribute client_request_hook_handler : Optional [ OpenTelemetryHookHandler ] = None Optional callback which is called with the internal span and an ASGI scope which is sent as a dictionary for when the method receive is called. client_response_hook_handler class-attribute client_response_hook_handler : Optional [ OpenTelemetryHookHandler ] = None Optional callback which is called with the internal span and an ASGI event which is sent as a dictionary for when the method send is called. exclude class-attribute exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the Allowed Hosts middleware. exclude_opt_key class-attribute exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable hosts check for a particular route. exclude_urls_env_key class-attribute exclude_urls_env_key : str = 'STARLITE' Key to use when checking whether a list of excluded urls is passed via ENV. OpenTelemetry supports excluding urls by passing an env in the format '{exclude_urls_env_key}_EXCLUDED_URLS'. With the default being 'STARLITE_EXCLUDED_URLS'. meter class-attribute meter : Optional [ Meter ] = None Optional meter to use. If omitted the provided meter provider or the global one will be used. meter_provider class-attribute meter_provider : Optional [ MeterProvider ] = None Optional meter provider to use. If omitted the current globally configured one is used. middleware property middleware : DefineMiddleware Create an instance of DefineMiddleware that wraps with. OpenTelemetry InstrumentationMiddleware or a subclass of this middleware. Returns: Type Description DefineMiddleware An instance of DefineMiddleware . scope_span_details_extractor class-attribute scope_span_details_extractor : Callable [[ Scope ], Tuple [ str , dict ]] = get_route_details_from_scope Callback which should return a string and a tuple, representing the desired default span name and a dictionary with any additional span attributes to set. scopes class-attribute scopes : Optional [ Scopes ] = None ASGI scopes processed by the middleware, if None both 'http' and 'websocket' will be processed. server_request_hook_handler class-attribute server_request_hook_handler : Optional [ OpenTelemetryHookHandler ] = None Optional callback which is called with the server span and ASGI scope object for every incoming request. tracer_provider class-attribute tracer_provider : Optional [ TracerProvider ] = None Optional tracer provider to use. If omitted the current globally configured one is used. starlite.contrib.opentelemetry.OpenTelemetryInstrumentationMiddleware Bases: AbstractMiddleware OpenTelemetry Middleware. __init__ __init__ ( app , config ) Middleware that adds OpenTelemetry instrumentation to the application. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config OpenTelemetryConfig An instance of OpenTelemetryConfig required starlite.contrib.opentelemetry.get_route_details_from_scope starlite . contrib . opentelemetry . get_route_details_from_scope ( scope ) Retrieve the span name and attributes from the ASGI scope. Parameters: Name Type Description Default scope Scope The ASGI scope instance. required Returns: Type Description Tuple [ str , Dict [ Any , str ]] A tuple of the span name and a dict of attrs.","title":"OpenTelemetry"},{"location":"reference/contrib/opentelemetry/#opentelemetry","text":"","title":"OpenTelemetry"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.OpenTelemetryConfig","text":"Bases: BaseModel Configuration class for the OpenTelemetry middleware. Consult the OpenTelemetry ASGI documentation for more info about the configuration options.","title":"OpenTelemetryConfig"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.client_request_hook_handler","text":"client_request_hook_handler : Optional [ OpenTelemetryHookHandler ] = None Optional callback which is called with the internal span and an ASGI scope which is sent as a dictionary for when the method receive is called.","title":"client_request_hook_handler"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.client_response_hook_handler","text":"client_response_hook_handler : Optional [ OpenTelemetryHookHandler ] = None Optional callback which is called with the internal span and an ASGI event which is sent as a dictionary for when the method send is called.","title":"client_response_hook_handler"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.exclude","text":"exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the Allowed Hosts middleware.","title":"exclude"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.exclude_opt_key","text":"exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable hosts check for a particular route.","title":"exclude_opt_key"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.exclude_urls_env_key","text":"exclude_urls_env_key : str = 'STARLITE' Key to use when checking whether a list of excluded urls is passed via ENV. OpenTelemetry supports excluding urls by passing an env in the format '{exclude_urls_env_key}_EXCLUDED_URLS'. With the default being 'STARLITE_EXCLUDED_URLS'.","title":"exclude_urls_env_key"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.meter","text":"meter : Optional [ Meter ] = None Optional meter to use. If omitted the provided meter provider or the global one will be used.","title":"meter"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.meter_provider","text":"meter_provider : Optional [ MeterProvider ] = None Optional meter provider to use. If omitted the current globally configured one is used.","title":"meter_provider"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.middleware","text":"middleware : DefineMiddleware Create an instance of DefineMiddleware that wraps with. OpenTelemetry InstrumentationMiddleware or a subclass of this middleware. Returns: Type Description DefineMiddleware An instance of DefineMiddleware .","title":"middleware"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.scope_span_details_extractor","text":"scope_span_details_extractor : Callable [[ Scope ], Tuple [ str , dict ]] = get_route_details_from_scope Callback which should return a string and a tuple, representing the desired default span name and a dictionary with any additional span attributes to set.","title":"scope_span_details_extractor"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.scopes","text":"scopes : Optional [ Scopes ] = None ASGI scopes processed by the middleware, if None both 'http' and 'websocket' will be processed.","title":"scopes"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.server_request_hook_handler","text":"server_request_hook_handler : Optional [ OpenTelemetryHookHandler ] = None Optional callback which is called with the server span and ASGI scope object for every incoming request.","title":"server_request_hook_handler"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.config.OpenTelemetryConfig.tracer_provider","text":"tracer_provider : Optional [ TracerProvider ] = None Optional tracer provider to use. If omitted the current globally configured one is used.","title":"tracer_provider"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.OpenTelemetryInstrumentationMiddleware","text":"Bases: AbstractMiddleware OpenTelemetry Middleware.","title":"OpenTelemetryInstrumentationMiddleware"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.middleware.OpenTelemetryInstrumentationMiddleware.__init__","text":"__init__ ( app , config ) Middleware that adds OpenTelemetry instrumentation to the application. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config OpenTelemetryConfig An instance of OpenTelemetryConfig required","title":"__init__()"},{"location":"reference/contrib/opentelemetry/#starlite.contrib.opentelemetry.get_route_details_from_scope","text":"starlite . contrib . opentelemetry . get_route_details_from_scope ( scope ) Retrieve the span name and attributes from the ASGI scope. Parameters: Name Type Description Default scope Scope The ASGI scope instance. required Returns: Type Description Tuple [ str , Dict [ Any , str ]] A tuple of the span name and a dict of attrs.","title":"get_route_details_from_scope()"},{"location":"reference/datastructures/0-state/","text":"State starlite.datastructures.ImmutableState Bases: Mapping [ str , Any ] An object meant to store arbitrary state. It can be accessed using dot notation while exposing dict like functionalities. __init__ __init__ ( state , deep_copy = True ) Initialize an ImmutableState instance. Parameters: Name Type Description Default state Union [ ImmutableState , Dict [ str , Any ], Iterable [ Tuple [ str , Any ]]] An object to initialize the state from. Can be a dict, an instance of 'ImmutableState', or a tuple of key value paris. required deep_copy bool Whether to 'deepcopy' the passed in state. True Examples: from starlite import ImmutableState state_dict = { \"first\" : 1 , \"second\" : 2 , \"third\" : 3 , \"fourth\" : 4 } state = ImmutableState ( state_dict ) # state implements the Mapping type: assert len ( state ) == 3 assert \"first\" in state assert not \"fourth\" in state assert state [ \"first\" ] == 1 assert [( k , v ) for k , v in state . items ()] == [( \"first\" , 1 ), ( \"second\" , 2 ), ( \"third\" , 3 )] # state implements __bool__ assert state # state is true when it has values. assert not State () # state is empty when it has no values. # it has a 'dict' method to retrieve a shallow copy of the underlying dict inner_dict = state . dict () assert inner_dict == state_dict # you can also retrieve a mutable State by calling 'mutable_copy' mutable_state = state . mutable_copy () del state [ \"first\" ] assert \"first\" not in state dict dict () Return a shallow copy of the wrapped dict. Returns: Type Description Dict [ str , Any ] A dict mutable_copy mutable_copy () Return a mutable copy of the state object. Returns: Type Description State A State starlite.datastructures.State Bases: ImmutableState , MutableMapping [ str , Any ] An object meant to store arbitrary state. It can be accessed using dot notation while exposing dict like functionalities. __init__ __init__ ( state = None , deep_copy = False ) Initialize a State instance with an optional value. Parameters: Name Type Description Default state Optional [ Union [ ImmutableState , Dict [ str , Any ], Iterable [ Tuple [ str , Any ]]]] An object to initialize the state from. Can be a dict, an instance of 'ImmutableState', or a tuple of key value paris. None deep_copy bool Whether to 'deepcopy' the passed in state. False Examples: from starlite import State state_dict = { \"first\" : 1 , \"second\" : 2 , \"third\" : 3 , \"fourth\" : 4 } state = State ( state_dict ) # state can be accessed using '.' notation assert state . fourth == 4 del state . fourth # state implements the Mapping type: assert len ( state ) == 3 assert \"first\" in state assert not \"fourth\" in state assert state [ \"first\" ] == 1 assert [( k , v ) for k , v in state . items ()] == [( \"first\" , 1 ), ( \"second\" , 2 ), ( \"third\" , 3 )] state [ \"fourth\" ] = 4 assert \"fourth\" in state del state [ \"fourth\" ] # state implements __bool__ assert state # state is true when it has values. assert not State () # state is empty when it has no values. # it has shallow copy copied_state = state . copy () del copied_state . first assert state . first # it has a 'dict' method to retrieve a shallow copy of the underlying dict inner_dict = state . dict () assert inner_dict == state_dict # you can get an immutable copy of the state by calling 'immutable_immutable_copy' immutable_copy = state . immutable_copy () del immutable_copy . first # raises AttributeError copy copy () Return a shallow copy of the state object. Returns: Type Description State A State immutable_copy immutable_copy () Return a shallow copy of the state object, setting it to be frozen. Returns: Type Description ImmutableState A State","title":"State"},{"location":"reference/datastructures/0-state/#state","text":"","title":"State"},{"location":"reference/datastructures/0-state/#starlite.datastructures.ImmutableState","text":"Bases: Mapping [ str , Any ] An object meant to store arbitrary state. It can be accessed using dot notation while exposing dict like functionalities.","title":"ImmutableState"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.ImmutableState.__init__","text":"__init__ ( state , deep_copy = True ) Initialize an ImmutableState instance. Parameters: Name Type Description Default state Union [ ImmutableState , Dict [ str , Any ], Iterable [ Tuple [ str , Any ]]] An object to initialize the state from. Can be a dict, an instance of 'ImmutableState', or a tuple of key value paris. required deep_copy bool Whether to 'deepcopy' the passed in state. True Examples: from starlite import ImmutableState state_dict = { \"first\" : 1 , \"second\" : 2 , \"third\" : 3 , \"fourth\" : 4 } state = ImmutableState ( state_dict ) # state implements the Mapping type: assert len ( state ) == 3 assert \"first\" in state assert not \"fourth\" in state assert state [ \"first\" ] == 1 assert [( k , v ) for k , v in state . items ()] == [( \"first\" , 1 ), ( \"second\" , 2 ), ( \"third\" , 3 )] # state implements __bool__ assert state # state is true when it has values. assert not State () # state is empty when it has no values. # it has a 'dict' method to retrieve a shallow copy of the underlying dict inner_dict = state . dict () assert inner_dict == state_dict # you can also retrieve a mutable State by calling 'mutable_copy' mutable_state = state . mutable_copy () del state [ \"first\" ] assert \"first\" not in state","title":"__init__()"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.ImmutableState.dict","text":"dict () Return a shallow copy of the wrapped dict. Returns: Type Description Dict [ str , Any ] A dict","title":"dict()"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.ImmutableState.mutable_copy","text":"mutable_copy () Return a mutable copy of the state object. Returns: Type Description State A State","title":"mutable_copy()"},{"location":"reference/datastructures/0-state/#starlite.datastructures.State","text":"Bases: ImmutableState , MutableMapping [ str , Any ] An object meant to store arbitrary state. It can be accessed using dot notation while exposing dict like functionalities.","title":"State"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.State.__init__","text":"__init__ ( state = None , deep_copy = False ) Initialize a State instance with an optional value. Parameters: Name Type Description Default state Optional [ Union [ ImmutableState , Dict [ str , Any ], Iterable [ Tuple [ str , Any ]]]] An object to initialize the state from. Can be a dict, an instance of 'ImmutableState', or a tuple of key value paris. None deep_copy bool Whether to 'deepcopy' the passed in state. False Examples: from starlite import State state_dict = { \"first\" : 1 , \"second\" : 2 , \"third\" : 3 , \"fourth\" : 4 } state = State ( state_dict ) # state can be accessed using '.' notation assert state . fourth == 4 del state . fourth # state implements the Mapping type: assert len ( state ) == 3 assert \"first\" in state assert not \"fourth\" in state assert state [ \"first\" ] == 1 assert [( k , v ) for k , v in state . items ()] == [( \"first\" , 1 ), ( \"second\" , 2 ), ( \"third\" , 3 )] state [ \"fourth\" ] = 4 assert \"fourth\" in state del state [ \"fourth\" ] # state implements __bool__ assert state # state is true when it has values. assert not State () # state is empty when it has no values. # it has shallow copy copied_state = state . copy () del copied_state . first assert state . first # it has a 'dict' method to retrieve a shallow copy of the underlying dict inner_dict = state . dict () assert inner_dict == state_dict # you can get an immutable copy of the state by calling 'immutable_immutable_copy' immutable_copy = state . immutable_copy () del immutable_copy . first # raises AttributeError","title":"__init__()"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.State.copy","text":"copy () Return a shallow copy of the state object. Returns: Type Description State A State","title":"copy()"},{"location":"reference/datastructures/0-state/#starlite.datastructures.state.State.immutable_copy","text":"immutable_copy () Return a shallow copy of the state object, setting it to be frozen. Returns: Type Description ImmutableState A State","title":"immutable_copy()"},{"location":"reference/datastructures/1-cookie/","text":"Cookie starlite.datastructures.Cookie dataclass Container class for defining a cookie using the 'Set-Cookie' header. See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie for more details regarding this header. description class-attribute description : Optional [ str ] = None Description of the response cookie header for OpenAPI documentation. documentation_only class-attribute documentation_only : bool = False Defines the Cookie instance as for OpenAPI documentation purpose only. domain class-attribute domain : Optional [ str ] = None Domain for which the cookie is valid. expires class-attribute expires : Optional [ int ] = None Expiration date as unix MS timestamp. httponly class-attribute httponly : Optional [ bool ] = None Forbids javascript to access the cookie via 'Document.cookie'. key class-attribute key : str Key for the cookie. max_age class-attribute max_age : Optional [ int ] = None Maximal age of the cookie before its invalidated. path class-attribute path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'. samesite class-attribute samesite : Literal [ 'lax' , 'strict' , 'none' ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'. secure class-attribute secure : Optional [ bool ] = None Https is required for the cookie. value class-attribute value : Optional [ str ] = None Value for the cookie, if none given defaults to empty string. to_header to_header ( ** kwargs ) Return a string representation suitable to be sent as HTTP headers. Parameters: Name Type Description Default **kwargs Any Any kwargs to pass to the simple cookie output method. {}","title":"Cookie"},{"location":"reference/datastructures/1-cookie/#cookie","text":"","title":"Cookie"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.Cookie","text":"Container class for defining a cookie using the 'Set-Cookie' header. See: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Set-Cookie for more details regarding this header.","title":"Cookie"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.description","text":"description : Optional [ str ] = None Description of the response cookie header for OpenAPI documentation.","title":"description"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.documentation_only","text":"documentation_only : bool = False Defines the Cookie instance as for OpenAPI documentation purpose only.","title":"documentation_only"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.domain","text":"domain : Optional [ str ] = None Domain for which the cookie is valid.","title":"domain"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.expires","text":"expires : Optional [ int ] = None Expiration date as unix MS timestamp.","title":"expires"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.httponly","text":"httponly : Optional [ bool ] = None Forbids javascript to access the cookie via 'Document.cookie'.","title":"httponly"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.key","text":"key : str Key for the cookie.","title":"key"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.max_age","text":"max_age : Optional [ int ] = None Maximal age of the cookie before its invalidated.","title":"max_age"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.path","text":"path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'.","title":"path"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.samesite","text":"samesite : Literal [ 'lax' , 'strict' , 'none' ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'.","title":"samesite"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.secure","text":"secure : Optional [ bool ] = None Https is required for the cookie.","title":"secure"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.value","text":"value : Optional [ str ] = None Value for the cookie, if none given defaults to empty string.","title":"value"},{"location":"reference/datastructures/1-cookie/#starlite.datastructures.cookie.Cookie.to_header","text":"to_header ( ** kwargs ) Return a string representation suitable to be sent as HTTP headers. Parameters: Name Type Description Default **kwargs Any Any kwargs to pass to the simple cookie output method. {}","title":"to_header()"},{"location":"reference/datastructures/2-provide/","text":"Provide starlite.datastructures.Provide A wrapper class for dependency injection. __init__ __init__ ( dependency , use_cache = False , sync_to_thread = False ) Initialize Provide Parameters: Name Type Description Default dependency AnyCallable Callable to inject, can be a function, method or class. required use_cache bool Cache the dependency return value. Defaults to False. False sync_to_thread bool Run sync code in an async thread. Defaults to False. False","title":"Provide"},{"location":"reference/datastructures/2-provide/#provide","text":"","title":"Provide"},{"location":"reference/datastructures/2-provide/#starlite.datastructures.Provide","text":"A wrapper class for dependency injection.","title":"Provide"},{"location":"reference/datastructures/2-provide/#starlite.datastructures.provide.Provide.__init__","text":"__init__ ( dependency , use_cache = False , sync_to_thread = False ) Initialize Provide Parameters: Name Type Description Default dependency AnyCallable Callable to inject, can be a function, method or class. required use_cache bool Cache the dependency return value. Defaults to False. False sync_to_thread bool Run sync code in an async thread. Defaults to False. False","title":"__init__()"},{"location":"reference/datastructures/3-headers/","text":"Headers starlite.datastructures.Headers Bases: CIMultiDictProxy [ str ] , MultiMixin [ str ] An immutable, case-insensitive for HTTP headers. Notes This class inherits from multidict . __init__ __init__ ( headers = None ) Initialize Headers . Parameters: Name Type Description Default headers Optional [ Union [ Mapping [ str , str ], RawHeaders , MultiMapping ]] Initial value. None from_scope classmethod from_scope ( scope ) Create headers from a send-message. Parameters: Name Type Description Default scope HeaderScope The ASGI connection scope. required Returns: Type Description Headers Headers Raises: Type Description ValueError If the message does not have a headers key starlite.datastructures.MutableScopeHeaders Bases: MutableMapping A case-insensitive, multidict-like structure that can be used to mutate headers within a. Scope __init__ __init__ ( scope = None ) Initialize MutableScopeHeaders from a HeaderScope . Parameters: Name Type Description Default scope Optional [ HeaderScope ] The ASGI connection scope. None add add ( key , value ) Add a header to the scope. Notes This method keeps duplicates. Parameters: Name Type Description Default key str Header key. required value str Header value. required Returns: Type Description None None. getall getall ( key , default = None ) Get all values of a header. Parameters: Name Type Description Default key str Header key. required default Optional [ List [ str ]] Default value to return if name is not found. None Returns: Type Description List [ str ] A list of strings. Raises: Type Description KeyError if no header for name was found and default is not given. extend_header_value extend_header_value ( key , value ) Extend a multivalued header. Notes A multivalues header is a header that can take a comma separated list. If the header previously did not exist, it will be added. Parameters: Name Type Description Default key str Header key. required value str Header value to add, required Returns: Type Description None None starlite.datastructures.ResponseHeader Bases: Header Container type for a response header. documentation_only class-attribute documentation_only : bool = False Defines the ResponseHeader instance as for OpenAPI documentation purpose only. value class-attribute value : Any = None Value to set for the response header. starlite.datastructures.headers.Header Bases: BaseModel , ABC An abstract type for HTTP headers. documentation_only class-attribute documentation_only : bool = False Defines the header instance as for OpenAPI documentation purpose only. starlite.datastructures.CacheControlHeader Bases: Header A cache-control header. max_age class-attribute max_age : Optional [ int ] = None Accessor for the max-age directive. s_maxage class-attribute s_maxage : Optional [ int ] = None Accessor for the s-maxage directive. no_cache class-attribute no_cache : Optional [ bool ] = None Accessor for the no-cache directive. no_store class-attribute no_store : Optional [ bool ] = None Accessor for the no-store directive. private class-attribute private : Optional [ bool ] = None Accessor for the private directive. public class-attribute public : Optional [ bool ] = None Accessor for the public directive. no_transform class-attribute no_transform : Optional [ bool ] = None Accessor for the no-transform directive. must_revalidate class-attribute must_revalidate : Optional [ bool ] = None Accessor for the must-revalidate directive. proxy_revalidate class-attribute proxy_revalidate : Optional [ bool ] = None Accessor for the proxy-revalidate directive. must_understand class-attribute must_understand : Optional [ bool ] = None Accessor for the must-understand directive. immutable class-attribute immutable : Optional [ bool ] = None Accessor for the immutable directive. stale_while_revalidate class-attribute stale_while_revalidate : Optional [ int ] = None Accessor for the stale-while-revalidate directive. from_header classmethod from_header ( header_value ) Create a CacheControlHeader instance from the header value. Parameters: Name Type Description Default header_value str the header value as string required Returns: Type Description CacheControlHeader An instance of CacheControlHeader prevent_storing classmethod prevent_storing () Create a cache-control header with the no-store directive which indicates that any caches of any kind (private or shared) should not store this response. starlite.datastructures.ETag Bases: Header An etag header. value class-attribute value : Annotated [ Optional [ str ], Field ( regex =^ [ -~ ] + $ )] = None weak class-attribute weak : bool = False","title":"Headers"},{"location":"reference/datastructures/3-headers/#headers","text":"","title":"Headers"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.Headers","text":"Bases: CIMultiDictProxy [ str ] , MultiMixin [ str ] An immutable, case-insensitive for HTTP headers. Notes This class inherits from multidict .","title":"Headers"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.Headers.__init__","text":"__init__ ( headers = None ) Initialize Headers . Parameters: Name Type Description Default headers Optional [ Union [ Mapping [ str , str ], RawHeaders , MultiMapping ]] Initial value. None","title":"__init__()"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.Headers.from_scope","text":"from_scope ( scope ) Create headers from a send-message. Parameters: Name Type Description Default scope HeaderScope The ASGI connection scope. required Returns: Type Description Headers Headers Raises: Type Description ValueError If the message does not have a headers key","title":"from_scope()"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.MutableScopeHeaders","text":"Bases: MutableMapping A case-insensitive, multidict-like structure that can be used to mutate headers within a. Scope","title":"MutableScopeHeaders"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.MutableScopeHeaders.__init__","text":"__init__ ( scope = None ) Initialize MutableScopeHeaders from a HeaderScope . Parameters: Name Type Description Default scope Optional [ HeaderScope ] The ASGI connection scope. None","title":"__init__()"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.MutableScopeHeaders.add","text":"add ( key , value ) Add a header to the scope. Notes This method keeps duplicates. Parameters: Name Type Description Default key str Header key. required value str Header value. required Returns: Type Description None None.","title":"add()"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.MutableScopeHeaders.getall","text":"getall ( key , default = None ) Get all values of a header. Parameters: Name Type Description Default key str Header key. required default Optional [ List [ str ]] Default value to return if name is not found. None Returns: Type Description List [ str ] A list of strings. Raises: Type Description KeyError if no header for name was found and default is not given.","title":"getall()"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.MutableScopeHeaders.extend_header_value","text":"extend_header_value ( key , value ) Extend a multivalued header. Notes A multivalues header is a header that can take a comma separated list. If the header previously did not exist, it will be added. Parameters: Name Type Description Default key str Header key. required value str Header value to add, required Returns: Type Description None None","title":"extend_header_value()"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.ResponseHeader","text":"Bases: Header Container type for a response header.","title":"ResponseHeader"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.response_header.ResponseHeader.documentation_only","text":"documentation_only : bool = False Defines the ResponseHeader instance as for OpenAPI documentation purpose only.","title":"documentation_only"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.response_header.ResponseHeader.value","text":"value : Any = None Value to set for the response header.","title":"value"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.Header","text":"Bases: BaseModel , ABC An abstract type for HTTP headers.","title":"Header"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.Header.documentation_only","text":"documentation_only : bool = False Defines the header instance as for OpenAPI documentation purpose only.","title":"documentation_only"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.CacheControlHeader","text":"Bases: Header A cache-control header.","title":"CacheControlHeader"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.max_age","text":"max_age : Optional [ int ] = None Accessor for the max-age directive.","title":"max_age"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.s_maxage","text":"s_maxage : Optional [ int ] = None Accessor for the s-maxage directive.","title":"s_maxage"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.no_cache","text":"no_cache : Optional [ bool ] = None Accessor for the no-cache directive.","title":"no_cache"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.no_store","text":"no_store : Optional [ bool ] = None Accessor for the no-store directive.","title":"no_store"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.private","text":"private : Optional [ bool ] = None Accessor for the private directive.","title":"private"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.public","text":"public : Optional [ bool ] = None Accessor for the public directive.","title":"public"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.no_transform","text":"no_transform : Optional [ bool ] = None Accessor for the no-transform directive.","title":"no_transform"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.must_revalidate","text":"must_revalidate : Optional [ bool ] = None Accessor for the must-revalidate directive.","title":"must_revalidate"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.proxy_revalidate","text":"proxy_revalidate : Optional [ bool ] = None Accessor for the proxy-revalidate directive.","title":"proxy_revalidate"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.must_understand","text":"must_understand : Optional [ bool ] = None Accessor for the must-understand directive.","title":"must_understand"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.immutable","text":"immutable : Optional [ bool ] = None Accessor for the immutable directive.","title":"immutable"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.stale_while_revalidate","text":"stale_while_revalidate : Optional [ int ] = None Accessor for the stale-while-revalidate directive.","title":"stale_while_revalidate"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.from_header","text":"from_header ( header_value ) Create a CacheControlHeader instance from the header value. Parameters: Name Type Description Default header_value str the header value as string required Returns: Type Description CacheControlHeader An instance of CacheControlHeader","title":"from_header()"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.CacheControlHeader.prevent_storing","text":"prevent_storing () Create a cache-control header with the no-store directive which indicates that any caches of any kind (private or shared) should not store this response.","title":"prevent_storing()"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.ETag","text":"Bases: Header An etag header.","title":"ETag"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.ETag.value","text":"value : Annotated [ Optional [ str ], Field ( regex =^ [ -~ ] + $ )] = None","title":"value"},{"location":"reference/datastructures/3-headers/#starlite.datastructures.headers.ETag.weak","text":"weak : bool = False","title":"weak"},{"location":"reference/datastructures/4-background/","text":"Background starlite.datastructures.BackgroundTask A container for a 'background' task function. Background tasks are called once a Response finishes. __init__ __init__ ( fn , * args , ** kwargs ) Initialize BackgroundTask . Parameters: Name Type Description Default fn Callable [ P , Any ] A sync or async function to call as the background task. required *args P . args Args to pass to the func. () **kwargs P . kwargs Kwargs to pass to the func {} starlite.datastructures.BackgroundTasks A container for multiple 'background' task functions. Background tasks are called once a Response finishes. __init__ __init__ ( tasks , run_in_task_group = False ) Initialize BackgroundTasks . Parameters: Name Type Description Default tasks Iterable [ BackgroundTask ] An iterable of BackgroundTask instances. required run_in_task_group bool If you set this value to True than the tasks will run concurrently, using an anyio.task_group . Note: this will not preserve execution order. False","title":"Background"},{"location":"reference/datastructures/4-background/#background","text":"","title":"Background"},{"location":"reference/datastructures/4-background/#starlite.datastructures.BackgroundTask","text":"A container for a 'background' task function. Background tasks are called once a Response finishes.","title":"BackgroundTask"},{"location":"reference/datastructures/4-background/#starlite.datastructures.background_tasks.BackgroundTask.__init__","text":"__init__ ( fn , * args , ** kwargs ) Initialize BackgroundTask . Parameters: Name Type Description Default fn Callable [ P , Any ] A sync or async function to call as the background task. required *args P . args Args to pass to the func. () **kwargs P . kwargs Kwargs to pass to the func {}","title":"__init__()"},{"location":"reference/datastructures/4-background/#starlite.datastructures.BackgroundTasks","text":"A container for multiple 'background' task functions. Background tasks are called once a Response finishes.","title":"BackgroundTasks"},{"location":"reference/datastructures/4-background/#starlite.datastructures.background_tasks.BackgroundTasks.__init__","text":"__init__ ( tasks , run_in_task_group = False ) Initialize BackgroundTasks . Parameters: Name Type Description Default tasks Iterable [ BackgroundTask ] An iterable of BackgroundTask instances. required run_in_task_group bool If you set this value to True than the tasks will run concurrently, using an anyio.task_group . Note: this will not preserve execution order. False","title":"__init__()"},{"location":"reference/datastructures/5-response-containers/","text":"Response Containers starlite.datastructures.ResponseContainer Bases: ABC , GenericModel , Generic [ R ] Generic response container. background class-attribute background : Optional [ Union [ BackgroundTask , BackgroundTasks ]] = None A BackgroundTask instance or. BackgroundTasks to execute after the response is finished. Defaults to None. cookies class-attribute cookies : List [ Cookie ] = [] A list of Cookie instances to be set under the response 'Set-Cookie' header. Defaults to None. encoding class-attribute encoding : str = 'utf-8' The encoding to be used for the response headers. headers class-attribute headers : Dict [ str , Any ] = {} A string/string dictionary of response headers. Header keys are insensitive. Defaults to None. media_type class-attribute media_type : Optional [ Union [ MediaType , str ]] = None If defined, overrides the media type configured in the route decorator. to_response abstractmethod to_response ( headers , media_type , status_code , app , request ) Abstract method that should be implemented by subclasses. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description R A Response Object starlite.datastructures.File Bases: ResponseContainer [ FileResponse ] Container type for returning File responses. chunk_size class-attribute chunk_size : int = DEFAULT_CHUNK_SIZE The size of chunks to use when streaming the file. content_disposition_type class-attribute content_disposition_type : Literal [ 'attachment' , 'inline' ] = 'attachment' The type of the 'Content-Disposition'. Either 'inline' or 'attachment'. etag class-attribute etag : Optional [ ETag ] = None An optional ETag instance. If not provided, an etag will be automatically generated. file_info class-attribute file_info : Optional [ FileInfo ] = None The output of calling file_system.info(..) , equivalent to providing a stat_result . file_system class-attribute file_system : Any = BaseLocalFileSystem () The file_system spec to use loading the file. Notes A file_system is a class that adheres to the FileSystemProtocol . You can use any of the file systems exported from the fsspec library for this purpose. filename class-attribute filename : Optional [ str ] = None An optional filename to set in the header. path class-attribute path : FilePath Path to the file to send. stat_result class-attribute stat_result : Optional [ os . stat_result ] = None An optional result of calling 'os.stat'. If not provided, this will be done by the response constructor. to_response to_response ( headers , media_type , status_code , app , request ) Create a FileResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Optional [ Union [ MediaType , str ]] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description FileResponse A FileResponse instance to_response to_response ( headers , media_type , status_code , app , request ) Create a FileResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Optional [ Union [ MediaType , str ]] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description FileResponse A FileResponse instance starlite.datastructures.Redirect Bases: ResponseContainer [ RedirectResponse ] Container type for returning Redirect responses. path class-attribute path : str Redirection path. to_response to_response ( headers , media_type , status_code , app , request ) Create a RedirectResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code Literal [301, 302, 303, 307, 308] A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description RedirectResponse A RedirectResponse instance starlite.datastructures.Stream Bases: ResponseContainer [ StreamingResponse ] Container type for returning Stream responses. iterator class-attribute iterator : Union [ StreamType [ Union [ str , bytes ]], Callable [[], StreamType [ Union [ str , bytes ]]]] Iterator, Iterable,Generator or async Iterator, Iterable or Generator returning chunks to stream. to_response to_response ( headers , media_type , status_code , app , request ) Create a StreamingResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description StreamingResponse A StreamingResponse instance starlite.datastructures.Template Bases: ResponseContainer [ TemplateResponse ] Container type for returning Template responses. context class-attribute context : Dict [ str , Any ] = {} A dictionary of key/value pairs to be passed to the temple engine's render method. Defaults to None. name class-attribute name : str Path-like name for the template to be rendered, e.g. \"index.html\". to_response to_response ( headers , media_type , status_code , app , request ) Create a TemplateResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] if app.template_engine is not configured. Returns: Type Description TemplateResponse A TemplateResponse instance","title":"Response Containers"},{"location":"reference/datastructures/5-response-containers/#response-containers","text":"","title":"Response Containers"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.ResponseContainer","text":"Bases: ABC , GenericModel , Generic [ R ] Generic response container.","title":"ResponseContainer"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.background","text":"background : Optional [ Union [ BackgroundTask , BackgroundTasks ]] = None A BackgroundTask instance or. BackgroundTasks to execute after the response is finished. Defaults to None.","title":"background"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.cookies","text":"cookies : List [ Cookie ] = [] A list of Cookie instances to be set under the response 'Set-Cookie' header. Defaults to None.","title":"cookies"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.encoding","text":"encoding : str = 'utf-8' The encoding to be used for the response headers.","title":"encoding"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.headers","text":"headers : Dict [ str , Any ] = {} A string/string dictionary of response headers. Header keys are insensitive. Defaults to None.","title":"headers"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.media_type","text":"media_type : Optional [ Union [ MediaType , str ]] = None If defined, overrides the media type configured in the route decorator.","title":"media_type"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.ResponseContainer.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Abstract method that should be implemented by subclasses. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description R A Response Object","title":"to_response()"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.File","text":"Bases: ResponseContainer [ FileResponse ] Container type for returning File responses.","title":"File"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.chunk_size","text":"chunk_size : int = DEFAULT_CHUNK_SIZE The size of chunks to use when streaming the file.","title":"chunk_size"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.content_disposition_type","text":"content_disposition_type : Literal [ 'attachment' , 'inline' ] = 'attachment' The type of the 'Content-Disposition'. Either 'inline' or 'attachment'.","title":"content_disposition_type"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.etag","text":"etag : Optional [ ETag ] = None An optional ETag instance. If not provided, an etag will be automatically generated.","title":"etag"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.file_info","text":"file_info : Optional [ FileInfo ] = None The output of calling file_system.info(..) , equivalent to providing a stat_result .","title":"file_info"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.file_system","text":"file_system : Any = BaseLocalFileSystem () The file_system spec to use loading the file. Notes A file_system is a class that adheres to the FileSystemProtocol . You can use any of the file systems exported from the fsspec library for this purpose.","title":"file_system"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.filename","text":"filename : Optional [ str ] = None An optional filename to set in the header.","title":"filename"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.path","text":"path : FilePath Path to the file to send.","title":"path"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.stat_result","text":"stat_result : Optional [ os . stat_result ] = None An optional result of calling 'os.stat'. If not provided, this will be done by the response constructor.","title":"stat_result"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Create a FileResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Optional [ Union [ MediaType , str ]] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description FileResponse A FileResponse instance","title":"to_response()"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.File.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Create a FileResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Optional [ Union [ MediaType , str ]] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description FileResponse A FileResponse instance","title":"to_response()"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.Redirect","text":"Bases: ResponseContainer [ RedirectResponse ] Container type for returning Redirect responses.","title":"Redirect"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Redirect.path","text":"path : str Redirection path.","title":"path"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Redirect.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Create a RedirectResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code Literal [301, 302, 303, 307, 308] A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description RedirectResponse A RedirectResponse instance","title":"to_response()"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.Stream","text":"Bases: ResponseContainer [ StreamingResponse ] Container type for returning Stream responses.","title":"Stream"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Stream.iterator","text":"iterator : Union [ StreamType [ Union [ str , bytes ]], Callable [[], StreamType [ Union [ str , bytes ]]]] Iterator, Iterable,Generator or async Iterator, Iterable or Generator returning chunks to stream.","title":"iterator"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Stream.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Create a StreamingResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Returns: Type Description StreamingResponse A StreamingResponse instance","title":"to_response()"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.Template","text":"Bases: ResponseContainer [ TemplateResponse ] Container type for returning Template responses.","title":"Template"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Template.context","text":"context : Dict [ str , Any ] = {} A dictionary of key/value pairs to be passed to the temple engine's render method. Defaults to None.","title":"context"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Template.name","text":"name : str Path-like name for the template to be rendered, e.g. \"index.html\".","title":"name"},{"location":"reference/datastructures/5-response-containers/#starlite.datastructures.response_containers.Template.to_response","text":"to_response ( headers , media_type , status_code , app , request ) Create a TemplateResponse instance. Parameters: Name Type Description Default headers Dict [ str , Any ] A dictionary of headers. required media_type Union [ MediaType , str ] A string or member of the MediaType enum. required status_code int A response status code. required app Starlite The Starlite application instance. required request Request A Request instance. required Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] if app.template_engine is not configured. Returns: Type Description TemplateResponse A TemplateResponse instance","title":"to_response()"},{"location":"reference/datastructures/6-upload-file/","text":"Upload File starlite.datastructures.UploadFile Representation of a file upload, modifying the pydantic schema. rolled_to_disk property rolled_to_disk : bool Determine whether the spooled file exceeded the rolled-to-disk threshold and is no longer in memory. Returns: Type Description bool A boolean flag __init__ __init__ ( content_type , filename , file_data = None , headers = None , max_spool_size = ONE_MEGABYTE ) Upload file in-memory container. Parameters: Name Type Description Default content_type str Content type for the file. required filename str The filename. required file_data Optional [ bytes ] File data. None headers Optional [ Dict [ str , str ]] Any attached headers. None max_spool_size int The size above which the temporary file will be rolled to disk. ONE_MEGABYTE close async close () Async proxy for file close. Returns: Type Description None None. read async read ( size =- 1 ) Proxy for data reading. Parameters: Name Type Description Default size int position from which to read. -1 Returns: Type Description bytes Byte string. seek async seek ( offset ) Async proxy for file seek. Parameters: Name Type Description Default offset int start position.. required Returns: Type Description int None. write async write ( data ) Proxy for data writing. Parameters: Name Type Description Default data bytes Byte string to write. required Returns: Type Description int None","title":"Upload File"},{"location":"reference/datastructures/6-upload-file/#upload-file","text":"","title":"Upload File"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.UploadFile","text":"Representation of a file upload, modifying the pydantic schema.","title":"UploadFile"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.rolled_to_disk","text":"rolled_to_disk : bool Determine whether the spooled file exceeded the rolled-to-disk threshold and is no longer in memory. Returns: Type Description bool A boolean flag","title":"rolled_to_disk"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.__init__","text":"__init__ ( content_type , filename , file_data = None , headers = None , max_spool_size = ONE_MEGABYTE ) Upload file in-memory container. Parameters: Name Type Description Default content_type str Content type for the file. required filename str The filename. required file_data Optional [ bytes ] File data. None headers Optional [ Dict [ str , str ]] Any attached headers. None max_spool_size int The size above which the temporary file will be rolled to disk. ONE_MEGABYTE","title":"__init__()"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.close","text":"close () Async proxy for file close. Returns: Type Description None None.","title":"close()"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.read","text":"read ( size =- 1 ) Proxy for data reading. Parameters: Name Type Description Default size int position from which to read. -1 Returns: Type Description bytes Byte string.","title":"read()"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.seek","text":"seek ( offset ) Async proxy for file seek. Parameters: Name Type Description Default offset int start position.. required Returns: Type Description int None.","title":"seek()"},{"location":"reference/datastructures/6-upload-file/#starlite.datastructures.upload_file.UploadFile.write","text":"write ( data ) Proxy for data writing. Parameters: Name Type Description Default data bytes Byte string to write. required Returns: Type Description int None","title":"write()"},{"location":"reference/datastructures/7-multi-dicts/","text":"Multi-Dicts starlite.datastructures.multi_dicts.MultiMixin Bases: Generic [ T ] , MultiMapping [ T ] , ABC Mixin providing common methods for multi dicts, used by. ImmutableMultiDict and MultiDict multi_items multi_items () Get all keys and values, including duplicates. Returns: Type Description Generator [ Tuple [ str , T ], None, None] A list of tuples containing key-value pairs dict dict () Return the multi-dict as a dict of lists. Returns: Type Description Dict [ str , List [ Any ]] A dict of lists starlite.datastructures.MultiDict Bases: BaseMultiDict [ T ] , MultiMixin [ T ] , Generic [ T ] MultiDict, using MultiDict . starlite.datastructures.ImmutableMultiDict Bases: MultiDictProxy [ T ] , MultiMixin [ T ] , Generic [ T ] Immutable MultiDict, using. MultiDictProxy . starlite.datastructures.FormMultiDict Bases: ImmutableMultiDict [ Any ] MultiDict for form data. close async close () Close all files in the multi-dict. Returns: Type Description None None","title":"Multi-Dicts"},{"location":"reference/datastructures/7-multi-dicts/#multi-dicts","text":"","title":"Multi-Dicts"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.multi_dicts.MultiMixin","text":"Bases: Generic [ T ] , MultiMapping [ T ] , ABC Mixin providing common methods for multi dicts, used by. ImmutableMultiDict and MultiDict","title":"MultiMixin"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.multi_dicts.MultiMixin.multi_items","text":"multi_items () Get all keys and values, including duplicates. Returns: Type Description Generator [ Tuple [ str , T ], None, None] A list of tuples containing key-value pairs","title":"multi_items()"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.multi_dicts.MultiMixin.dict","text":"dict () Return the multi-dict as a dict of lists. Returns: Type Description Dict [ str , List [ Any ]] A dict of lists","title":"dict()"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.MultiDict","text":"Bases: BaseMultiDict [ T ] , MultiMixin [ T ] , Generic [ T ] MultiDict, using MultiDict .","title":"MultiDict"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.ImmutableMultiDict","text":"Bases: MultiDictProxy [ T ] , MultiMixin [ T ] , Generic [ T ] Immutable MultiDict, using. MultiDictProxy .","title":"ImmutableMultiDict"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.FormMultiDict","text":"Bases: ImmutableMultiDict [ Any ] MultiDict for form data.","title":"FormMultiDict"},{"location":"reference/datastructures/7-multi-dicts/#starlite.datastructures.multi_dicts.FormMultiDict.close","text":"close () Close all files in the multi-dict. Returns: Type Description None None","title":"close()"},{"location":"reference/datastructures/8-url/","text":"URL starlite.datastructures.URL Representation and modification utilities of a URL. fragment class-attribute fragment : str Fragment component. hostname class-attribute hostname : Optional [ str ] Hostname if specified. netloc class-attribute netloc : str Network location. password class-attribute password : Optional [ str ] Password if specified. path class-attribute path : str Hierarchical path. port class-attribute port : Optional [ int ] Port if specified. query class-attribute query : str Query string. scheme class-attribute scheme : str URL scheme. username class-attribute username : Optional [ str ] Username if specified. query_params property query_params : MultiDict Query parameters of a URL as a MultiDict Returns: Type Description MultiDict A MultiDict with query parameters Notes While the returned MultiDict is mutable, URL itself is immutable , therefore mutating the query parameters will not directly mutate the URL . If you want to modify query parameters, make modifications in the multidict and pass them back to with_replacements from_components cached classmethod from_components ( scheme = '' , netloc = '' , path = '' , fragment = '' , query = '' ) Create a new URL from components. Parameters: Name Type Description Default scheme str URL scheme '' netloc str Network location '' path str Hierarchical path '' query str Query component '' fragment str Fragment identifier '' Returns: Type Description URL A new URL with the given components from_scope classmethod from_scope ( scope ) Construct a URL from a Scope Parameters: Name Type Description Default scope Scope A scope required Returns: Type Description URL A URL with_replacements with_replacements ( scheme = '' , netloc = '' , path = '' , query = None , fragment = '' ) Create a new URL, replacing the given components. Parameters: Name Type Description Default scheme str URL scheme '' netloc str Network location '' path str Hierarchical path '' query Optional [ Union [ str , MultiDict ]] Raw query string None fragment str Fragment identifier '' Returns: Type Description URL A new URL with the given components replaced starlite.datastructures.Address Bases: NamedTuple Just a network address. host class-attribute host : str Address host. port class-attribute port : int Address port. starlite.datastructures.url.make_absolute_url starlite . datastructures . url . make_absolute_url ( path , base ) Create an absolute URL. Parameters: Name Type Description Default path Union [ str , URL ] URL path to make absolute required base Union [ str , URL ] URL to use as a base required Returns: Type Description str A string representing the new, absolute URL","title":"URL"},{"location":"reference/datastructures/8-url/#url","text":"","title":"URL"},{"location":"reference/datastructures/8-url/#starlite.datastructures.URL","text":"Representation and modification utilities of a URL.","title":"URL"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.fragment","text":"fragment : str Fragment component.","title":"fragment"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.hostname","text":"hostname : Optional [ str ] Hostname if specified.","title":"hostname"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.netloc","text":"netloc : str Network location.","title":"netloc"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.password","text":"password : Optional [ str ] Password if specified.","title":"password"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.path","text":"path : str Hierarchical path.","title":"path"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.port","text":"port : Optional [ int ] Port if specified.","title":"port"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.query","text":"query : str Query string.","title":"query"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.scheme","text":"scheme : str URL scheme.","title":"scheme"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.username","text":"username : Optional [ str ] Username if specified.","title":"username"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.query_params","text":"query_params : MultiDict Query parameters of a URL as a MultiDict Returns: Type Description MultiDict A MultiDict with query parameters Notes While the returned MultiDict is mutable, URL itself is immutable , therefore mutating the query parameters will not directly mutate the URL . If you want to modify query parameters, make modifications in the multidict and pass them back to with_replacements","title":"query_params"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.from_components","text":"from_components ( scheme = '' , netloc = '' , path = '' , fragment = '' , query = '' ) Create a new URL from components. Parameters: Name Type Description Default scheme str URL scheme '' netloc str Network location '' path str Hierarchical path '' query str Query component '' fragment str Fragment identifier '' Returns: Type Description URL A new URL with the given components","title":"from_components()"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.from_scope","text":"from_scope ( scope ) Construct a URL from a Scope Parameters: Name Type Description Default scope Scope A scope required Returns: Type Description URL A URL","title":"from_scope()"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.URL.with_replacements","text":"with_replacements ( scheme = '' , netloc = '' , path = '' , query = None , fragment = '' ) Create a new URL, replacing the given components. Parameters: Name Type Description Default scheme str URL scheme '' netloc str Network location '' path str Hierarchical path '' query Optional [ Union [ str , MultiDict ]] Raw query string None fragment str Fragment identifier '' Returns: Type Description URL A new URL with the given components replaced","title":"with_replacements()"},{"location":"reference/datastructures/8-url/#starlite.datastructures.Address","text":"Bases: NamedTuple Just a network address.","title":"Address"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.Address.host","text":"host : str Address host.","title":"host"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.Address.port","text":"port : int Address port.","title":"port"},{"location":"reference/datastructures/8-url/#starlite.datastructures.url.make_absolute_url","text":"starlite . datastructures . url . make_absolute_url ( path , base ) Create an absolute URL. Parameters: Name Type Description Default path Union [ str , URL ] URL path to make absolute required base Union [ str , URL ] URL to use as a base required Returns: Type Description str A string representing the new, absolute URL","title":"make_absolute_url()"},{"location":"reference/datastructures/9-pagination/","text":"Pagination Containers starlite.datastructures.ClassicPagination dataclass Bases: Generic [ T ] Container for data returned using limit/offset pagination. items class-attribute items : List [ T ] List of data being sent as part of the response. page_size class-attribute page_size : int Number of items per page. current_page class-attribute current_page : int Current page number. total_pages class-attribute total_pages : int Total number of pages. starlite.datastructures.OffsetPagination dataclass Bases: Generic [ T ] Container for data returned using limit/offset pagination. items class-attribute items : List [ T ] List of data being sent as part of the response. limit class-attribute limit : int Maximal number of items to send. offset class-attribute offset : int Offset from the beginning of the query. Identical to an index. total class-attribute total : int Total number of items. starlite.datastructures.CursorPagination dataclass Bases: Generic [ C , T ] Container for data returned using cursor pagination. items class-attribute items : List [ T ] List of data being sent as part of the response. results_per_page class-attribute results_per_page : int Maximal number of items to send. cursor class-attribute cursor : Optional [ C ] Unique ID, designating the last identifier in the given data set. This value can be used to request the \"next\" batch of records. starlite.datastructures.AbstractSyncClassicPaginator Bases: ABC , Generic [ T ] Base paginator class for sync classic pagination. Implement this class to return paginated result sets using the classic pagination scheme. __call__ __call__ ( page_size , current_page ) Return a paginated result set. Parameters: Name Type Description Default page_size int Maximal number of records to return. required current_page int The current page of results to return. required Returns: Type Description ClassicPagination [ T ] A paginated result set. get_items abstractmethod get_items ( page_size , current_page ) Return a list of items of the given size 'page_size' correlating with 'current_page'. Parameters: Name Type Description Default page_size int Maximal number of records to return. required current_page int The current page of results to return. required Returns: Type Description List [ T ] A list of items. get_total abstractmethod get_total ( page_size ) Return the total number of records. Parameters: Name Type Description Default page_size int Maximal number of records to return. required Returns: Type Description int An integer. starlite.datastructures.AbstractAsyncClassicPaginator Bases: ABC , Generic [ T ] Base paginator class for async classic pagination. Implement this class to return paginated result sets using the classic pagination scheme. __call__ async __call__ ( page_size , current_page ) Return a paginated result set. Parameters: Name Type Description Default page_size int Maximal number of records to return. required current_page int The current page of results to return. required Returns: Type Description ClassicPagination [ T ] A paginated result set. get_items async abstractmethod get_items ( page_size , current_page ) Return a list of items of the given size 'page_size' correlating with 'current_page'. Parameters: Name Type Description Default page_size int Maximal number of records to return. required current_page int The current page of results to return. required Returns: Type Description List [ T ] A list of items. get_total async abstractmethod get_total ( page_size ) Return the total number of records. Parameters: Name Type Description Default page_size int Maximal number of records to return. required Returns: Type Description int An integer. starlite.datastructures.AbstractSyncOffsetPaginator Bases: ABC , Generic [ T ] Base paginator class for limit / offset pagination. Implement this class to return paginated result sets using the limit / offset pagination scheme. __call__ __call__ ( limit , offset ) Return a paginated result set. Parameters: Name Type Description Default limit int Maximal number of records to return. required offset int Starting position within the result set (assume index 0 as starting position). required Returns: Type Description OffsetPagination [ T ] A paginated result set. get_items abstractmethod get_items ( limit , offset ) Return a list of items of the given size 'limit' starting from position 'offset'. Parameters: Name Type Description Default limit int Maximal number of records to return. required offset int Starting position within the result set (assume index 0 as starting position). required Returns: Type Description List [ T ] A list of items. get_total abstractmethod get_total () Return the total number of records. Returns: Type Description int An integer. starlite.datastructures.AbstractAsyncOffsetPaginator Bases: ABC , Generic [ T ] Base paginator class for limit / offset pagination. Implement this class to return paginated result sets using the limit / offset pagination scheme. __call__ async __call__ ( limit , offset ) Return a paginated result set. Parameters: Name Type Description Default limit int Maximal number of records to return. required offset int Starting position within the result set (assume index 0 as starting position). required Returns: Type Description OffsetPagination [ T ] A paginated result set. get_items async abstractmethod get_items ( limit , offset ) Return a list of items of the given size 'limit' starting from position 'offset'. Parameters: Name Type Description Default limit int Maximal number of records to return. required offset int Starting position within the result set (assume index 0 as starting position). required Returns: Type Description List [ T ] A list of items. get_total async abstractmethod get_total () Return the total number of records. Returns: Type Description int An integer. starlite.datastructures.AbstractSyncCursorPaginator Bases: ABC , Generic [ C , T ] Base paginator class for sync cursor pagination. Implement this class to return paginated result sets using the cursor pagination scheme. __call__ __call__ ( cursor , results_per_page ) Return a paginated result set given an optional cursor (unique ID) and a maximal number of results to return. Parameters: Name Type Description Default cursor Optional [ C ] A unique identifier that acts as the 'cursor' after which results should be given. required results_per_page int A maximal number of results to return. required Returns: Type Description CursorPagination [ C , T ] A paginated result set. get_items abstractmethod get_items ( cursor , results_per_page ) Return a list of items of the size 'results_per_page' following the given cursor, if any, Parameters: Name Type Description Default cursor Optional [ C ] A unique identifier that acts as the 'cursor' after which results should be given. required results_per_page int A maximal number of results to return. required Returns: Type Description List [ T ] A tuple containing the result set and a new cursor that marks the last record retrieved. Optional [ C ] The new cursor can be used to ask for the 'next_cursor' batch of results. starlite.datastructures.AbstractAsyncCursorPaginator Bases: ABC , Generic [ C , T ] Base paginator class for async cursor pagination. Implement this class to return paginated result sets using the cursor pagination scheme. __call__ async __call__ ( cursor , results_per_page ) Return a paginated result set given an optional cursor (unique ID) and a maximal number of results to return. Parameters: Name Type Description Default cursor Optional [ C ] A unique identifier that acts as the 'cursor' after which results should be given. required results_per_page int A maximal number of results to return. required Returns: Type Description CursorPagination [ C , T ] A paginated result set. get_items async abstractmethod get_items ( cursor , results_per_page ) Return a list of items of the size 'results_per_page' following the given cursor, if any, Parameters: Name Type Description Default cursor Optional [ C ] A unique identifier that acts as the 'cursor' after which results should be given. required results_per_page int A maximal number of results to return. required Returns: Type Description List [ T ] A tuple containing the result set and a new cursor that marks the last record retrieved. Optional [ C ] The new cursor can be used to ask for the 'next_cursor' batch of results.","title":"Pagination Containers"},{"location":"reference/datastructures/9-pagination/#pagination-containers","text":"","title":"Pagination Containers"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.ClassicPagination","text":"Bases: Generic [ T ] Container for data returned using limit/offset pagination.","title":"ClassicPagination"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.ClassicPagination.items","text":"items : List [ T ] List of data being sent as part of the response.","title":"items"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.ClassicPagination.page_size","text":"page_size : int Number of items per page.","title":"page_size"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.ClassicPagination.current_page","text":"current_page : int Current page number.","title":"current_page"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.ClassicPagination.total_pages","text":"total_pages : int Total number of pages.","title":"total_pages"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.OffsetPagination","text":"Bases: Generic [ T ] Container for data returned using limit/offset pagination.","title":"OffsetPagination"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.OffsetPagination.items","text":"items : List [ T ] List of data being sent as part of the response.","title":"items"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.OffsetPagination.limit","text":"limit : int Maximal number of items to send.","title":"limit"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.OffsetPagination.offset","text":"offset : int Offset from the beginning of the query. Identical to an index.","title":"offset"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.OffsetPagination.total","text":"total : int Total number of items.","title":"total"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.CursorPagination","text":"Bases: Generic [ C , T ] Container for data returned using cursor pagination.","title":"CursorPagination"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.CursorPagination.items","text":"items : List [ T ] List of data being sent as part of the response.","title":"items"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.CursorPagination.results_per_page","text":"results_per_page : int Maximal number of items to send.","title":"results_per_page"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.CursorPagination.cursor","text":"cursor : Optional [ C ] Unique ID, designating the last identifier in the given data set. This value can be used to request the \"next\" batch of records.","title":"cursor"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractSyncClassicPaginator","text":"Bases: ABC , Generic [ T ] Base paginator class for sync classic pagination. Implement this class to return paginated result sets using the classic pagination scheme.","title":"AbstractSyncClassicPaginator"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncClassicPaginator.__call__","text":"__call__ ( page_size , current_page ) Return a paginated result set. Parameters: Name Type Description Default page_size int Maximal number of records to return. required current_page int The current page of results to return. required Returns: Type Description ClassicPagination [ T ] A paginated result set.","title":"__call__()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncClassicPaginator.get_items","text":"get_items ( page_size , current_page ) Return a list of items of the given size 'page_size' correlating with 'current_page'. Parameters: Name Type Description Default page_size int Maximal number of records to return. required current_page int The current page of results to return. required Returns: Type Description List [ T ] A list of items.","title":"get_items()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncClassicPaginator.get_total","text":"get_total ( page_size ) Return the total number of records. Parameters: Name Type Description Default page_size int Maximal number of records to return. required Returns: Type Description int An integer.","title":"get_total()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractAsyncClassicPaginator","text":"Bases: ABC , Generic [ T ] Base paginator class for async classic pagination. Implement this class to return paginated result sets using the classic pagination scheme.","title":"AbstractAsyncClassicPaginator"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncClassicPaginator.__call__","text":"__call__ ( page_size , current_page ) Return a paginated result set. Parameters: Name Type Description Default page_size int Maximal number of records to return. required current_page int The current page of results to return. required Returns: Type Description ClassicPagination [ T ] A paginated result set.","title":"__call__()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncClassicPaginator.get_items","text":"get_items ( page_size , current_page ) Return a list of items of the given size 'page_size' correlating with 'current_page'. Parameters: Name Type Description Default page_size int Maximal number of records to return. required current_page int The current page of results to return. required Returns: Type Description List [ T ] A list of items.","title":"get_items()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncClassicPaginator.get_total","text":"get_total ( page_size ) Return the total number of records. Parameters: Name Type Description Default page_size int Maximal number of records to return. required Returns: Type Description int An integer.","title":"get_total()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractSyncOffsetPaginator","text":"Bases: ABC , Generic [ T ] Base paginator class for limit / offset pagination. Implement this class to return paginated result sets using the limit / offset pagination scheme.","title":"AbstractSyncOffsetPaginator"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncOffsetPaginator.__call__","text":"__call__ ( limit , offset ) Return a paginated result set. Parameters: Name Type Description Default limit int Maximal number of records to return. required offset int Starting position within the result set (assume index 0 as starting position). required Returns: Type Description OffsetPagination [ T ] A paginated result set.","title":"__call__()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncOffsetPaginator.get_items","text":"get_items ( limit , offset ) Return a list of items of the given size 'limit' starting from position 'offset'. Parameters: Name Type Description Default limit int Maximal number of records to return. required offset int Starting position within the result set (assume index 0 as starting position). required Returns: Type Description List [ T ] A list of items.","title":"get_items()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncOffsetPaginator.get_total","text":"get_total () Return the total number of records. Returns: Type Description int An integer.","title":"get_total()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractAsyncOffsetPaginator","text":"Bases: ABC , Generic [ T ] Base paginator class for limit / offset pagination. Implement this class to return paginated result sets using the limit / offset pagination scheme.","title":"AbstractAsyncOffsetPaginator"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncOffsetPaginator.__call__","text":"__call__ ( limit , offset ) Return a paginated result set. Parameters: Name Type Description Default limit int Maximal number of records to return. required offset int Starting position within the result set (assume index 0 as starting position). required Returns: Type Description OffsetPagination [ T ] A paginated result set.","title":"__call__()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncOffsetPaginator.get_items","text":"get_items ( limit , offset ) Return a list of items of the given size 'limit' starting from position 'offset'. Parameters: Name Type Description Default limit int Maximal number of records to return. required offset int Starting position within the result set (assume index 0 as starting position). required Returns: Type Description List [ T ] A list of items.","title":"get_items()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncOffsetPaginator.get_total","text":"get_total () Return the total number of records. Returns: Type Description int An integer.","title":"get_total()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractSyncCursorPaginator","text":"Bases: ABC , Generic [ C , T ] Base paginator class for sync cursor pagination. Implement this class to return paginated result sets using the cursor pagination scheme.","title":"AbstractSyncCursorPaginator"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncCursorPaginator.__call__","text":"__call__ ( cursor , results_per_page ) Return a paginated result set given an optional cursor (unique ID) and a maximal number of results to return. Parameters: Name Type Description Default cursor Optional [ C ] A unique identifier that acts as the 'cursor' after which results should be given. required results_per_page int A maximal number of results to return. required Returns: Type Description CursorPagination [ C , T ] A paginated result set.","title":"__call__()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractSyncCursorPaginator.get_items","text":"get_items ( cursor , results_per_page ) Return a list of items of the size 'results_per_page' following the given cursor, if any, Parameters: Name Type Description Default cursor Optional [ C ] A unique identifier that acts as the 'cursor' after which results should be given. required results_per_page int A maximal number of results to return. required Returns: Type Description List [ T ] A tuple containing the result set and a new cursor that marks the last record retrieved. Optional [ C ] The new cursor can be used to ask for the 'next_cursor' batch of results.","title":"get_items()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.AbstractAsyncCursorPaginator","text":"Bases: ABC , Generic [ C , T ] Base paginator class for async cursor pagination. Implement this class to return paginated result sets using the cursor pagination scheme.","title":"AbstractAsyncCursorPaginator"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncCursorPaginator.__call__","text":"__call__ ( cursor , results_per_page ) Return a paginated result set given an optional cursor (unique ID) and a maximal number of results to return. Parameters: Name Type Description Default cursor Optional [ C ] A unique identifier that acts as the 'cursor' after which results should be given. required results_per_page int A maximal number of results to return. required Returns: Type Description CursorPagination [ C , T ] A paginated result set.","title":"__call__()"},{"location":"reference/datastructures/9-pagination/#starlite.datastructures.pagination.AbstractAsyncCursorPaginator.get_items","text":"get_items ( cursor , results_per_page ) Return a list of items of the size 'results_per_page' following the given cursor, if any, Parameters: Name Type Description Default cursor Optional [ C ] A unique identifier that acts as the 'cursor' after which results should be given. required results_per_page int A maximal number of results to return. required Returns: Type Description List [ T ] A tuple containing the result set and a new cursor that marks the last record retrieved. Optional [ C ] The new cursor can be used to ask for the 'next_cursor' batch of results.","title":"get_items()"},{"location":"reference/exceptions/0-base-exceptions/","text":"Base Exceptions starlite.exceptions.StarLiteException Bases: Exception Base exception class from which all Starlite exceptions inherit. __init__ __init__ ( * args , detail = '' ) Initialize StarLiteException . Parameters: Name Type Description Default *args Any args are cast to str before passing to Exception.__init__() () detail str detail of the exception. '' starlite.exceptions.MissingDependencyException Bases: StarLiteException Missing optional dependency. This exception is raised only when a module depends on a dependency that has not been installed.","title":"Base Exceptions"},{"location":"reference/exceptions/0-base-exceptions/#base-exceptions","text":"","title":"Base Exceptions"},{"location":"reference/exceptions/0-base-exceptions/#starlite.exceptions.StarLiteException","text":"Bases: Exception Base exception class from which all Starlite exceptions inherit.","title":"StarLiteException"},{"location":"reference/exceptions/0-base-exceptions/#starlite.exceptions.base_exceptions.StarLiteException.__init__","text":"__init__ ( * args , detail = '' ) Initialize StarLiteException . Parameters: Name Type Description Default *args Any args are cast to str before passing to Exception.__init__() () detail str detail of the exception. ''","title":"__init__()"},{"location":"reference/exceptions/0-base-exceptions/#starlite.exceptions.MissingDependencyException","text":"Bases: StarLiteException Missing optional dependency. This exception is raised only when a module depends on a dependency that has not been installed.","title":"MissingDependencyException"},{"location":"reference/exceptions/1-http-exceptions/","text":"HTTP Exceptions starlite.exceptions.HTTPException Bases: StarLiteException Base exception for HTTP error responses. These exceptions carry information to construct an HTTP response. detail instance-attribute detail = detail extra instance-attribute extra = extra headers instance-attribute headers = headers status_code instance-attribute status_code = status_code or self . status_code __init__ __init__ ( * args , detail = '' , status_code = None , headers = None , extra = None ) Initialize HTTPException . Set detail and args if not provided. Parameters: Name Type Description Default *args Any if detail kwarg not provided, first arg should be error detail. () detail str Exception details or message. Will default to args[0] if not provided. '' status_code Optional [ int ] Exception HTTP status code. None headers Optional [ Dict [ str , str ]] Headers to set on the response. None extra Optional [ Union [ Dict [ str , Any ], List [ Any ]]] An extra mapping to attach to the exception. None starlite.exceptions.ImproperlyConfiguredException Bases: HTTPException , ValueError Application has improper configuration. starlite.exceptions.InternalServerException Bases: HTTPException Server encountered an unexpected condition that prevented it from fulfilling the request. status_code class-attribute status_code = HTTP_500_INTERNAL_SERVER_ERROR starlite.exceptions.MethodNotAllowedException Bases: HTTPException Server knows the request method, but the target resource doesn't support this method. status_code class-attribute status_code = HTTP_405_METHOD_NOT_ALLOWED starlite.exceptions.NotAuthorizedException Bases: HTTPException Request lacks valid authentication credentials for the requested resource. status_code class-attribute status_code = HTTP_401_UNAUTHORIZED starlite.exceptions.NoRouteMatchFoundException Bases: InternalServerException A route with the given name could not be found. starlite.exceptions.NotFoundException Bases: HTTPException , ValueError Cannot find the requested resource. status_code class-attribute status_code = HTTP_404_NOT_FOUND starlite.exceptions.PermissionDeniedException Bases: HTTPException Request understood, but not authorized. status_code class-attribute status_code = HTTP_403_FORBIDDEN starlite.exceptions.ServiceUnavailableException Bases: HTTPException Server is not ready to handle the request. starlite.exceptions.TemplateNotFoundException Bases: InternalServerException Referenced template could not be found. __init__ __init__ ( * args , template_name ) Initialize TemplateNotFoundException . Parameters: Name Type Description Default *args Any Passed through to super().__init__() - should not include detail . () template_name str Name of template that could not be found. required starlite.exceptions.TooManyRequestsException Bases: HTTPException Request limits have been exceeded. status_code class-attribute status_code = HTTP_429_TOO_MANY_REQUESTS starlite.exceptions.ValidationException Bases: HTTPException , ValueError Client error. status_code class-attribute status_code = HTTP_400_BAD_REQUEST","title":"HTTP Exceptions"},{"location":"reference/exceptions/1-http-exceptions/#http-exceptions","text":"","title":"HTTP Exceptions"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.HTTPException","text":"Bases: StarLiteException Base exception for HTTP error responses. These exceptions carry information to construct an HTTP response.","title":"HTTPException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.detail","text":"detail = detail","title":"detail"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.extra","text":"extra = extra","title":"extra"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.headers","text":"headers = headers","title":"headers"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.status_code","text":"status_code = status_code or self . status_code","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.HTTPException.__init__","text":"__init__ ( * args , detail = '' , status_code = None , headers = None , extra = None ) Initialize HTTPException . Set detail and args if not provided. Parameters: Name Type Description Default *args Any if detail kwarg not provided, first arg should be error detail. () detail str Exception details or message. Will default to args[0] if not provided. '' status_code Optional [ int ] Exception HTTP status code. None headers Optional [ Dict [ str , str ]] Headers to set on the response. None extra Optional [ Union [ Dict [ str , Any ], List [ Any ]]] An extra mapping to attach to the exception. None","title":"__init__()"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.ImproperlyConfiguredException","text":"Bases: HTTPException , ValueError Application has improper configuration.","title":"ImproperlyConfiguredException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.InternalServerException","text":"Bases: HTTPException Server encountered an unexpected condition that prevented it from fulfilling the request.","title":"InternalServerException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.InternalServerException.status_code","text":"status_code = HTTP_500_INTERNAL_SERVER_ERROR","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.MethodNotAllowedException","text":"Bases: HTTPException Server knows the request method, but the target resource doesn't support this method.","title":"MethodNotAllowedException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.MethodNotAllowedException.status_code","text":"status_code = HTTP_405_METHOD_NOT_ALLOWED","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.NotAuthorizedException","text":"Bases: HTTPException Request lacks valid authentication credentials for the requested resource.","title":"NotAuthorizedException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.NotAuthorizedException.status_code","text":"status_code = HTTP_401_UNAUTHORIZED","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.NoRouteMatchFoundException","text":"Bases: InternalServerException A route with the given name could not be found.","title":"NoRouteMatchFoundException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.NotFoundException","text":"Bases: HTTPException , ValueError Cannot find the requested resource.","title":"NotFoundException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.NotFoundException.status_code","text":"status_code = HTTP_404_NOT_FOUND","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.PermissionDeniedException","text":"Bases: HTTPException Request understood, but not authorized.","title":"PermissionDeniedException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.PermissionDeniedException.status_code","text":"status_code = HTTP_403_FORBIDDEN","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.ServiceUnavailableException","text":"Bases: HTTPException Server is not ready to handle the request.","title":"ServiceUnavailableException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.TemplateNotFoundException","text":"Bases: InternalServerException Referenced template could not be found.","title":"TemplateNotFoundException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.TemplateNotFoundException.__init__","text":"__init__ ( * args , template_name ) Initialize TemplateNotFoundException . Parameters: Name Type Description Default *args Any Passed through to super().__init__() - should not include detail . () template_name str Name of template that could not be found. required","title":"__init__()"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.TooManyRequestsException","text":"Bases: HTTPException Request limits have been exceeded.","title":"TooManyRequestsException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.TooManyRequestsException.status_code","text":"status_code = HTTP_429_TOO_MANY_REQUESTS","title":"status_code"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.ValidationException","text":"Bases: HTTPException , ValueError Client error.","title":"ValidationException"},{"location":"reference/exceptions/1-http-exceptions/#starlite.exceptions.http_exceptions.ValidationException.status_code","text":"status_code = HTTP_400_BAD_REQUEST","title":"status_code"},{"location":"reference/exceptions/2-websocket-exceptions/","text":"WebSocket Exceptions starlite.exceptions.WebSocketException Bases: StarLiteException Exception class for websocket related events.","title":"WebSocket Exceptions"},{"location":"reference/exceptions/2-websocket-exceptions/#websocket-exceptions","text":"","title":"WebSocket Exceptions"},{"location":"reference/exceptions/2-websocket-exceptions/#starlite.exceptions.WebSocketException","text":"Bases: StarLiteException Exception class for websocket related events.","title":"WebSocketException"},{"location":"reference/handlers/0-base-handler/","text":"Base Route Handler starlite.handlers.base.BaseRouteHandler Bases: Generic [ T ] Base route handler. Serves as a subclass for all route handlers opt instance-attribute opt : Dict [ str , Any ] = opt or {}","title":"Base Route Handler"},{"location":"reference/handlers/0-base-handler/#base-route-handler","text":"","title":"Base Route Handler"},{"location":"reference/handlers/0-base-handler/#starlite.handlers.base.BaseRouteHandler","text":"Bases: Generic [ T ] Base route handler. Serves as a subclass for all route handlers","title":"BaseRouteHandler"},{"location":"reference/handlers/0-base-handler/#starlite.handlers.base.BaseRouteHandler.opt","text":"opt : Dict [ str , Any ] = opt or {}","title":"opt"},{"location":"reference/handlers/1-http-handlers/","text":"HTTP Route Handler Decorators starlite.handlers.HTTPRouteHandler Bases: BaseRouteHandler [ HTTPRouteHandler ] HTTP Route Decorator. Use this decorator to decorate an HTTP handler with multiple methods. __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , http_method , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize HTTPRouteHandler . Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None http_method Union [ HttpMethod , Method , List [ Union [ HttpMethod , Method ]]] An http method string , a member of the enum HttpMethod or a list of these that correlates to the methods the route handler function should handle. required media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200' for mixed method or 'GET', 'PUT' and 'PATCH', '201' for 'POST' and '204' for 'DELETE'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.route module-attribute starlite . handlers . route = HTTPRouteHandler starlite.handlers.get Bases: HTTPRouteHandler GET Route Decorator. Use this decorator to decorate an HTTP handler for GET requests. __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize get . Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.head Bases: HTTPRouteHandler HEAD Route Decorator. Use this decorator to decorate an HTTP handler for HEAD requests. __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize head . Notes A response to a head request cannot include a body. See: MDN . Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.post Bases: HTTPRouteHandler POST Route Decorator. Use this decorator to decorate an HTTP handler for POST requests. __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize post Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '201' for 'POST'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.put Bases: HTTPRouteHandler PUT Route Decorator. Use this decorator to decorate an HTTP handler for PUT requests. __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize put Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.patch Bases: HTTPRouteHandler PATCH Route Decorator. Use this decorator to decorate an HTTP handler for PATCH requests. __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize patch . Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.delete Bases: HTTPRouteHandler DELETE Route Decorator. Use this decorator to decorate an HTTP handler for DELETE requests. __init__ __init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize delete Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '204'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"HTTP Route Handler Decorators"},{"location":"reference/handlers/1-http-handlers/#http-route-handler-decorators","text":"","title":"HTTP Route Handler Decorators"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.HTTPRouteHandler","text":"Bases: BaseRouteHandler [ HTTPRouteHandler ] HTTP Route Decorator. Use this decorator to decorate an HTTP handler with multiple methods.","title":"HTTPRouteHandler"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.HTTPRouteHandler.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , http_method , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize HTTPRouteHandler . Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None http_method Union [ HttpMethod , Method , List [ Union [ HttpMethod , Method ]]] An http method string , a member of the enum HttpMethod or a list of these that correlates to the methods the route handler function should handle. required media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200' for mixed method or 'GET', 'PUT' and 'PATCH', '201' for 'POST' and '204' for 'DELETE'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.route","text":"starlite . handlers . route = HTTPRouteHandler","title":"route"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.get","text":"Bases: HTTPRouteHandler GET Route Decorator. Use this decorator to decorate an HTTP handler for GET requests.","title":"get"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.get.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize get . Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.head","text":"Bases: HTTPRouteHandler HEAD Route Decorator. Use this decorator to decorate an HTTP handler for HEAD requests.","title":"head"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.head.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize head . Notes A response to a head request cannot include a body. See: MDN . Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.post","text":"Bases: HTTPRouteHandler POST Route Decorator. Use this decorator to decorate an HTTP handler for POST requests.","title":"post"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.post.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize post Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '201' for 'POST'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.put","text":"Bases: HTTPRouteHandler PUT Route Decorator. Use this decorator to decorate an HTTP handler for PUT requests.","title":"put"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.put.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize put Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.patch","text":"Bases: HTTPRouteHandler PATCH Route Decorator. Use this decorator to decorate an HTTP handler for PATCH requests.","title":"patch"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.patch.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize patch . Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '200'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.delete","text":"Bases: HTTPRouteHandler DELETE Route Decorator. Use this decorator to decorate an HTTP handler for DELETE requests.","title":"delete"},{"location":"reference/handlers/1-http-handlers/#starlite.handlers.http.delete.__init__","text":"__init__ ( path = None , * , after_request = None , after_response = None , background = None , before_request = None , cache = False , cache_control = None , cache_key_builder = None , dependencies = None , etag = None , exception_handlers = None , guards = None , media_type = None , middleware = None , name = None , opt = None , response_class = None , response_cookies = None , response_headers = None , status_code = None , sync_to_thread = False , content_encoding = None , content_media_type = None , deprecated = False , description = None , include_in_schema = True , operation_id = None , raises = None , response_description = None , responses = None , security = None , summary = None , tags = None , ** kwargs ) Initialize delete Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None after_request Optional [ AfterRequestHookHandler ] A sync or async function executed before a Request is passed to any route handler. If this function returns a value, the request will not reach the route handler, and instead this value will be used. None after_response Optional [ AfterResponseHookHandler ] A sync or async function called after the response has been awaited. It receives the Request object and should not return any values. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None before_request Optional [ BeforeRequestHookHandler ] A sync or async function called immediately before calling the route handler. Receives the starlite.connection.Request instance and any non- None return value is used for the response, bypassing the route handler. None cache Union [ bool , int ] Enables response caching if configured on the application level. Valid values are 'true' or a number of seconds (e.g. '120') to cache the response. False cache_control Optional [ CacheControlHeader ] A cache-control header of type CacheControlHeader that will be added to the response. None cache_key_builder Optional [ CacheKeyBuilder ] A cache-key builder function . Allows for customization of the cache key if caching is configured on the application level. None dependencies Optional [ Dict [ str , Provide ]] A string keyed dictionary of dependency Provider instances. None etag Optional [ ETag ] An etag header of type ETag that will be added to the response. None exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None media_type Optional [ Union [ MediaType , str ]] A member of the MediaType enum or a string with a valid IANA Media-Type. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None response_class Optional [ ResponseType ] A custom subclass of [starlite.response.Response] to be used as route handler's default response. None response_cookies Optional [ ResponseCookies ] A list of [Cookie](starlite.datastructures.Cookie] instances. None response_headers Optional [ ResponseHeadersMap ] A string keyed dictionary mapping ResponseHeader instances. None responses Optional [ Dict [ int , ResponseSpec ]] A dictionary of additional status codes and a description of their expected content. This information will be included in the OpenAPI schema None status_code Optional [ int ] An http status code for the response. Defaults to '204'. None sync_to_thread bool A boolean dictating whether the handler function will be executed in a worker thread or the main event loop. This has an effect only for sync handler functions. See using sync handler functions. False content_encoding Optional [ str ] A string describing the encoding of the content, e.g. \"base64\". None content_media_type Optional [ str ] A string designating the media-type of the content, e.g. \"image/png\". None deprecated bool A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. False description Optional [ str ] Text used for the route's schema description section. None include_in_schema bool A boolean flag dictating whether the route handler should be documented in the OpenAPI schema. True operation_id Optional [ str ] An identifier used for the route's schema operationId. Defaults to the name of the wrapped function. None raises Optional [ List [ Type [ HTTPException ]]] A list of exception classes extending from starlite.HttpException that is used for the OpenAPI documentation. This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved. None response_description Optional [ str ] Text used for the route's response schema description section. None security Optional [ List [ SecurityRequirement ]] A list of dictionaries that contain information about which security scheme can be used on the endpoint. None summary Optional [ str ] Text used for the route's schema summary section. None tags Optional [ List [ str ]] A list of string tags that will be appended to the OpenAPI schema. None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/2-websocket-handlers/","text":"WebSocket Route Handler Decorators starlite.handlers.WebsocketRouteHandler Bases: BaseRouteHandler [ WebsocketRouteHandler ] Websocket route handler decorator. Use this decorator to decorate websocket handler functions. __init__ __init__ ( path = None , * , dependencies = None , exception_handlers = None , guards = None , middleware = None , name = None , opt = None , ** kwargs ) Initialize WebsocketRouteHandler Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None dependencies Optional [ Dependencies ] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ Dict [ Union [ int , Type [ Exception ]], ExceptionHandler ]] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.websocket","title":"WebSocket Route Handler Decorators"},{"location":"reference/handlers/2-websocket-handlers/#websocket-route-handler-decorators","text":"","title":"WebSocket Route Handler Decorators"},{"location":"reference/handlers/2-websocket-handlers/#starlite.handlers.WebsocketRouteHandler","text":"Bases: BaseRouteHandler [ WebsocketRouteHandler ] Websocket route handler decorator. Use this decorator to decorate websocket handler functions.","title":"WebsocketRouteHandler"},{"location":"reference/handlers/2-websocket-handlers/#starlite.handlers.websocket.WebsocketRouteHandler.__init__","text":"__init__ ( path = None , * , dependencies = None , exception_handlers = None , guards = None , middleware = None , name = None , opt = None , ** kwargs ) Initialize WebsocketRouteHandler Parameters: Name Type Description Default path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None dependencies Optional [ Dependencies ] A string keyed dictionary of dependency Provider instances. None exception_handlers Optional [ Dict [ Union [ int , Type [ Exception ]], ExceptionHandler ]] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None middleware Optional [ List [ Middleware ]] A list of Middleware . None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string keyed dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/2-websocket-handlers/#starlite.handlers.websocket","text":"","title":"websocket"},{"location":"reference/handlers/3-asgi-handlers/","text":"ASGI Route Handler Decorators starlite.handlers.ASGIRouteHandler Bases: BaseRouteHandler [ ASGIRouteHandler ] ASGI Route Handler decorator. Use this decorator to decorate ASGI applications. __init__ __init__ ( path = None , * , exception_handlers = None , guards = None , name = None , opt = None , is_mount = False , is_static = False , ** kwargs ) Initialize ASGIRouteHandler . Parameters: Name Type Description Default exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None is_mount bool A boolean dictating whether the handler's paths should be regarded as mount paths. Mount path accept any arbitrary paths that begin with the defined prefixed path. For example, a mount with the path /some-path/ will accept requests for /some-path/ and any sub path under this, e.g. /some-path/sub-path/ etc. False is_static bool A boolean dictating whether the handler's paths should be regarded as static paths. Static paths are used to deliver static files. False **kwargs Any Any additional kwarg - will be set in the opt dictionary. {} starlite.handlers.asgi","title":"ASGI Route Handler Decorators"},{"location":"reference/handlers/3-asgi-handlers/#asgi-route-handler-decorators","text":"","title":"ASGI Route Handler Decorators"},{"location":"reference/handlers/3-asgi-handlers/#starlite.handlers.ASGIRouteHandler","text":"Bases: BaseRouteHandler [ ASGIRouteHandler ] ASGI Route Handler decorator. Use this decorator to decorate ASGI applications.","title":"ASGIRouteHandler"},{"location":"reference/handlers/3-asgi-handlers/#starlite.handlers.asgi.ASGIRouteHandler.__init__","text":"__init__ ( path = None , * , exception_handlers = None , guards = None , name = None , opt = None , is_mount = False , is_static = False , ** kwargs ) Initialize ASGIRouteHandler . Parameters: Name Type Description Default exception_handlers Optional [ ExceptionHandlersMap ] A dictionary that maps handler functions to status codes and/or exception types. None guards Optional [ List [ Guard ]] A list of Guard callables. None name Optional [ str ] A string identifying the route handler. None opt Optional [ Dict [ str , Any ]] A string key dictionary of arbitrary values that can be accessed in Guards or wherever you have access to Request or ASGI Scope . None path Union [ Optional [ str ], Optional [ List [ str ]]] A path fragment for the route handler function or a list of path fragments. If not given defaults to '/' None is_mount bool A boolean dictating whether the handler's paths should be regarded as mount paths. Mount path accept any arbitrary paths that begin with the defined prefixed path. For example, a mount with the path /some-path/ will accept requests for /some-path/ and any sub path under this, e.g. /some-path/sub-path/ etc. False is_static bool A boolean dictating whether the handler's paths should be regarded as static paths. Static paths are used to deliver static files. False **kwargs Any Any additional kwarg - will be set in the opt dictionary. {}","title":"__init__()"},{"location":"reference/handlers/3-asgi-handlers/#starlite.handlers.asgi","text":"","title":"asgi"},{"location":"reference/middleware/0-base/","text":"Middleware Base starlite.middleware.MiddlewareProtocol Bases: Protocol Abstract middleware protocol. __call__ async __call__ ( scope , receive , send ) Execute the ASGI middleware. Called by the previous middleware in the stack if a response is not awaited prior. Upon completion, middleware should call the next ASGI handler and await it - or await a response created in its closure. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. required send Send The ASGI send function. required Returns: Type Description None None starlite.middleware.DefineMiddleware Container enabling passing args and *kwargs to Middleware class constructors and factory functions. __init__ __init__ ( middleware , * args , ** kwargs ) Initialize DefineMiddleware . Parameters: Name Type Description Default middleware Callable [..., ASGIApp ] A callable that returns an ASGIApp. required *args Any Positional arguments to pass to the callable. () **kwargs Any Key word arguments to pass to the callable. {} Notes The callable will be passed a kwarg app , which is the next ASGI app to call in the middleware stack. It therefore must define such a kwarg. starlite.middleware.AbstractMiddleware Abstract middleware providing base functionality common to all middlewares, for dynamically engaging/bypassing the middleware based on paths, opt -keys and scope types. When implementing new middleware, this class should be used as a base. __init__ __init__ ( app , exclude = None , exclude_opt_key = None , scopes = None ) Initialize the middleware. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to match against a request's path. If a match is found, the middleware will be skipped. . None exclude_opt_key Optional [ str ] An identifier that is set in the route handler 'opt' key which allows skipping the middleware. None scopes Optional [ Scopes ] ASGI scope types, should be a set including either or both 'ScopeType.HTTP' and 'ScopeType.WEBSOCKET'. None","title":"Middleware Base"},{"location":"reference/middleware/0-base/#middleware-base","text":"","title":"Middleware Base"},{"location":"reference/middleware/0-base/#starlite.middleware.MiddlewareProtocol","text":"Bases: Protocol Abstract middleware protocol.","title":"MiddlewareProtocol"},{"location":"reference/middleware/0-base/#starlite.middleware.base.MiddlewareProtocol.__call__","text":"__call__ ( scope , receive , send ) Execute the ASGI middleware. Called by the previous middleware in the stack if a response is not awaited prior. Upon completion, middleware should call the next ASGI handler and await it - or await a response created in its closure. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. required send Send The ASGI send function. required Returns: Type Description None None","title":"__call__()"},{"location":"reference/middleware/0-base/#starlite.middleware.DefineMiddleware","text":"Container enabling passing args and *kwargs to Middleware class constructors and factory functions.","title":"DefineMiddleware"},{"location":"reference/middleware/0-base/#starlite.middleware.base.DefineMiddleware.__init__","text":"__init__ ( middleware , * args , ** kwargs ) Initialize DefineMiddleware . Parameters: Name Type Description Default middleware Callable [..., ASGIApp ] A callable that returns an ASGIApp. required *args Any Positional arguments to pass to the callable. () **kwargs Any Key word arguments to pass to the callable. {} Notes The callable will be passed a kwarg app , which is the next ASGI app to call in the middleware stack. It therefore must define such a kwarg.","title":"__init__()"},{"location":"reference/middleware/0-base/#starlite.middleware.AbstractMiddleware","text":"Abstract middleware providing base functionality common to all middlewares, for dynamically engaging/bypassing the middleware based on paths, opt -keys and scope types. When implementing new middleware, this class should be used as a base.","title":"AbstractMiddleware"},{"location":"reference/middleware/0-base/#starlite.middleware.base.AbstractMiddleware.__init__","text":"__init__ ( app , exclude = None , exclude_opt_key = None , scopes = None ) Initialize the middleware. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to match against a request's path. If a match is found, the middleware will be skipped. . None exclude_opt_key Optional [ str ] An identifier that is set in the route handler 'opt' key which allows skipping the middleware. None scopes Optional [ Scopes ] ASGI scope types, should be a set including either or both 'ScopeType.HTTP' and 'ScopeType.WEBSOCKET'. None","title":"__init__()"},{"location":"reference/middleware/1-authentication-middleware/","text":"Authentication Middleware starlite.middleware.AuthenticationResult Bases: BaseModel Pydantic model for authentication data. user class-attribute user : Any The user model, this can be any value corresponding to a user of the API. auth class-attribute auth : Any = None The auth value, this can for example be a JWT token. starlite.middleware.AbstractAuthenticationMiddleware Bases: ABC Abstract AuthenticationMiddleware that allows users to create their own AuthenticationMiddleware by extending it and overriding the 'authenticate_request' method. scopes instance-attribute scopes = scopes or { ScopeType . HTTP , ScopeType . WEBSOCKET } __init__ __init__ ( app , exclude = None , exclude_from_auth_key = 'exclude_from_auth' , scopes = None ) Initialize AbstractAuthenticationMiddleware . Parameters: Name Type Description Default app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip in the authentication middleware. None exclude_from_auth_key str An identifier to use on routes to disable authentication for a particular route. 'exclude_from_auth' scopes Optional [ Scopes ] ASGI scopes processed by the authentication middleware. None authenticate_request async abstractmethod authenticate_request ( connection ) Receive the http connection and return an AuthenticationResult . Notes This method must be overridden by subclasses. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance. required Raises: Type Description NotAuthorizedException | PermissionDeniedException if authentication fails. Returns: Type Description AuthenticationResult An instance of AuthenticationResult .","title":"Authentication Middleware"},{"location":"reference/middleware/1-authentication-middleware/#authentication-middleware","text":"","title":"Authentication Middleware"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.AuthenticationResult","text":"Bases: BaseModel Pydantic model for authentication data.","title":"AuthenticationResult"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AuthenticationResult.user","text":"user : Any The user model, this can be any value corresponding to a user of the API.","title":"user"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AuthenticationResult.auth","text":"auth : Any = None The auth value, this can for example be a JWT token.","title":"auth"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.AbstractAuthenticationMiddleware","text":"Bases: ABC Abstract AuthenticationMiddleware that allows users to create their own AuthenticationMiddleware by extending it and overriding the 'authenticate_request' method.","title":"AbstractAuthenticationMiddleware"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AbstractAuthenticationMiddleware.scopes","text":"scopes = scopes or { ScopeType . HTTP , ScopeType . WEBSOCKET }","title":"scopes"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AbstractAuthenticationMiddleware.__init__","text":"__init__ ( app , exclude = None , exclude_from_auth_key = 'exclude_from_auth' , scopes = None ) Initialize AbstractAuthenticationMiddleware . Parameters: Name Type Description Default app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip in the authentication middleware. None exclude_from_auth_key str An identifier to use on routes to disable authentication for a particular route. 'exclude_from_auth' scopes Optional [ Scopes ] ASGI scopes processed by the authentication middleware. None","title":"__init__()"},{"location":"reference/middleware/1-authentication-middleware/#starlite.middleware.authentication.AbstractAuthenticationMiddleware.authenticate_request","text":"authenticate_request ( connection ) Receive the http connection and return an AuthenticationResult . Notes This method must be overridden by subclasses. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance. required Raises: Type Description NotAuthorizedException | PermissionDeniedException if authentication fails. Returns: Type Description AuthenticationResult An instance of AuthenticationResult .","title":"authenticate_request()"},{"location":"reference/middleware/2-logging-middleware/","text":"Logging Middleware starlite.middleware.logging.LoggingMiddlewareConfig Bases: BaseModel Configuration for LoggingMiddleware exclude class-attribute exclude : Optional [ Union [ str , List [ str ]]] = None List of paths to exclude from logging. exclude_opt_key class-attribute exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable logging for a particular route. include_compressed_body class-attribute include_compressed_body : bool = False Include body of compressed response in middleware. If \"body\" not set in. response_log_fields this config value is ignored. logger_name class-attribute logger_name : str = 'starlite' Name of the logger to retrieve using app.get_logger(\"<name>\") . middleware property middleware : DefineMiddleware Use this property to insert the config into a middleware list on one of the application layers. Examples: from starlite import Starlite , Request , LoggingConfig , get from starlite.middleware.logging import LoggingMiddlewareConfig logging_config = LoggingConfig () logging_middleware_config = LoggingMiddlewareConfig () @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], logging_config = logging_config , middleware = [ logging_middleware_config . middleware ], ) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value. middleware_class class-attribute middleware_class : Type [ LoggingMiddleware ] = LoggingMiddleware Middleware class to use. Should be a subclass of [starlite.middleware.LoggingMiddleware]. request_cookies_to_obfuscate class-attribute request_cookies_to_obfuscate : Set [ str ] = { 'session' } Request cookie keys to obfuscate. Obfuscated values are replaced with ' * '. request_headers_to_obfuscate class-attribute request_headers_to_obfuscate : Set [ str ] = { 'Authorization' , 'X-API-KEY' } Request header keys to obfuscate. Obfuscated values are replaced with ' * '. request_log_fields class-attribute request_log_fields : Iterable [ RequestExtractorField ] = ( \"path\" , \"method\" , \"content_type\" , \"headers\" , \"cookies\" , \"query\" , \"path_params\" , \"body\" , ) Fields to extract and log from the request. Notes The order of fields in the iterable determines the order of the log message logged out. Thus, re-arranging the log-message is as simple as changing the iterable. To turn off logging of requests, use and empty iterable. request_log_message class-attribute request_log_message : str = 'HTTP Request' Log message to prepend when logging a request. response_cookies_to_obfuscate class-attribute response_cookies_to_obfuscate : Set [ str ] = { 'session' } Response cookie keys to obfuscate. Obfuscated values are replaced with ' * '. response_headers_to_obfuscate class-attribute response_headers_to_obfuscate : Set [ str ] = { 'Authorization' , 'X-API-KEY' } Response header keys to obfuscate. Obfuscated values are replaced with ' * '. response_log_fields class-attribute response_log_fields : Iterable [ ResponseExtractorField ] = ( \"status_code\" , \"cookies\" , \"headers\" , \"body\" , ) Fields to extract and log from the response. The order of fields in the iterable determines the order of the log message logged out. Notes The order of fields in the iterable determines the order of the log message logged out. Thus, re-arranging the log-message is as simple as changing the iterable. To turn off logging of responses, use and empty iterable. response_log_message class-attribute response_log_message : str = 'HTTP Response' Log message to prepend when logging a response. starlite.middleware.logging.LoggingMiddleware Bases: AbstractMiddleware Logging middleware. __init__ __init__ ( app , config ) Initialize LoggingMiddleware . Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config LoggingMiddlewareConfig An instance of LoggingMiddlewareConfig. required create_send_wrapper create_send_wrapper ( scope , send ) Create a send wrapper, which handles logging response data. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required send Send The ASGI send function. required Returns: Type Description Send An ASGI send function. extract_request_data async extract_request_data ( request ) Create a dictionary of values for the message. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Dict [ str , Any ] An dict. extract_response_data extract_response_data ( scope ) Extract data from the response. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description Dict [ str , Any ] An dict. log_message log_message ( values ) Log a message. Parameters: Name Type Description Default values Dict [ str , Any ] Extract values to log. required Returns: Type Description None None log_request async log_request ( scope , receive ) Extract request data and log the message. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive ASGI receive callable required Returns: Type Description None None log_response log_response ( scope ) Extract the response data and log the message. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description None None","title":"Logging Middleware"},{"location":"reference/middleware/2-logging-middleware/#logging-middleware","text":"","title":"Logging Middleware"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig","text":"Bases: BaseModel Configuration for LoggingMiddleware","title":"LoggingMiddlewareConfig"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.exclude","text":"exclude : Optional [ Union [ str , List [ str ]]] = None List of paths to exclude from logging.","title":"exclude"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.exclude_opt_key","text":"exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable logging for a particular route.","title":"exclude_opt_key"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.include_compressed_body","text":"include_compressed_body : bool = False Include body of compressed response in middleware. If \"body\" not set in. response_log_fields this config value is ignored.","title":"include_compressed_body"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.logger_name","text":"logger_name : str = 'starlite' Name of the logger to retrieve using app.get_logger(\"<name>\") .","title":"logger_name"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.middleware","text":"middleware : DefineMiddleware Use this property to insert the config into a middleware list on one of the application layers. Examples: from starlite import Starlite , Request , LoggingConfig , get from starlite.middleware.logging import LoggingMiddlewareConfig logging_config = LoggingConfig () logging_middleware_config = LoggingMiddlewareConfig () @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], logging_config = logging_config , middleware = [ logging_middleware_config . middleware ], ) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value.","title":"middleware"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.middleware_class","text":"middleware_class : Type [ LoggingMiddleware ] = LoggingMiddleware Middleware class to use. Should be a subclass of [starlite.middleware.LoggingMiddleware].","title":"middleware_class"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_cookies_to_obfuscate","text":"request_cookies_to_obfuscate : Set [ str ] = { 'session' } Request cookie keys to obfuscate. Obfuscated values are replaced with ' * '.","title":"request_cookies_to_obfuscate"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_headers_to_obfuscate","text":"request_headers_to_obfuscate : Set [ str ] = { 'Authorization' , 'X-API-KEY' } Request header keys to obfuscate. Obfuscated values are replaced with ' * '.","title":"request_headers_to_obfuscate"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_log_fields","text":"request_log_fields : Iterable [ RequestExtractorField ] = ( \"path\" , \"method\" , \"content_type\" , \"headers\" , \"cookies\" , \"query\" , \"path_params\" , \"body\" , ) Fields to extract and log from the request. Notes The order of fields in the iterable determines the order of the log message logged out. Thus, re-arranging the log-message is as simple as changing the iterable. To turn off logging of requests, use and empty iterable.","title":"request_log_fields"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.request_log_message","text":"request_log_message : str = 'HTTP Request' Log message to prepend when logging a request.","title":"request_log_message"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_cookies_to_obfuscate","text":"response_cookies_to_obfuscate : Set [ str ] = { 'session' } Response cookie keys to obfuscate. Obfuscated values are replaced with ' * '.","title":"response_cookies_to_obfuscate"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_headers_to_obfuscate","text":"response_headers_to_obfuscate : Set [ str ] = { 'Authorization' , 'X-API-KEY' } Response header keys to obfuscate. Obfuscated values are replaced with ' * '.","title":"response_headers_to_obfuscate"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_log_fields","text":"response_log_fields : Iterable [ ResponseExtractorField ] = ( \"status_code\" , \"cookies\" , \"headers\" , \"body\" , ) Fields to extract and log from the response. The order of fields in the iterable determines the order of the log message logged out. Notes The order of fields in the iterable determines the order of the log message logged out. Thus, re-arranging the log-message is as simple as changing the iterable. To turn off logging of responses, use and empty iterable.","title":"response_log_fields"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddlewareConfig.response_log_message","text":"response_log_message : str = 'HTTP Response' Log message to prepend when logging a response.","title":"response_log_message"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware","text":"Bases: AbstractMiddleware Logging middleware.","title":"LoggingMiddleware"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.__init__","text":"__init__ ( app , config ) Initialize LoggingMiddleware . Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config LoggingMiddlewareConfig An instance of LoggingMiddlewareConfig. required","title":"__init__()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.create_send_wrapper","text":"create_send_wrapper ( scope , send ) Create a send wrapper, which handles logging response data. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required send Send The ASGI send function. required Returns: Type Description Send An ASGI send function.","title":"create_send_wrapper()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.extract_request_data","text":"extract_request_data ( request ) Create a dictionary of values for the message. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Dict [ str , Any ] An dict.","title":"extract_request_data()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.extract_response_data","text":"extract_response_data ( scope ) Extract data from the response. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description Dict [ str , Any ] An dict.","title":"extract_response_data()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.log_message","text":"log_message ( values ) Log a message. Parameters: Name Type Description Default values Dict [ str , Any ] Extract values to log. required Returns: Type Description None None","title":"log_message()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.log_request","text":"log_request ( scope , receive ) Extract request data and log the message. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive ASGI receive callable required Returns: Type Description None None","title":"log_request()"},{"location":"reference/middleware/2-logging-middleware/#starlite.middleware.logging.LoggingMiddleware.log_response","text":"log_response ( scope ) Extract the response data and log the message. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description None None","title":"log_response()"},{"location":"reference/middleware/3-rate-limit-middleware/","text":"Rate-Limit Middleware starlite.middleware.rate_limit.RateLimitConfig Bases: BaseModel Configuration for RateLimitMiddleware cache_key_builder class-attribute cache_key_builder : Optional [ Callable [[ Request ], str ]] = None check_throttle_handler class-attribute check_throttle_handler : Optional [ Callable [[ Request [ Any , Any ]], SyncOrAsyncUnion [ bool ]]] = None Handler callable that receives the request instance, returning a boolean dictating whether or not the request should be checked for rate limiting. exclude class-attribute exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the rate limiting middleware. exclude_opt_key class-attribute exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable rate limiting for a particular route. middleware property middleware : DefineMiddleware Use this property to insert the config into a middleware list on one of the application layers. Examples: from starlite import Starlite , Request , get from starlite.middleware import RateLimitConfig # limit to 10 requests per minute, excluding the schema path throttle_config = RateLimitConfig ( rate_limit = ( \"minute\" , 10 ), exclude = [ \"/schema\" ]) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ throttle_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value. middleware_class class-attribute middleware_class : Type [ RateLimitMiddleware ] = RateLimitMiddleware The middleware class to use. rate_limit class-attribute rate_limit : Tuple [ DurationUnit , int ] A tuple containing a time unit (second, minute, hour, day) and quantity, e.g. (\"day\", 1) or (\"minute\", 5). rate_limit_limit_header_key class-attribute rate_limit_limit_header_key : str = 'RateLimit-Limit' Key to use for the rate limit limit header. rate_limit_policy_header_key class-attribute rate_limit_policy_header_key : str = 'RateLimit-Policy' Key to use for the rate limit policy header. rate_limit_remaining_header_key class-attribute rate_limit_remaining_header_key : str = 'RateLimit-Remaining' Key to use for the rate limit remaining header. rate_limit_reset_header_key class-attribute rate_limit_reset_header_key : str = 'RateLimit-Reset' Key to use for the rate limit reset header. set_rate_limit_headers class-attribute set_rate_limit_headers : bool = True Boolean dictating whether to set the rate limit headers on the response. starlite.middleware.rate_limit.RateLimitMiddleware Bases: AbstractMiddleware Rate-limiting middleware. __init__ __init__ ( app , config ) Initialize RateLimitMiddleware . Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config RateLimitConfig An instance of RateLimitConfig. required cache_key_from_request cache_key_from_request ( request ) Get a cache-key from a Request Parameters: Name Type Description Default request Request[Any, Any] A Request instance. required Returns: Type Description str A cache key. create_response_headers create_response_headers ( cache_object ) Create ratelimit response headers. Notes see the [IETF RateLimit draft][ https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/ ] Parameters: Name Type Description Default cache_object CacheObject An instance of Cache Object. required Returns: Type Description Dict [ str , str ] A dict of http headers. retrieve_cached_history async retrieve_cached_history ( key ) Retrieve a list of time stamps for the given duration unit. Parameters: Name Type Description Default key str Cache key. required Returns: Type Description CacheObject An instance of CacheObject. set_cached_history async set_cached_history ( key , cache_object ) Store history extended with the current timestamp in cache. Parameters: Name Type Description Default key str Cache key. required cache_object CacheObject An instance of CacheObject. required Returns: Type Description None None should_check_request async should_check_request ( request ) Return a boolean indicating if a request should be checked for rate limiting. Parameters: Name Type Description Default request Request[Any, Any] A Request instance. required Returns: Type Description bool Boolean dictating whether the request should be checked for rate-limiting.","title":"Rate-Limit Middleware"},{"location":"reference/middleware/3-rate-limit-middleware/#rate-limit-middleware","text":"","title":"Rate-Limit Middleware"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig","text":"Bases: BaseModel Configuration for RateLimitMiddleware","title":"RateLimitConfig"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.cache_key_builder","text":"cache_key_builder : Optional [ Callable [[ Request ], str ]] = None","title":"cache_key_builder"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.check_throttle_handler","text":"check_throttle_handler : Optional [ Callable [[ Request [ Any , Any ]], SyncOrAsyncUnion [ bool ]]] = None Handler callable that receives the request instance, returning a boolean dictating whether or not the request should be checked for rate limiting.","title":"check_throttle_handler"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.exclude","text":"exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the rate limiting middleware.","title":"exclude"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.exclude_opt_key","text":"exclude_opt_key : Optional [ str ] = None An identifier to use on routes to disable rate limiting for a particular route.","title":"exclude_opt_key"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.middleware","text":"middleware : DefineMiddleware Use this property to insert the config into a middleware list on one of the application layers. Examples: from starlite import Starlite , Request , get from starlite.middleware import RateLimitConfig # limit to 10 requests per minute, excluding the schema path throttle_config = RateLimitConfig ( rate_limit = ( \"minute\" , 10 ), exclude = [ \"/schema\" ]) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ throttle_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value.","title":"middleware"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.middleware_class","text":"middleware_class : Type [ RateLimitMiddleware ] = RateLimitMiddleware The middleware class to use.","title":"middleware_class"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit","text":"rate_limit : Tuple [ DurationUnit , int ] A tuple containing a time unit (second, minute, hour, day) and quantity, e.g. (\"day\", 1) or (\"minute\", 5).","title":"rate_limit"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_limit_header_key","text":"rate_limit_limit_header_key : str = 'RateLimit-Limit' Key to use for the rate limit limit header.","title":"rate_limit_limit_header_key"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_policy_header_key","text":"rate_limit_policy_header_key : str = 'RateLimit-Policy' Key to use for the rate limit policy header.","title":"rate_limit_policy_header_key"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_remaining_header_key","text":"rate_limit_remaining_header_key : str = 'RateLimit-Remaining' Key to use for the rate limit remaining header.","title":"rate_limit_remaining_header_key"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.rate_limit_reset_header_key","text":"rate_limit_reset_header_key : str = 'RateLimit-Reset' Key to use for the rate limit reset header.","title":"rate_limit_reset_header_key"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitConfig.set_rate_limit_headers","text":"set_rate_limit_headers : bool = True Boolean dictating whether to set the rate limit headers on the response.","title":"set_rate_limit_headers"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware","text":"Bases: AbstractMiddleware Rate-limiting middleware.","title":"RateLimitMiddleware"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.__init__","text":"__init__ ( app , config ) Initialize RateLimitMiddleware . Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config RateLimitConfig An instance of RateLimitConfig. required","title":"__init__()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.cache_key_from_request","text":"cache_key_from_request ( request ) Get a cache-key from a Request Parameters: Name Type Description Default request Request[Any, Any] A Request instance. required Returns: Type Description str A cache key.","title":"cache_key_from_request()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.create_response_headers","text":"create_response_headers ( cache_object ) Create ratelimit response headers. Notes see the [IETF RateLimit draft][ https://datatracker.ietf.org/doc/draft-ietf-httpapi-ratelimit-headers/ ] Parameters: Name Type Description Default cache_object CacheObject An instance of Cache Object. required Returns: Type Description Dict [ str , str ] A dict of http headers.","title":"create_response_headers()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.retrieve_cached_history","text":"retrieve_cached_history ( key ) Retrieve a list of time stamps for the given duration unit. Parameters: Name Type Description Default key str Cache key. required Returns: Type Description CacheObject An instance of CacheObject.","title":"retrieve_cached_history()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.set_cached_history","text":"set_cached_history ( key , cache_object ) Store history extended with the current timestamp in cache. Parameters: Name Type Description Default key str Cache key. required cache_object CacheObject An instance of CacheObject. required Returns: Type Description None None","title":"set_cached_history()"},{"location":"reference/middleware/3-rate-limit-middleware/#starlite.middleware.rate_limit.RateLimitMiddleware.should_check_request","text":"should_check_request ( request ) Return a boolean indicating if a request should be checked for rate limiting. Parameters: Name Type Description Default request Request[Any, Any] A Request instance. required Returns: Type Description bool Boolean dictating whether the request should be checked for rate-limiting.","title":"should_check_request()"},{"location":"reference/middleware/4-compression-middleware/","text":"Compression Middleware starlite.middleware.CompressionMiddleware Bases: AbstractMiddleware Compression Middleware Wrapper. This is a wrapper allowing for generic compression configuration / handler middleware __init__ __init__ ( app , config ) Initialize CompressionMiddleware Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CompressionConfig An instance of CompressionConfig. required","title":"Compression Middleware"},{"location":"reference/middleware/4-compression-middleware/#compression-middleware","text":"","title":"Compression Middleware"},{"location":"reference/middleware/4-compression-middleware/#starlite.middleware.CompressionMiddleware","text":"Bases: AbstractMiddleware Compression Middleware Wrapper. This is a wrapper allowing for generic compression configuration / handler middleware","title":"CompressionMiddleware"},{"location":"reference/middleware/4-compression-middleware/#starlite.middleware.compression.CompressionMiddleware.__init__","text":"__init__ ( app , config ) Initialize CompressionMiddleware Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CompressionConfig An instance of CompressionConfig. required","title":"__init__()"},{"location":"reference/middleware/5-csrf-middleware/","text":"CSRF Middleware starlite.middleware.CSRFMiddleware Bases: MiddlewareProtocol CSRF Middleware class. This Middleware protects against attacks by setting a CSRF cookie with a token and verifying it in request headers. __init__ __init__ ( app , config ) Initialize CSRFMiddleware . Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CSRFConfig The CSRFConfig instance. required","title":"CSRF Middleware"},{"location":"reference/middleware/5-csrf-middleware/#csrf-middleware","text":"","title":"CSRF Middleware"},{"location":"reference/middleware/5-csrf-middleware/#starlite.middleware.CSRFMiddleware","text":"Bases: MiddlewareProtocol CSRF Middleware class. This Middleware protects against attacks by setting a CSRF cookie with a token and verifying it in request headers.","title":"CSRFMiddleware"},{"location":"reference/middleware/5-csrf-middleware/#starlite.middleware.csrf.CSRFMiddleware.__init__","text":"__init__ ( app , config ) Initialize CSRFMiddleware . Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CSRFConfig The CSRFConfig instance. required","title":"__init__()"},{"location":"reference/middleware/6-exceptions-middleware/","text":"Exceptions Middleware starlite.middleware.ExceptionHandlerMiddleware Middleware used to wrap an ASGIApp inside a try catch block and handle any exceptions raised. This used in multiple layers of Starlite. __init__ __init__ ( app , debug , exception_handlers ) Initialize ExceptionHandlerMiddleware . Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required debug bool Whether 'debug' mode is enabled required exception_handlers ExceptionHandlersMap A dictionary mapping status codes and/or exception types to handler functions. required default_http_exception_handler default_http_exception_handler ( request , exc ) Handle HTTPException s and its subclasses.","title":"Exceptions Middleware"},{"location":"reference/middleware/6-exceptions-middleware/#exceptions-middleware","text":"","title":"Exceptions Middleware"},{"location":"reference/middleware/6-exceptions-middleware/#starlite.middleware.ExceptionHandlerMiddleware","text":"Middleware used to wrap an ASGIApp inside a try catch block and handle any exceptions raised. This used in multiple layers of Starlite.","title":"ExceptionHandlerMiddleware"},{"location":"reference/middleware/6-exceptions-middleware/#starlite.middleware.exceptions.middleware.ExceptionHandlerMiddleware.__init__","text":"__init__ ( app , debug , exception_handlers ) Initialize ExceptionHandlerMiddleware . Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required debug bool Whether 'debug' mode is enabled required exception_handlers ExceptionHandlersMap A dictionary mapping status codes and/or exception types to handler functions. required","title":"__init__()"},{"location":"reference/middleware/6-exceptions-middleware/#starlite.middleware.exceptions.middleware.ExceptionHandlerMiddleware.default_http_exception_handler","text":"default_http_exception_handler ( request , exc ) Handle HTTPException s and its subclasses.","title":"default_http_exception_handler()"},{"location":"reference/middleware/7-cors-middleware/","text":"CORS Middleware starlite.middleware.cors.CORSMiddleware Bases: AbstractMiddleware CORS Middleware. __init__ __init__ ( app , config ) Middleware that adds CORS validation to the application. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CORSConfig An instance of CORSConfig required","title":"CORS Middleware"},{"location":"reference/middleware/7-cors-middleware/#cors-middleware","text":"","title":"CORS Middleware"},{"location":"reference/middleware/7-cors-middleware/#starlite.middleware.cors.CORSMiddleware","text":"Bases: AbstractMiddleware CORS Middleware.","title":"CORSMiddleware"},{"location":"reference/middleware/7-cors-middleware/#starlite.middleware.cors.CORSMiddleware.__init__","text":"__init__ ( app , config ) Middleware that adds CORS validation to the application. Parameters: Name Type Description Default app ASGIApp The 'next' ASGI app to call. required config CORSConfig An instance of CORSConfig required","title":"__init__()"},{"location":"reference/middleware/session-middleware/0-middleware/","text":"Middleware starlite.middleware.session.SessionMiddleware Bases: AbstractMiddleware , Generic [ BaseSessionBackendT ] Starlite session middleware for storing session data. __init__ __init__ ( app , backend ) Initialize SessionMiddleware Parameters: Name Type Description Default app ASGIApp An ASGI application required backend BaseSessionBackendT A BaseSessionBackend instance used to store and retrieve session data required","title":"Middleware"},{"location":"reference/middleware/session-middleware/0-middleware/#middleware","text":"","title":"Middleware"},{"location":"reference/middleware/session-middleware/0-middleware/#starlite.middleware.session.SessionMiddleware","text":"Bases: AbstractMiddleware , Generic [ BaseSessionBackendT ] Starlite session middleware for storing session data.","title":"SessionMiddleware"},{"location":"reference/middleware/session-middleware/0-middleware/#starlite.middleware.session.base.SessionMiddleware.__init__","text":"__init__ ( app , backend ) Initialize SessionMiddleware Parameters: Name Type Description Default app ASGIApp An ASGI application required backend BaseSessionBackendT A BaseSessionBackend instance used to store and retrieve session data required","title":"__init__()"},{"location":"reference/middleware/session-middleware/1-base-backend/","text":"Base backend starlite.middleware.session.base.BaseBackendConfig Bases: BaseModel Configuration for Session middleware backends. key class-attribute key : constr ( min_length = 1 , max_length = 256 ) = 'session' Key to use for the cookie inside the header, e.g. session=<data> where 'session' is the cookie key and is the session data. Notes If a session cookie exceeds 4KB in size it is split. In this case the key will be of the format 'session-{segment number}'. max_age class-attribute max_age : conint ( ge = 1 ) = ONE_DAY_IN_SECONDS * 14 Maximal age of the cookie before its invalidated. scopes class-attribute scopes : Scopes = { ScopeType . HTTP , ScopeType . WEBSOCKET } Scopes for the middleware - options are 'http' and 'websocket' with the default being both path class-attribute path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'. domain class-attribute domain : Optional [ str ] = None Domain for which the cookie is valid. secure class-attribute secure : bool = False Https is required for the cookie. httponly class-attribute httponly : bool = True Forbids javascript to access the cookie via 'Document.cookie'. samesite class-attribute samesite : Literal [ 'lax' , 'strict' , 'none' ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'. middleware property middleware : DefineMiddleware Use this property to insert the config into a middleware list on one of the application layers. Examples: from os import urandom from starlite import Starlite , Request , get from starlite.middleware.session import SessionCookieConfig session_config = SessionCookieConfig ( secret = urandom ( 16 )) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ session_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value. starlite.middleware.session.base.ServerSideSessionConfig Bases: BaseBackendConfig Base configuration for server side backends. session_id_bytes class-attribute session_id_bytes : int = 32 Number of bytes used to generate a random session-ID. starlite.middleware.session.base.BaseSessionBackend Bases: ABC , Generic [ ConfigT ] Abstract session backend defining the interface between a storage mechanism and the application. SessionMiddleware . This serves as the base class for all client- and server-side backends __init__ __init__ ( config ) Initialize BaseSessionBackend Parameters: Name Type Description Default config ConfigT A instance of a subclass of BaseBackendConfig required deserialize_data staticmethod deserialize_data ( data ) Deserialize data into a dictionary for use in the application scope. Parameters: Name Type Description Default data Any Data to be deserialized required Returns: Type Description Dict [ str , Any ] Deserialized data as a dictionary store_in_message async abstractmethod store_in_message ( scope_session , message , connection ) Store the necessary information in the outgoing Message Parameters: Name Type Description Default scope_session ScopeSession Current session to store required message Message Outgoing send-message required connection ASGIConnection Originating ASGIConnection containing the scope required Returns: Type Description None None load_from_connection async abstractmethod load_from_connection ( connection ) Load session data from a connection and return it as a dictionary to be used in the current application scope. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance required Returns: Type Description Dict [ str , Any ] The session data Notes This should not modify the connection's scope. The data returned by this method will be stored in the application scope by the middleware starlite.middleware.session.base.ServerSideBackend Bases: Generic [ ServerConfigT ] , BaseSessionBackend [ ServerConfigT ] Base class for server-side backends. Implements BaseSessionBackend and defines and interface which subclasses can implement to facilitate the storage of session data __init__ __init__ ( config ) Initialize ServerSideBackend Parameters: Name Type Description Default config ServerConfigT A subclass of ServerSideSessionConfig required store_in_message async store_in_message ( scope_session , message , connection ) Store the necessary information in the outgoing Message by setting a cookie containing the session-ID. If the session is empty, a null-cookie will be set. Otherwise, the serialised data will be stored using set , under the current session-id. If no session-ID exists, a new ID will be generated using generate_session_id . Parameters: Name Type Description Default scope_session ScopeSession Current session to store required message Message Outgoing send-message required connection ASGIConnection Originating ASGIConnection containing the scope required Returns: Type Description None None load_from_connection async load_from_connection ( connection ) Load session data from a connection and return it as a dictionary to be used in the current application scope. The session-ID will be gathered from a cookie with the key set in the configuration . If a cookie is found, its value will be used as the session-ID and data associated with this ID will be loaded using get . If no cookie was found or no data was loaded from the store, this will return an empty dictionary. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance required Returns: Type Description Dict [ str , Any ] The current session data get async abstractmethod get ( session_id ) Retrieve data associated with session_id . Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Union [ bytes , str , Dict [ str , Any ], None] The session data, if existing, otherwise None . set async abstractmethod set ( session_id , data ) Store data under the session_id for later retrieval. If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None delete async abstractmethod delete ( session_id ) Delete the data associated with session_id . Fails silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None delete_all async abstractmethod delete_all () Delete all session data stored within this backend. Returns: Type Description None None generate_session_id generate_session_id () Generate a new session-ID, with n=[session_id_bytes][starlite.middle ware.session.base.ServerSideSessionConfig.session_id_bytes] random bytes. Returns: Type Description str A session-ID","title":"Base backend"},{"location":"reference/middleware/session-middleware/1-base-backend/#base-backend","text":"","title":"Base backend"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig","text":"Bases: BaseModel Configuration for Session middleware backends.","title":"BaseBackendConfig"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.key","text":"key : constr ( min_length = 1 , max_length = 256 ) = 'session' Key to use for the cookie inside the header, e.g. session=<data> where 'session' is the cookie key and is the session data. Notes If a session cookie exceeds 4KB in size it is split. In this case the key will be of the format 'session-{segment number}'.","title":"key"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.max_age","text":"max_age : conint ( ge = 1 ) = ONE_DAY_IN_SECONDS * 14 Maximal age of the cookie before its invalidated.","title":"max_age"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.scopes","text":"scopes : Scopes = { ScopeType . HTTP , ScopeType . WEBSOCKET } Scopes for the middleware - options are 'http' and 'websocket' with the default being both","title":"scopes"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.path","text":"path : str = '/' Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'.","title":"path"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.domain","text":"domain : Optional [ str ] = None Domain for which the cookie is valid.","title":"domain"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.secure","text":"secure : bool = False Https is required for the cookie.","title":"secure"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.httponly","text":"httponly : bool = True Forbids javascript to access the cookie via 'Document.cookie'.","title":"httponly"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.samesite","text":"samesite : Literal [ 'lax' , 'strict' , 'none' ] = 'lax' Controls whether or not a cookie is sent with cross-site requests. Defaults to 'lax'.","title":"samesite"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseBackendConfig.middleware","text":"middleware : DefineMiddleware Use this property to insert the config into a middleware list on one of the application layers. Examples: from os import urandom from starlite import Starlite , Request , get from starlite.middleware.session import SessionCookieConfig session_config = SessionCookieConfig ( secret = urandom ( 16 )) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ session_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value.","title":"middleware"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideSessionConfig","text":"Bases: BaseBackendConfig Base configuration for server side backends.","title":"ServerSideSessionConfig"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideSessionConfig.session_id_bytes","text":"session_id_bytes : int = 32 Number of bytes used to generate a random session-ID.","title":"session_id_bytes"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend","text":"Bases: ABC , Generic [ ConfigT ] Abstract session backend defining the interface between a storage mechanism and the application. SessionMiddleware . This serves as the base class for all client- and server-side backends","title":"BaseSessionBackend"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend.__init__","text":"__init__ ( config ) Initialize BaseSessionBackend Parameters: Name Type Description Default config ConfigT A instance of a subclass of BaseBackendConfig required","title":"__init__()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend.deserialize_data","text":"deserialize_data ( data ) Deserialize data into a dictionary for use in the application scope. Parameters: Name Type Description Default data Any Data to be deserialized required Returns: Type Description Dict [ str , Any ] Deserialized data as a dictionary","title":"deserialize_data()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend.store_in_message","text":"store_in_message ( scope_session , message , connection ) Store the necessary information in the outgoing Message Parameters: Name Type Description Default scope_session ScopeSession Current session to store required message Message Outgoing send-message required connection ASGIConnection Originating ASGIConnection containing the scope required Returns: Type Description None None","title":"store_in_message()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.BaseSessionBackend.load_from_connection","text":"load_from_connection ( connection ) Load session data from a connection and return it as a dictionary to be used in the current application scope. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance required Returns: Type Description Dict [ str , Any ] The session data Notes This should not modify the connection's scope. The data returned by this method will be stored in the application scope by the middleware","title":"load_from_connection()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend","text":"Bases: Generic [ ServerConfigT ] , BaseSessionBackend [ ServerConfigT ] Base class for server-side backends. Implements BaseSessionBackend and defines and interface which subclasses can implement to facilitate the storage of session data","title":"ServerSideBackend"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.__init__","text":"__init__ ( config ) Initialize ServerSideBackend Parameters: Name Type Description Default config ServerConfigT A subclass of ServerSideSessionConfig required","title":"__init__()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.store_in_message","text":"store_in_message ( scope_session , message , connection ) Store the necessary information in the outgoing Message by setting a cookie containing the session-ID. If the session is empty, a null-cookie will be set. Otherwise, the serialised data will be stored using set , under the current session-id. If no session-ID exists, a new ID will be generated using generate_session_id . Parameters: Name Type Description Default scope_session ScopeSession Current session to store required message Message Outgoing send-message required connection ASGIConnection Originating ASGIConnection containing the scope required Returns: Type Description None None","title":"store_in_message()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.load_from_connection","text":"load_from_connection ( connection ) Load session data from a connection and return it as a dictionary to be used in the current application scope. The session-ID will be gathered from a cookie with the key set in the configuration . If a cookie is found, its value will be used as the session-ID and data associated with this ID will be loaded using get . If no cookie was found or no data was loaded from the store, this will return an empty dictionary. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance required Returns: Type Description Dict [ str , Any ] The current session data","title":"load_from_connection()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.get","text":"get ( session_id ) Retrieve data associated with session_id . Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Union [ bytes , str , Dict [ str , Any ], None] The session data, if existing, otherwise None .","title":"get()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.set","text":"set ( session_id , data ) Store data under the session_id for later retrieval. If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None","title":"set()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.delete","text":"delete ( session_id ) Delete the data associated with session_id . Fails silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None","title":"delete()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.delete_all","text":"delete_all () Delete all session data stored within this backend. Returns: Type Description None None","title":"delete_all()"},{"location":"reference/middleware/session-middleware/1-base-backend/#starlite.middleware.session.base.ServerSideBackend.generate_session_id","text":"generate_session_id () Generate a new session-ID, with n=[session_id_bytes][starlite.middle ware.session.base.ServerSideSessionConfig.session_id_bytes] random bytes. Returns: Type Description str A session-ID","title":"generate_session_id()"},{"location":"reference/middleware/session-middleware/2-cookie-backend/","text":"Cookie Backend starlite.middleware.session.cookie_backend.CookieBackendConfig Bases: BaseBackendConfig Configuration for [SessionMiddleware] middleware. secret class-attribute secret : SecretBytes A secret key to use for generating an encryption key. Must have a length of 16 (128 bits), 24 (192 bits) or 32 (256 bits) characters. starlite.middleware.session.cookie_backend.CookieBackend Bases: BaseSessionBackend [ CookieBackendConfig ] Cookie backend for SessionMiddleware. __init__ __init__ ( config ) Initialize CookieBackend . Parameters: Name Type Description Default config CookieBackendConfig SessionCookieConfig instance. required dump_data dump_data ( data , scope = None ) Given serializable data, including pydantic models and numpy types, dump it into a bytes string, encrypt, encode and split it into chunks of the desirable size. Parameters: Name Type Description Default data Any Data to serialize, encrypt, encode and chunk. required scope Optional [ Scope ] The ASGI connection scope. None Notes The returned list is composed of a chunks of a single base64 encoded string that is encrypted using AES-CGM. Returns: Type Description List [ bytes ] List of encoded bytes string of a maximum length equal to the 'CHUNK_SIZE' constant. load_data load_data ( data ) Given a list of strings, decodes them into the session object. Parameters: Name Type Description Default data List [ bytes ] A list of strings derived from the request's session cookie(s). required Returns: Type Description Dict [ str , Any ] A deserialized session value. get_cookie_keys get_cookie_keys ( connection ) Return a list of cookie-keys from the connection if they match the session-cookie pattern. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance required Returns: Type Description List [ str ] A list of session-cookie keys store_in_message async store_in_message ( scope_session , message , connection ) Store data from scope_session in Message in the form of cookies. If the contents of scope_session are too large to fit a single cookie, it will be split across several cookies, following the naming scheme of <cookie key>-<n> . If the session is empty or shrinks, cookies will be cleared by setting their value to null Parameters: Name Type Description Default scope_session ScopeSession Current session to store required message Message Outgoing send-message required connection ASGIConnection Originating ASGIConnection containing the scope required Returns: Type Description None None load_from_connection async load_from_connection ( connection ) Load session data from a connection's session-cookies and return it as a dictionary. Parameters: Name Type Description Default connection ASGIConnection Originating ASGIConnection required Returns: Type Description Dict [ str , Any ] The session data","title":"Cookie Backend"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#cookie-backend","text":"","title":"Cookie Backend"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackendConfig","text":"Bases: BaseBackendConfig Configuration for [SessionMiddleware] middleware.","title":"CookieBackendConfig"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackendConfig.secret","text":"secret : SecretBytes A secret key to use for generating an encryption key. Must have a length of 16 (128 bits), 24 (192 bits) or 32 (256 bits) characters.","title":"secret"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend","text":"Bases: BaseSessionBackend [ CookieBackendConfig ] Cookie backend for SessionMiddleware.","title":"CookieBackend"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.__init__","text":"__init__ ( config ) Initialize CookieBackend . Parameters: Name Type Description Default config CookieBackendConfig SessionCookieConfig instance. required","title":"__init__()"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.dump_data","text":"dump_data ( data , scope = None ) Given serializable data, including pydantic models and numpy types, dump it into a bytes string, encrypt, encode and split it into chunks of the desirable size. Parameters: Name Type Description Default data Any Data to serialize, encrypt, encode and chunk. required scope Optional [ Scope ] The ASGI connection scope. None Notes The returned list is composed of a chunks of a single base64 encoded string that is encrypted using AES-CGM. Returns: Type Description List [ bytes ] List of encoded bytes string of a maximum length equal to the 'CHUNK_SIZE' constant.","title":"dump_data()"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.load_data","text":"load_data ( data ) Given a list of strings, decodes them into the session object. Parameters: Name Type Description Default data List [ bytes ] A list of strings derived from the request's session cookie(s). required Returns: Type Description Dict [ str , Any ] A deserialized session value.","title":"load_data()"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.get_cookie_keys","text":"get_cookie_keys ( connection ) Return a list of cookie-keys from the connection if they match the session-cookie pattern. Parameters: Name Type Description Default connection ASGIConnection An ASGIConnection instance required Returns: Type Description List [ str ] A list of session-cookie keys","title":"get_cookie_keys()"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.store_in_message","text":"store_in_message ( scope_session , message , connection ) Store data from scope_session in Message in the form of cookies. If the contents of scope_session are too large to fit a single cookie, it will be split across several cookies, following the naming scheme of <cookie key>-<n> . If the session is empty or shrinks, cookies will be cleared by setting their value to null Parameters: Name Type Description Default scope_session ScopeSession Current session to store required message Message Outgoing send-message required connection ASGIConnection Originating ASGIConnection containing the scope required Returns: Type Description None None","title":"store_in_message()"},{"location":"reference/middleware/session-middleware/2-cookie-backend/#starlite.middleware.session.cookie_backend.CookieBackend.load_from_connection","text":"load_from_connection ( connection ) Load session data from a connection's session-cookies and return it as a dictionary. Parameters: Name Type Description Default connection ASGIConnection Originating ASGIConnection required Returns: Type Description Dict [ str , Any ] The session data","title":"load_from_connection()"},{"location":"reference/middleware/session-middleware/3-file-backend/","text":"File backend starlite.middleware.session.file_backend.FileBackendConfig Bases: ServerSideSessionConfig Backend configuration for FileBackend storage_path class-attribute storage_path : PathLike Disk path under which to store session files. make_filename class-attribute make_filename : Optional [ Callable [[ str ], str ]] = None Callable that turns a session-ID into a filename used for storage. By default, the session-ID will be used as a filename starlite.middleware.session.file_backend.FileBackend Bases: ServerSideBackend [ FileBackendConfig ] Session backend to store data in files. __init__ __init__ ( config ) Initialize FileBackend Parameters: Name Type Description Default config FileBackendConfig A FileBackendConfig required get async get ( session_id ) Load data associated with session_id from a file. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None . set async set ( session_id , data ) Store data alongside metadata under the session_id , using the ID as a filename. If a file already exists for session_id , replace it with data and reset its expiry time. Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None delete async delete ( session_id ) Delete the file associated with session_id . Fails silently if no such file exists Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None delete_all async delete_all () Delete all files in the storage path. Returns: Type Description None None delete_expired async delete_expired () Delete expired session files. Return None","title":"File backend"},{"location":"reference/middleware/session-middleware/3-file-backend/#file-backend","text":"","title":"File backend"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackendConfig","text":"Bases: ServerSideSessionConfig Backend configuration for FileBackend","title":"FileBackendConfig"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackendConfig.storage_path","text":"storage_path : PathLike Disk path under which to store session files.","title":"storage_path"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackendConfig.make_filename","text":"make_filename : Optional [ Callable [[ str ], str ]] = None Callable that turns a session-ID into a filename used for storage. By default, the session-ID will be used as a filename","title":"make_filename"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend","text":"Bases: ServerSideBackend [ FileBackendConfig ] Session backend to store data in files.","title":"FileBackend"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.__init__","text":"__init__ ( config ) Initialize FileBackend Parameters: Name Type Description Default config FileBackendConfig A FileBackendConfig required","title":"__init__()"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.get","text":"get ( session_id ) Load data associated with session_id from a file. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None .","title":"get()"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.set","text":"set ( session_id , data ) Store data alongside metadata under the session_id , using the ID as a filename. If a file already exists for session_id , replace it with data and reset its expiry time. Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None","title":"set()"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.delete","text":"delete ( session_id ) Delete the file associated with session_id . Fails silently if no such file exists Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None","title":"delete()"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.delete_all","text":"delete_all () Delete all files in the storage path. Returns: Type Description None None","title":"delete_all()"},{"location":"reference/middleware/session-middleware/3-file-backend/#starlite.middleware.session.file_backend.FileBackend.delete_expired","text":"delete_expired () Delete expired session files. Return None","title":"delete_expired()"},{"location":"reference/middleware/session-middleware/4-memcached-backend/","text":"Memcached backend starlite.middleware.session.memcached_backend.MemcachedBackendConfig Bases: ServerSideSessionConfig Configuration for MemcachedBackend memcached class-attribute memcached : MemcacheClient An aiomcache.Client instance. starlite.middleware.session.memcached_backend.MemcachedBackend Bases: ServerSideBackend [ MemcachedBackendConfig ] Session backend to store data in memcached. __init__ __init__ ( config ) Initialize MemcachedBackend Parameters: Name Type Description Default config MemcachedBackendConfig A MemcachedBackendConfig instance required Notes Requires aiomcache . Install with pip install starlite[memcached] get async get ( session_id ) Retrieve data associated with session_id from memcached. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None . set async set ( session_id , data ) Store data in memcached under <prefix>:<session_id> . If there is already data associated with session_id , replace it with data and reset its expiry time. Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None delete async delete ( session_id ) Delete the data associated with session_id . Fail silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None delete_all async delete_all () Delete all data stored within this backend. Returns: Type Description None None Notes This has poor performance since memcached does not offer utilities to properly scan or match keys by prefix. Deprecated since 1.43.0 This method is deprecated since 1.43.0. If you need this functionality, consider using the redis backend instead.","title":"Memcached backend"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#memcached-backend","text":"","title":"Memcached backend"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackendConfig","text":"Bases: ServerSideSessionConfig Configuration for MemcachedBackend","title":"MemcachedBackendConfig"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackendConfig.memcached","text":"memcached : MemcacheClient An aiomcache.Client instance.","title":"memcached"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend","text":"Bases: ServerSideBackend [ MemcachedBackendConfig ] Session backend to store data in memcached.","title":"MemcachedBackend"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.__init__","text":"__init__ ( config ) Initialize MemcachedBackend Parameters: Name Type Description Default config MemcachedBackendConfig A MemcachedBackendConfig instance required Notes Requires aiomcache . Install with pip install starlite[memcached]","title":"__init__()"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.get","text":"get ( session_id ) Retrieve data associated with session_id from memcached. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None .","title":"get()"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.set","text":"set ( session_id , data ) Store data in memcached under <prefix>:<session_id> . If there is already data associated with session_id , replace it with data and reset its expiry time. Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None","title":"set()"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.delete","text":"delete ( session_id ) Delete the data associated with session_id . Fail silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None","title":"delete()"},{"location":"reference/middleware/session-middleware/4-memcached-backend/#starlite.middleware.session.memcached_backend.MemcachedBackend.delete_all","text":"delete_all () Delete all data stored within this backend. Returns: Type Description None None Notes This has poor performance since memcached does not offer utilities to properly scan or match keys by prefix. Deprecated since 1.43.0 This method is deprecated since 1.43.0. If you need this functionality, consider using the redis backend instead.","title":"delete_all()"},{"location":"reference/middleware/session-middleware/5-memory-backend/","text":"Memory backend starlite.middleware.session.memory_backend.MemoryBackend Bases: ServerSideBackend [ MemoryBackendConfig ] Session backend to store data in memory. __init__ __init__ ( config ) Initialize MemoryBackend . Parameters: Name Type Description Default config MemoryBackendConfig An instance of MemoryBackendConfig required Warning This should not be used in production and serves mainly as a dummy backend for easy testing. It is not process-safe, and data won't be persisted get async get ( session_id ) Retrieve data associated with session_id . Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None . set async set ( session_id , data ) Store data under the session_id for later retrieval. If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None delete async delete ( session_id ) Delete the data associated with session_id . Fails silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None delete_all async delete_all () Delete all session data. Returns: Type Description None None","title":"Memory backend"},{"location":"reference/middleware/session-middleware/5-memory-backend/#memory-backend","text":"","title":"Memory backend"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend","text":"Bases: ServerSideBackend [ MemoryBackendConfig ] Session backend to store data in memory.","title":"MemoryBackend"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.__init__","text":"__init__ ( config ) Initialize MemoryBackend . Parameters: Name Type Description Default config MemoryBackendConfig An instance of MemoryBackendConfig required Warning This should not be used in production and serves mainly as a dummy backend for easy testing. It is not process-safe, and data won't be persisted","title":"__init__()"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.get","text":"get ( session_id ) Retrieve data associated with session_id . Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None .","title":"get()"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.set","text":"set ( session_id , data ) Store data under the session_id for later retrieval. If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None","title":"set()"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.delete","text":"delete ( session_id ) Delete the data associated with session_id . Fails silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None","title":"delete()"},{"location":"reference/middleware/session-middleware/5-memory-backend/#starlite.middleware.session.memory_backend.MemoryBackend.delete_all","text":"delete_all () Delete all session data. Returns: Type Description None None","title":"delete_all()"},{"location":"reference/middleware/session-middleware/6-redis-backend/","text":"Redis backend starlite.middleware.session.redis_backend.RedisBackendConfig Bases: ServerSideSessionConfig Configuration for RedisBackend redis class-attribute redis : Redis redis.asyncio.Redis instance. starlite.middleware.session.redis_backend.RedisBackend Bases: ServerSideBackend [ RedisBackendConfig ] Session backend to store data in redis. __init__ __init__ ( config ) Initialize RedisBackend . Notes Requires redis . Install with pip install starlite[redis] get async get ( session_id ) Load data associated with session_id from redis. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Union [ bytes , str , None] The session data, if existing, otherwise None . set async set ( session_id , data ) Store data in redis under <prefix>:<session_id> If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None delete async delete ( session_id ) Delete the data associated with session_id from redis. Fail silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None delete_all async delete_all () Delete all session data stored in redis. Returns: Type Description None None","title":"Redis backend"},{"location":"reference/middleware/session-middleware/6-redis-backend/#redis-backend","text":"","title":"Redis backend"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackendConfig","text":"Bases: ServerSideSessionConfig Configuration for RedisBackend","title":"RedisBackendConfig"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackendConfig.redis","text":"redis : Redis redis.asyncio.Redis instance.","title":"redis"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend","text":"Bases: ServerSideBackend [ RedisBackendConfig ] Session backend to store data in redis.","title":"RedisBackend"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.__init__","text":"__init__ ( config ) Initialize RedisBackend . Notes Requires redis . Install with pip install starlite[redis]","title":"__init__()"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.get","text":"get ( session_id ) Load data associated with session_id from redis. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Union [ bytes , str , None] The session data, if existing, otherwise None .","title":"get()"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.set","text":"set ( session_id , data ) Store data in redis under <prefix>:<session_id> If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None","title":"set()"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.delete","text":"delete ( session_id ) Delete the data associated with session_id from redis. Fail silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None","title":"delete()"},{"location":"reference/middleware/session-middleware/6-redis-backend/#starlite.middleware.session.redis_backend.RedisBackend.delete_all","text":"delete_all () Delete all session data stored in redis. Returns: Type Description None None","title":"delete_all()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/","text":"SQLAlchemy backends starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackendConfig Bases: ServerSideSessionConfig Configuration for SQLAlchemyBackend and AsyncSQLAlchemyBackend plugin class-attribute plugin : SQLAlchemyPlugin starlite.middleware.session.sqlalchemy_backend.BaseSQLAlchemyBackend Bases: Generic [ AnySASessionT ] , ServerSideBackend [ SQLAlchemyBackendConfig ] , ABC Session backend to store data in a database with SQLAlchemy. Works with both sync and async engines. Notes Requires sqlalchemy which needs to be installed separately, and a configured SQLAlchemyPlugin . __init__ __init__ ( config ) Initialize BaseSQLAlchemyBackend . Parameters: Name Type Description Default config SQLAlchemyBackendConfig An instance of SQLAlchemyBackendConfig required delete_expired async abstractmethod delete_expired () Delete all expired sessions from the database. starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend Bases: BaseSQLAlchemyBackend [ SASession ] Synchronous SQLAlchemy backend. get async get ( session_id ) Retrieve data associated with session_id . Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None . set async set ( session_id , data ) Store data under the session_id for later retrieval. If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None delete async delete ( session_id ) Delete the data associated with session_id . Fails silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None delete_all async delete_all () Delete all session data. Returns: Type Description None None delete_expired async delete_expired () Delete all expired session from the database. Returns: Type Description None None starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend Bases: BaseSQLAlchemyBackend [ AsyncSASession ] Asynchronous SQLAlchemy backend. get async get ( session_id ) Retrieve data associated with session_id . Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None . set async set ( session_id , data ) Store data under the session_id for later retrieval. If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID. required data bytes Serialized session data required Returns: Type Description None None delete async delete ( session_id ) Delete the data associated with session_id . Fails silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None delete_all async delete_all () Delete all session data. Returns: Type Description None None delete_expired async delete_expired () Delete all expired session from the database. Returns: Type Description None None starlite.middleware.session.sqlalchemy_backend.create_session_model starlite . middleware . session . sqlalchemy_backend . create_session_model ( base , table_name = 'session' ) Dynamically generate a session storage model and register it with the declarative base. Parameters: Name Type Description Default base Type [ Any ] SQLAlchemy declarative base required table_name str Alternative table name 'session' Returns: Type Description Type [ SessionModelMixin ] A mapped model subclassing base and SessionModelMixin starlite.middleware.session.sqlalchemy_backend.register_session_model starlite . middleware . session . sqlalchemy_backend . register_session_model ( base , model ) Map and register a pre-existing model subclassing SessionModelMixin with a declarative base or registry. Parameters: Name Type Description Default base Union [ registry , Any ] Either a orm.registry or DeclarativeBase required model Type [ SessionModelT ] SQLAlchemy model to register required Returns: Type Description Type [ SessionModelT ] A mapped model subclassing SessionModelMixin , and registered in registry starlite.middleware.session.sqlalchemy_backend.SessionModelMixin Mixin for session storage. session_id class-attribute session_id : Mapped [ str ] = sa . Column ( sa . String , nullable = False , unique = True , index = True ) data class-attribute data : Mapped [ bytes ] = sa . Column ( sa . LargeBinary , nullable = False ) expires class-attribute expires : Mapped [ datetime ] = sa . Column ( sa . DateTime , nullable = False ) expired expired () SQL-Expression to check if the session has expired. starlite.middleware.session.sqlalchemy_backend.SessionModel Bases: SessionModelMixin Session storage model. __tablename__ class-attribute __tablename__ = 'session' id class-attribute id : Mapped [ int ] = sa . Column ( sa . Integer , primary_key = True )","title":"SQLAlchemy backends"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#sqlalchemy-backends","text":"","title":"SQLAlchemy backends"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackendConfig","text":"Bases: ServerSideSessionConfig Configuration for SQLAlchemyBackend and AsyncSQLAlchemyBackend","title":"SQLAlchemyBackendConfig"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackendConfig.plugin","text":"plugin : SQLAlchemyPlugin","title":"plugin"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.BaseSQLAlchemyBackend","text":"Bases: Generic [ AnySASessionT ] , ServerSideBackend [ SQLAlchemyBackendConfig ] , ABC Session backend to store data in a database with SQLAlchemy. Works with both sync and async engines. Notes Requires sqlalchemy which needs to be installed separately, and a configured SQLAlchemyPlugin .","title":"BaseSQLAlchemyBackend"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.BaseSQLAlchemyBackend.__init__","text":"__init__ ( config ) Initialize BaseSQLAlchemyBackend . Parameters: Name Type Description Default config SQLAlchemyBackendConfig An instance of SQLAlchemyBackendConfig required","title":"__init__()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.BaseSQLAlchemyBackend.delete_expired","text":"delete_expired () Delete all expired sessions from the database.","title":"delete_expired()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend","text":"Bases: BaseSQLAlchemyBackend [ SASession ] Synchronous SQLAlchemy backend.","title":"SQLAlchemyBackend"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.get","text":"get ( session_id ) Retrieve data associated with session_id . Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None .","title":"get()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.set","text":"set ( session_id , data ) Store data under the session_id for later retrieval. If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID required data bytes Serialized session data required Returns: Type Description None None","title":"set()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.delete","text":"delete ( session_id ) Delete the data associated with session_id . Fails silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None","title":"delete()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.delete_all","text":"delete_all () Delete all session data. Returns: Type Description None None","title":"delete_all()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SQLAlchemyBackend.delete_expired","text":"delete_expired () Delete all expired session from the database. Returns: Type Description None None","title":"delete_expired()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend","text":"Bases: BaseSQLAlchemyBackend [ AsyncSASession ] Asynchronous SQLAlchemy backend.","title":"AsyncSQLAlchemyBackend"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.get","text":"get ( session_id ) Retrieve data associated with session_id . Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description Optional [ bytes ] The session data, if existing, otherwise None .","title":"get()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.set","text":"set ( session_id , data ) Store data under the session_id for later retrieval. If there is already data associated with session_id , replace it with data and reset its expiry time Parameters: Name Type Description Default session_id str The session-ID. required data bytes Serialized session data required Returns: Type Description None None","title":"set()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.delete","text":"delete ( session_id ) Delete the data associated with session_id . Fails silently if no such session-ID exists. Parameters: Name Type Description Default session_id str The session-ID required Returns: Type Description None None","title":"delete()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.delete_all","text":"delete_all () Delete all session data. Returns: Type Description None None","title":"delete_all()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.AsyncSQLAlchemyBackend.delete_expired","text":"delete_expired () Delete all expired session from the database. Returns: Type Description None None","title":"delete_expired()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.create_session_model","text":"starlite . middleware . session . sqlalchemy_backend . create_session_model ( base , table_name = 'session' ) Dynamically generate a session storage model and register it with the declarative base. Parameters: Name Type Description Default base Type [ Any ] SQLAlchemy declarative base required table_name str Alternative table name 'session' Returns: Type Description Type [ SessionModelMixin ] A mapped model subclassing base and SessionModelMixin","title":"create_session_model()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.register_session_model","text":"starlite . middleware . session . sqlalchemy_backend . register_session_model ( base , model ) Map and register a pre-existing model subclassing SessionModelMixin with a declarative base or registry. Parameters: Name Type Description Default base Union [ registry , Any ] Either a orm.registry or DeclarativeBase required model Type [ SessionModelT ] SQLAlchemy model to register required Returns: Type Description Type [ SessionModelT ] A mapped model subclassing SessionModelMixin , and registered in registry","title":"register_session_model()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin","text":"Mixin for session storage.","title":"SessionModelMixin"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin.session_id","text":"session_id : Mapped [ str ] = sa . Column ( sa . String , nullable = False , unique = True , index = True )","title":"session_id"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin.data","text":"data : Mapped [ bytes ] = sa . Column ( sa . LargeBinary , nullable = False )","title":"data"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin.expires","text":"expires : Mapped [ datetime ] = sa . Column ( sa . DateTime , nullable = False )","title":"expires"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModelMixin.expired","text":"expired () SQL-Expression to check if the session has expired.","title":"expired()"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModel","text":"Bases: SessionModelMixin Session storage model.","title":"SessionModel"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModel.__tablename__","text":"__tablename__ = 'session'","title":"__tablename__"},{"location":"reference/middleware/session-middleware/7-sqlalchemy-backend/#starlite.middleware.session.sqlalchemy_backend.SessionModel.id","text":"id : Mapped [ int ] = sa . Column ( sa . Integer , primary_key = True )","title":"id"},{"location":"reference/openapi/0-openapi-controller/","text":"OpenAPI Controller starlite.openapi.controller.OpenAPIController Bases: Controller Controller for OpenAPI endpoints. favicon property favicon : str Return favicon <link> tag, if applicable. Returns: Type Description str A <link> tag if self.favicon_url is not empty, otherwise returns a placeholder meta tag. favicon_url class-attribute favicon_url : str = '' URL to download a favicon from. path class-attribute path : str = '/schema' Base path for the OpenAPI documentation endpoints. redoc_version class-attribute redoc_version : str = 'next' Redoc version to download from the CDN. redoc_google_fonts class-attribute redoc_google_fonts : bool = True Download google fonts via CDN. Should be set to False when not using a CDN. redoc_js_url class-attribute redoc_js_url : str = ( f \"https://cdn.jsdelivr.net/npm/redoc@ { redoc_version } /bundles/redoc.standalone.js\" ) Download url for the Redoc JS bundle. render_methods_map cached property render_methods_map : Dict [ Literal [ 'redoc' , 'swagger' , 'elements' ], Callable [[ Request ], str ]] Map render method names to render methods. Returns: Type Description Dict [ Literal ['redoc', 'swagger', 'elements'], Callable [[ Request ], str ]] A mapping of string keys to render methods. stoplight_elements_version class-attribute stoplight_elements_version : str = '7.7.5' StopLight Elements version to download from the CDN. stoplight_elements_css_url class-attribute stoplight_elements_css_url : str = ( f \"https://unpkg.com/@stoplight/elements@ { stoplight_elements_version } /styles.min.css\" ) Download url for the Stoplight Elements CSS bundle. stoplight_elements_js_url class-attribute stoplight_elements_js_url : str = ( f \"https://unpkg.com/@stoplight/elements@ { stoplight_elements_version } /web-components.min.js\" ) Download url for the Stoplight Elements JS bundle. style class-attribute style : str = 'body { margin: 0; padding: 0 }' Base styling of the html body. swagger_ui_version class-attribute swagger_ui_version : str = '4.15.5' SwaggerUI version to download from the CDN. swagger_css_url class-attribute swagger_css_url : str = ( f \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@ { swagger_ui_version } /swagger-ui.css\" ) Download url for the Swagger UI CSS bundle. redoc redoc ( request ) Route handler responsible for rendering Redoc. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with a rendered redoc documentation site render_404_page render_404_page () Render an HTML 404 page. Returns: Type Description str A rendered html string. render_redoc render_redoc ( request ) Render an HTML page for Redoc. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string. render_stoplight_elements render_stoplight_elements ( request ) Render an HTML page for StopLight Elements. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string. render_swagger_ui render_swagger_ui ( request ) Render an HTML page for Swagger-UI. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string. retrieve_schema_json retrieve_schema_json ( request ) Return the OpenAPI schema as JSON with an 'application/vnd.oai.openapi+json' Content-Type header. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A Response instance with the JSON object rendered into a string. retrieve_schema_yaml retrieve_schema_yaml ( request ) Return the OpenAPI schema as YAML with an 'application/vnd.oai.openapi' Content-Type header. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A Response instance with the YAML object rendered into a string. root root ( request ) Render a static documentation site. The site to be rendered is based on the root_schema_site value set in the application's OpenAPIConfig . Defaults to redoc . Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with the rendered site defined in root_schema_site. Raises: Type Description ImproperlyConfiguredException If the application openapi_config attribute is None . should_serve_endpoint should_serve_endpoint ( request ) Verify that the requested path is within the enabled endpoints in the openapi_config. Parameters: Name Type Description Default request Request To be tested if endpoint enabled. required Returns: Type Description bool A boolean. Raises: Type Description ImproperlyConfiguredException If the application openapi_config attribute is None . stoplight_elements stoplight_elements ( request ) Route handler responsible for rendering StopLight Elements. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with a rendered stoplight elements documentation site swagger_ui swagger_ui ( request ) Route handler responsible for rendering Swagger-UI. Parameters: Name Type Description Default request Request A Request instance. required Returns: Name Type Description response Response With a rendered swagger documentation site","title":"OpenAPI Controller"},{"location":"reference/openapi/0-openapi-controller/#openapi-controller","text":"","title":"OpenAPI Controller"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController","text":"Bases: Controller Controller for OpenAPI endpoints.","title":"OpenAPIController"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.favicon","text":"favicon : str Return favicon <link> tag, if applicable. Returns: Type Description str A <link> tag if self.favicon_url is not empty, otherwise returns a placeholder meta tag.","title":"favicon"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.favicon_url","text":"favicon_url : str = '' URL to download a favicon from.","title":"favicon_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.path","text":"path : str = '/schema' Base path for the OpenAPI documentation endpoints.","title":"path"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc_version","text":"redoc_version : str = 'next' Redoc version to download from the CDN.","title":"redoc_version"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc_google_fonts","text":"redoc_google_fonts : bool = True Download google fonts via CDN. Should be set to False when not using a CDN.","title":"redoc_google_fonts"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc_js_url","text":"redoc_js_url : str = ( f \"https://cdn.jsdelivr.net/npm/redoc@ { redoc_version } /bundles/redoc.standalone.js\" ) Download url for the Redoc JS bundle.","title":"redoc_js_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_methods_map","text":"render_methods_map : Dict [ Literal [ 'redoc' , 'swagger' , 'elements' ], Callable [[ Request ], str ]] Map render method names to render methods. Returns: Type Description Dict [ Literal ['redoc', 'swagger', 'elements'], Callable [[ Request ], str ]] A mapping of string keys to render methods.","title":"render_methods_map"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements_version","text":"stoplight_elements_version : str = '7.7.5' StopLight Elements version to download from the CDN.","title":"stoplight_elements_version"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements_css_url","text":"stoplight_elements_css_url : str = ( f \"https://unpkg.com/@stoplight/elements@ { stoplight_elements_version } /styles.min.css\" ) Download url for the Stoplight Elements CSS bundle.","title":"stoplight_elements_css_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements_js_url","text":"stoplight_elements_js_url : str = ( f \"https://unpkg.com/@stoplight/elements@ { stoplight_elements_version } /web-components.min.js\" ) Download url for the Stoplight Elements JS bundle.","title":"stoplight_elements_js_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.style","text":"style : str = 'body { margin: 0; padding: 0 }' Base styling of the html body.","title":"style"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.swagger_ui_version","text":"swagger_ui_version : str = '4.15.5' SwaggerUI version to download from the CDN.","title":"swagger_ui_version"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.swagger_css_url","text":"swagger_css_url : str = ( f \"https://cdn.jsdelivr.net/npm/swagger-ui-dist@ { swagger_ui_version } /swagger-ui.css\" ) Download url for the Swagger UI CSS bundle.","title":"swagger_css_url"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.redoc","text":"redoc ( request ) Route handler responsible for rendering Redoc. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with a rendered redoc documentation site","title":"redoc()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_404_page","text":"render_404_page () Render an HTML 404 page. Returns: Type Description str A rendered html string.","title":"render_404_page()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_redoc","text":"render_redoc ( request ) Render an HTML page for Redoc. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string.","title":"render_redoc()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_stoplight_elements","text":"render_stoplight_elements ( request ) Render an HTML page for StopLight Elements. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string.","title":"render_stoplight_elements()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.render_swagger_ui","text":"render_swagger_ui ( request ) Render an HTML page for Swagger-UI. Notes override this method to customize the template. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description str A rendered html string.","title":"render_swagger_ui()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.retrieve_schema_json","text":"retrieve_schema_json ( request ) Return the OpenAPI schema as JSON with an 'application/vnd.oai.openapi+json' Content-Type header. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A Response instance with the JSON object rendered into a string.","title":"retrieve_schema_json()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.retrieve_schema_yaml","text":"retrieve_schema_yaml ( request ) Return the OpenAPI schema as YAML with an 'application/vnd.oai.openapi' Content-Type header. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A Response instance with the YAML object rendered into a string.","title":"retrieve_schema_yaml()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.root","text":"root ( request ) Render a static documentation site. The site to be rendered is based on the root_schema_site value set in the application's OpenAPIConfig . Defaults to redoc . Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with the rendered site defined in root_schema_site. Raises: Type Description ImproperlyConfiguredException If the application openapi_config attribute is None .","title":"root()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.should_serve_endpoint","text":"should_serve_endpoint ( request ) Verify that the requested path is within the enabled endpoints in the openapi_config. Parameters: Name Type Description Default request Request To be tested if endpoint enabled. required Returns: Type Description bool A boolean. Raises: Type Description ImproperlyConfiguredException If the application openapi_config attribute is None .","title":"should_serve_endpoint()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.stoplight_elements","text":"stoplight_elements ( request ) Route handler responsible for rendering StopLight Elements. Parameters: Name Type Description Default request Request A Request instance. required Returns: Type Description Response A response with a rendered stoplight elements documentation site","title":"stoplight_elements()"},{"location":"reference/openapi/0-openapi-controller/#starlite.openapi.controller.OpenAPIController.swagger_ui","text":"swagger_ui ( request ) Route handler responsible for rendering Swagger-UI. Parameters: Name Type Description Default request Request A Request instance. required Returns: Name Type Description response Response With a rendered swagger documentation site","title":"swagger_ui()"},{"location":"reference/openapi/1-openapi-response-spec/","text":"OpenAPI Response Spec starlite.openapi.datastructures.ResponseSpec Bases: BaseModel Container type of additional responses. model class-attribute model : Type [ BaseModel ] A model that describes the content of the response. generate_examples class-attribute generate_examples : bool = True Generate examples for the response content. description class-attribute description : str = 'Additional response' A description of the response. media_type class-attribute media_type : MediaType = MediaType . JSON Response media type.","title":"OpenAPI Response Spec"},{"location":"reference/openapi/1-openapi-response-spec/#openapi-response-spec","text":"","title":"OpenAPI Response Spec"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec","text":"Bases: BaseModel Container type of additional responses.","title":"ResponseSpec"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.model","text":"model : Type [ BaseModel ] A model that describes the content of the response.","title":"model"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.generate_examples","text":"generate_examples : bool = True Generate examples for the response content.","title":"generate_examples"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.description","text":"description : str = 'Additional response' A description of the response.","title":"description"},{"location":"reference/openapi/1-openapi-response-spec/#starlite.openapi.datastructures.ResponseSpec.media_type","text":"media_type : MediaType = MediaType . JSON Response media type.","title":"media_type"},{"location":"reference/params/0-parameter/","text":"Parameter starlite . params . Parameter ( value_type = Undefined , * , header = None , cookie = None , query = None , examples = None , external_docs = None , content_encoding = None , required = True , default = Undefined , title = None , description = None , const = None , gt = None , ge = None , lt = None , le = None , multiple_of = None , min_items = None , max_items = None , min_length = None , max_length = None , regex = None ) Create a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default value_type Any Undefined by default. Undefined header Optional [ str ] The header parameter key - required for header parameters. None cookie Optional [ str ] The cookie parameter key - required for cookie parameters. None query Optional [ str ] The query parameter key for this parameter. None examples Optional [ List [ Example ]] A list of Example models. None external_docs Optional [ ExternalDocumentation ] A url pointing at external documentation for the given parameter. None content_encoding Optional [ str ] The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details. None required bool A boolean flag dictating whether this parameter is required. If set to False, None values will be allowed. Defaults to True. True default Any A default value. If const is true, this value is required. Undefined title Optional [ str ] String value used in the title section of the OpenAPI schema for the given parameter. None description Optional [ str ] String value used in the description section of the OpenAPI schema for the given parameter. None const Optional [ bool ] A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. None gt Optional [ float ] Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. None ge Optional [ float ] Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. None lt Optional [ float ] Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. None le Optional [ float ] Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. None multiple_of Optional [ float ] Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. None min_items Optional [ int ] Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. None max_items Optional [ int ] Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. None min_length Optional [ int ] Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. None max_length Optional [ int ] Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. None regex Optional [ str ] A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. None","title":"Parameter"},{"location":"reference/params/0-parameter/#parameter","text":"","title":"Parameter"},{"location":"reference/params/0-parameter/#starlite.params.Parameter","text":"Create a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default value_type Any Undefined by default. Undefined header Optional [ str ] The header parameter key - required for header parameters. None cookie Optional [ str ] The cookie parameter key - required for cookie parameters. None query Optional [ str ] The query parameter key for this parameter. None examples Optional [ List [ Example ]] A list of Example models. None external_docs Optional [ ExternalDocumentation ] A url pointing at external documentation for the given parameter. None content_encoding Optional [ str ] The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details. None required bool A boolean flag dictating whether this parameter is required. If set to False, None values will be allowed. Defaults to True. True default Any A default value. If const is true, this value is required. Undefined title Optional [ str ] String value used in the title section of the OpenAPI schema for the given parameter. None description Optional [ str ] String value used in the description section of the OpenAPI schema for the given parameter. None const Optional [ bool ] A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. None gt Optional [ float ] Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. None ge Optional [ float ] Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. None lt Optional [ float ] Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. None le Optional [ float ] Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. None multiple_of Optional [ float ] Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. None min_items Optional [ int ] Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. None max_items Optional [ int ] Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. None min_length Optional [ int ] Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. None max_length Optional [ int ] Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. None regex Optional [ str ] A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. None","title":"Parameter()"},{"location":"reference/params/1-body/","text":"Body starlite . params . Body ( * , media_type = RequestEncodingType . JSON , examples = None , external_docs = None , content_encoding = None , default = Undefined , title = None , description = None , const = None , gt = None , ge = None , lt = None , le = None , multiple_of = None , min_items = None , max_items = None , min_length = None , max_length = None , regex = None ) Create a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default media_type Union [ str , RequestEncodingType ] Defaults to RequestEncodingType.JSON. RequestEncodingType.JSON examples Optional [ List [ Example ]] A list of Example models. None external_docs Optional [ ExternalDocumentation ] A url pointing at external documentation for the given parameter. None content_encoding Optional [ str ] The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details. None default Any A default value. If const is true, this value is required. Undefined title Optional [ str ] String value used in the title section of the OpenAPI schema for the given parameter. None description Optional [ str ] String value used in the description section of the OpenAPI schema for the given parameter. None const Optional [ bool ] A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. None gt Optional [ float ] Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. None ge Optional [ float ] Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. None lt Optional [ float ] Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. None le Optional [ float ] Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. None multiple_of Optional [ float ] Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. None min_items Optional [ int ] Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. None max_items Optional [ int ] Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. None min_length Optional [ int ] Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. None max_length Optional [ int ] Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. None regex Optional [ str ] A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. None","title":"Body"},{"location":"reference/params/1-body/#body","text":"","title":"Body"},{"location":"reference/params/1-body/#starlite.params.Body","text":"Create a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default media_type Union [ str , RequestEncodingType ] Defaults to RequestEncodingType.JSON. RequestEncodingType.JSON examples Optional [ List [ Example ]] A list of Example models. None external_docs Optional [ ExternalDocumentation ] A url pointing at external documentation for the given parameter. None content_encoding Optional [ str ] The content encoding of the value. Applicable on to string values. See OpenAPI 3.1 for details. None default Any A default value. If const is true, this value is required. Undefined title Optional [ str ] String value used in the title section of the OpenAPI schema for the given parameter. None description Optional [ str ] String value used in the description section of the OpenAPI schema for the given parameter. None const Optional [ bool ] A boolean flag dictating whether this parameter is a constant. If True, the value passed to the parameter must equal its default value. This also causes the OpenAPI const field to be populated with the default value. None gt Optional [ float ] Constrict value to be greater than a given float or int. Equivalent to exclusiveMinimum in the OpenAPI specification. None ge Optional [ float ] Constrict value to be greater or equal to a given float or int. Equivalent to minimum in the OpenAPI specification. None lt Optional [ float ] Constrict value to be less than a given float or int. Equivalent to exclusiveMaximum in the OpenAPI specification. None le Optional [ float ] Constrict value to be less or equal to a given float or int. Equivalent to maximum in the OpenAPI specification. None multiple_of Optional [ float ] Constrict value to a multiple of a given float or int. Equivalent to multipleOf in the OpenAPI specification. None min_items Optional [ int ] Constrict a set or a list to have a minimum number of items. Equivalent to minItems in the OpenAPI specification. None max_items Optional [ int ] Constrict a set or a list to have a maximum number of items. Equivalent to maxItems in the OpenAPI specification. None min_length Optional [ int ] Constrict a string or bytes value to have a minimum length. Equivalent to minLength in the OpenAPI specification. None max_length Optional [ int ] Constrict a string or bytes value to have a maximum length. Equivalent to maxLength in the OpenAPI specification. None regex Optional [ str ] A string representing a regex against which the given string will be matched. Equivalent to pattern in the OpenAPI specification. None","title":"Body()"},{"location":"reference/params/2-dependency/","text":"Dependency starlite . params . Dependency ( * , default = Undefined , skip_validation = False ) Create a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default default Any default value if dependency not provided. Undefined skip_validation bool If True provided dependency values are not validated by signature model. False","title":"Dependency"},{"location":"reference/params/2-dependency/#dependency","text":"","title":"Dependency"},{"location":"reference/params/2-dependency/#starlite.params.Dependency","text":"Create a pydantic FieldInfo instance with an extra kwargs, used for both parameter parsing and OpenAPI schema generation. Parameters: Name Type Description Default default Any default value if dependency not provided. Undefined skip_validation bool If True provided dependency values are not validated by signature model. False","title":"Dependency()"},{"location":"reference/plugins/0-plugin-protocol/","text":"Plugin Protocol starlite.plugins.base.PluginProtocol Bases: Protocol [ ModelT ] Base plugin protocol to be inherited when implementing plugins. on_app_init on_app_init ( app ) Receive the Starlite application instance before init is finalized and allow the plugin to update various attributes. Examples: from starlite import PluginProtocol , Starlite , get @get ( \"/my-path\" ) def my_route_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } class MyPlugin ( PluginProtocol [ Any ]): def on_app_init ( self , app : Starlite ) -> None : # update app attributes app . after_request = ... app . after_response = ... app . before_request = ... app . dependencies . update ({ ... }) app . exception_handlers . update ({ ... }) app . guards . extend ( ... ) app . middleware . extend ( ... ) app . on_shutdown . extend ( ... ) app . on_startup . extend ( ... ) app . parameters . update ({ ... }) app . response_class = ... app . response_cookies . extend ( ... ) app . response_headers . update ( ... ) app . tags . extend ( ... ) # register a route handler app . register ( my_route_handler ) Parameters: Name Type Description Default app Starlite The Starlite instance. required Returns: Type Description None None is_plugin_supported_type staticmethod is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin. Parameters: Name Type Description Default value Any An arbitrary value. required Returns: Type Description TypeGuard [ ModelT ] A typeguard dictating whether the value is supported by the plugin. to_pydantic_model_class to_pydantic_model_class ( model_class , ** kwargs ) Given a model_class supported by the plugin, convert it to a subclass of the pydantic BaseModel. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required **kwargs Any Any additional kwargs. {} Returns: Type Description Type [ BaseModel ] A pydantic model class. from_pydantic_model_instance from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required pydantic_model_instance BaseModel A pydantic model instance. required Returns: Type Description ModelT A model instance. to_dict to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values. Parameters: Name Type Description Default model_instance ModelT A model instance of the type supported by the plugin. required Notes This method can be async as well. Returns: Type Description Union [ Dict [ str , Any ], Awaitable [ Dict [ str , Any ]]] A string keyed dictionary of values. from_dict from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required **kwargs Any A string keyed mapping of values. {} Returns: Type Description ModelT A model instance.","title":"Plugin Protocol"},{"location":"reference/plugins/0-plugin-protocol/#plugin-protocol","text":"","title":"Plugin Protocol"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol","text":"Bases: Protocol [ ModelT ] Base plugin protocol to be inherited when implementing plugins.","title":"PluginProtocol"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.on_app_init","text":"on_app_init ( app ) Receive the Starlite application instance before init is finalized and allow the plugin to update various attributes. Examples: from starlite import PluginProtocol , Starlite , get @get ( \"/my-path\" ) def my_route_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } class MyPlugin ( PluginProtocol [ Any ]): def on_app_init ( self , app : Starlite ) -> None : # update app attributes app . after_request = ... app . after_response = ... app . before_request = ... app . dependencies . update ({ ... }) app . exception_handlers . update ({ ... }) app . guards . extend ( ... ) app . middleware . extend ( ... ) app . on_shutdown . extend ( ... ) app . on_startup . extend ( ... ) app . parameters . update ({ ... }) app . response_class = ... app . response_cookies . extend ( ... ) app . response_headers . update ( ... ) app . tags . extend ( ... ) # register a route handler app . register ( my_route_handler ) Parameters: Name Type Description Default app Starlite The Starlite instance. required Returns: Type Description None None","title":"on_app_init()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.is_plugin_supported_type","text":"is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin. Parameters: Name Type Description Default value Any An arbitrary value. required Returns: Type Description TypeGuard [ ModelT ] A typeguard dictating whether the value is supported by the plugin.","title":"is_plugin_supported_type()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.to_pydantic_model_class","text":"to_pydantic_model_class ( model_class , ** kwargs ) Given a model_class supported by the plugin, convert it to a subclass of the pydantic BaseModel. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required **kwargs Any Any additional kwargs. {} Returns: Type Description Type [ BaseModel ] A pydantic model class.","title":"to_pydantic_model_class()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.from_pydantic_model_instance","text":"from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required pydantic_model_instance BaseModel A pydantic model instance. required Returns: Type Description ModelT A model instance.","title":"from_pydantic_model_instance()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.to_dict","text":"to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values. Parameters: Name Type Description Default model_instance ModelT A model instance of the type supported by the plugin. required Notes This method can be async as well. Returns: Type Description Union [ Dict [ str , Any ], Awaitable [ Dict [ str , Any ]]] A string keyed dictionary of values.","title":"to_dict()"},{"location":"reference/plugins/0-plugin-protocol/#starlite.plugins.base.PluginProtocol.from_dict","text":"from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class. Parameters: Name Type Description Default model_class Type [ ModelT ] A model class supported by the plugin. required **kwargs Any A string keyed mapping of values. {} Returns: Type Description ModelT A model instance.","title":"from_dict()"},{"location":"reference/plugins/1-sqlalchemy-plugin/","text":"SQLAlchemy Plugin starlite.plugins.sql_alchemy.SQLAlchemyPlugin Bases: PluginProtocol [ DeclarativeMeta ] A Plugin for SQLAlchemy. providers_map property providers_map : Dict [ Type [ TypeEngine ], Callable [[ Union [ TypeEngine , Type [ TypeEngine ]]], Any ]] Map of SQLAlchemy column types to provider functions. This method is separated to allow for easy overriding in subclasses. Returns A dictionary mapping SQLAlchemy types to callables. __init__ __init__ ( config = None ) Initialize SQLAlchemyPlugin . Support (de)serialization and OpenAPI generation for SQLAlchemy ORM types. Parameters: Name Type Description Default config Optional [ SQLAlchemyConfig ] Optional SQLAlchemyConfig instance. If passed, the plugin will establish a DB connection and hook handlers and dependencies. None from_dict from_dict ( model_class , ** kwargs ) Given a dictionary of kwargs, return an instance of the given model_class. Parameters: Name Type Description Default model_class Type[DeclarativeMeta] A declarative table class. required **kwargs Any Kwargs to instantiate the table with. {} Returns: Type Description DeclarativeMeta An instantiated table instance. from_pydantic_model_instance from_pydantic_model_instance ( model_class , pydantic_model_instance ) Create an instance of a given model_class using the values stored in the given pydantic_model_instance. Parameters: Name Type Description Default model_class Type[DeclarativeMeta] A declarative table class. required pydantic_model_instance BaseModel A pydantic model instance. required Returns: Type Description Any A declarative meta table instance. get_pydantic_type get_pydantic_type ( column_type ) Given a 'Column.type' value, return a type supported by pydantic. Parameters: Name Type Description Default column_type Any The type of the SQLColumn. required Returns: Type Description Any A pydantic supported type. is_plugin_supported_type staticmethod is_plugin_supported_type ( value ) TypeGuard testing whether values are subclasses of SQLAlchemy's 'DeclarativeMeta' class. Parameters: Name Type Description Default value Any An arbitrary type to test. required Returns: Type Description TypeGuard[DeclarativeMeta] A boolean typeguard. on_app_init on_app_init ( app ) If config has been passed to the plugin, it will initialize SQLAlchemy and add the dependencies as expected. Executed on the application's init process. Parameters: Name Type Description Default app Starlite The Starlite application instance. required Returns: Type Description None None to_dict to_dict ( model_instance ) Given a model instance, convert it to a dict of values that can be serialized. Parameters: Name Type Description Default model_instance DeclarativeMeta An SQLAlchemy declarative table instance. required Returns: Type Description Dict [ str , Any ] A string keyed dict of values. to_pydantic_model_class to_pydantic_model_class ( model_class , ** kwargs ) Generate a pydantic model for a given SQLAlchemy declarative table and any nested relations. Parameters: Name Type Description Default model_class Type [ DeclarativeMeta ] An SQLAlchemy declarative class instance. required **kwargs Any Kwargs to pass to the model. {} Returns: Type Description Type[BaseModel] A pydantic model instance. starlite.plugins.sql_alchemy.SQLAlchemyConfig Bases: BaseModel Configuration for SQLAlchemy's sessionmaker . For details see: https://docs.sqlalchemy.org/en/14/orm/session_api.html before_send_handler class-attribute before_send_handler : BeforeMessageSendHookHandler = default_before_send_handler Handler to call before the ASGI message is sent. The handler should handle closing the session stored in the ASGI scope, if its still open, and committing and uncommitted data. connection_string class-attribute connection_string : Optional [ str ] = None Database connection string in one of the formats supported by SQLAlchemy. Notes: - For async connections, the connection string must include the correct async prefix. e.g. 'postgresql+asyncpg://...' instead of 'postgresql://', and for sync connections its the opposite. create_async_engine_callable class-attribute create_async_engine_callable : Callable [[ str ], AsyncEngine ] = create_async_engine Callable that creates an 'AsyncEngine' instance or instance of its subclass. create_engine_callable class-attribute create_engine_callable : Callable [[ str ], Union [ Engine , FutureEngine ]] = create_engine Callable that creates an 'Engine' or 'FutureEngine' instance or instance of its subclass. dependency_key class-attribute dependency_key : str = 'db_session' Key to use for the dependency injection of database sessions. engine property engine : Union [ Engine , FutureEngine , AsyncEngine ] Return an engine. If none exists yet, create one. Returns: Type Description Union [ Engine , FutureEngine , AsyncEngine ] Getter that returns the engine instance used by the plugin. engine_app_state_key class-attribute engine_app_state_key : str = 'db_engine' Key under which to store the SQLAlchemy engine in the application State instance. engine_config class-attribute engine_config : SQLAlchemyEngineConfig = SQLAlchemyEngineConfig () Configuration for the SQLAlchemy engine. The configuration options are documented in the SQLAlchemy documentation. engine_instance class-attribute engine_instance : Optional [ Union [ Engine , FutureEngine , AsyncEngine ]] = None Optional engine to use. If set, the plugin will use the provided instance rather than instantiate an engine. session_class class-attribute session_class : Optional [ Union [ Type [ Session ], Type [ AsyncSession ]]] = None The session class to use. If not set, the session class will default to 'sqlalchemy.orm.Session' for sync connections and 'sqlalchemy.ext.asyncio.AsyncSession' for async ones. session_config class-attribute session_config : SQLAlchemySessionConfig = SQLAlchemySessionConfig () Configuration options for the 'sessionmaker'. The configuration options are documented in the SQLAlchemy documentation. session_maker property session_maker : sessionmaker Get a sessionmaker. If none exists yet, create one. Returns: Type Description sessionmaker Getter that returns the session_maker instance used by the plugin. session_maker_app_state_key class-attribute session_maker_app_state_key : str = 'session_maker_class' Key under which to store the SQLAlchemy 'sessionmaker' in the application State instance. session_maker_class class-attribute session_maker_class : Type [ SessionMakerTypeProtocol ] = sessionmaker Sessionmaker class to use. session_maker_instance class-attribute session_maker_instance : Optional [ SessionMakerInstanceProtocol ] = None Optional sessionmaker to use. If set, the plugin will use the provided instance rather than instantiate a sessionmaker. starlite.plugins.sql_alchemy.SQLAlchemyEngineConfig Bases: BaseModel Configuration for SQLAlchemy's Engine . For details see: https://docs.sqlalchemy.org/en/14/core/engines.html connect_args class-attribute connect_args : Optional [ Dict [ str , Any ]] = None echo class-attribute echo : Optional [ bool ] = None echo_pool class-attribute echo_pool : Optional [ bool ] = None enable_from_linting class-attribute enable_from_linting : Optional [ bool ] = None future class-attribute future : bool = True hide_parameters class-attribute hide_parameters : Optional [ bool ] = None isolation_level class-attribute isolation_level : Optional [ IsolationLevel ] = None json_deserializer class-attribute json_deserializer : Callable [[ str ], Any ] = decode_json json_serializer class-attribute json_serializer : Callable [[ Any ], str ] = serializer label_length class-attribute label_length : Optional [ int ] = None listeners class-attribute listeners : Any = None logging_level class-attribute logging_level : Optional [ Union [ int , str ]] = None logging_name class-attribute logging_name : Optional [ str ] = None max_identifier_length class-attribute max_identifier_length : Optional [ int ] = None max_overflow class-attribute max_overflow : Optional [ int ] = None module class-attribute module : Any = None paramstyle class-attribute paramstyle : Optional [ Literal [ 'qmark' , 'numeric' , 'named' , 'format' , 'pyformat' ]] = None plugins class-attribute plugins : Optional [ List [ str ]] = None pool class-attribute pool : Optional [ Pool ] = None pool_logging_name class-attribute pool_logging_name : Optional [ str ] = None pool_pre_ping class-attribute pool_pre_ping : Optional [ bool ] = None pool_recycle class-attribute pool_recycle : Optional [ int ] = None pool_reset_on_return class-attribute pool_reset_on_return : Optional [ Literal [ 'rollback' , 'commit' ]] = None pool_size class-attribute pool_size : Optional [ int ] = None pool_timeout class-attribute pool_timeout : Optional [ int ] = None pool_use_lifo class-attribute pool_use_lifo : Optional [ bool ] = None poolclass class-attribute poolclass : Optional [ Type [ Pool ]] = None query_cache_size class-attribute query_cache_size : Optional [ int ] = None strategy class-attribute strategy : Optional [ str ] = None starlite.plugins.sql_alchemy.SQLAlchemySessionConfig Bases: BaseModel Configuration for a SQLAlchemy-Session. autocommit class-attribute autocommit : Optional [ bool ] = None autoflush class-attribute autoflush : Optional [ bool ] = None bind class-attribute bind : Optional [ Any ] = None binds class-attribute binds : Optional [ Any ] = None enable_baked_queries class-attribute enable_baked_queries : Optional [ bool ] = None expire_on_commit class-attribute expire_on_commit : bool = False future class-attribute future : Optional [ bool ] = None info class-attribute info : Optional [ Dict [ str , Any ]] = None query_cls class-attribute query_cls : Optional [ Type [ Query ]] = None twophase class-attribute twophase : Optional [ bool ] = None","title":"SQLAlchemy Plugin"},{"location":"reference/plugins/1-sqlalchemy-plugin/#sqlalchemy-plugin","text":"","title":"SQLAlchemy Plugin"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemyPlugin","text":"Bases: PluginProtocol [ DeclarativeMeta ] A Plugin for SQLAlchemy.","title":"SQLAlchemyPlugin"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.providers_map","text":"providers_map : Dict [ Type [ TypeEngine ], Callable [[ Union [ TypeEngine , Type [ TypeEngine ]]], Any ]] Map of SQLAlchemy column types to provider functions. This method is separated to allow for easy overriding in subclasses. Returns A dictionary mapping SQLAlchemy types to callables.","title":"providers_map"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.__init__","text":"__init__ ( config = None ) Initialize SQLAlchemyPlugin . Support (de)serialization and OpenAPI generation for SQLAlchemy ORM types. Parameters: Name Type Description Default config Optional [ SQLAlchemyConfig ] Optional SQLAlchemyConfig instance. If passed, the plugin will establish a DB connection and hook handlers and dependencies. None","title":"__init__()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.from_dict","text":"from_dict ( model_class , ** kwargs ) Given a dictionary of kwargs, return an instance of the given model_class. Parameters: Name Type Description Default model_class Type[DeclarativeMeta] A declarative table class. required **kwargs Any Kwargs to instantiate the table with. {} Returns: Type Description DeclarativeMeta An instantiated table instance.","title":"from_dict()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.from_pydantic_model_instance","text":"from_pydantic_model_instance ( model_class , pydantic_model_instance ) Create an instance of a given model_class using the values stored in the given pydantic_model_instance. Parameters: Name Type Description Default model_class Type[DeclarativeMeta] A declarative table class. required pydantic_model_instance BaseModel A pydantic model instance. required Returns: Type Description Any A declarative meta table instance.","title":"from_pydantic_model_instance()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.get_pydantic_type","text":"get_pydantic_type ( column_type ) Given a 'Column.type' value, return a type supported by pydantic. Parameters: Name Type Description Default column_type Any The type of the SQLColumn. required Returns: Type Description Any A pydantic supported type.","title":"get_pydantic_type()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.is_plugin_supported_type","text":"is_plugin_supported_type ( value ) TypeGuard testing whether values are subclasses of SQLAlchemy's 'DeclarativeMeta' class. Parameters: Name Type Description Default value Any An arbitrary type to test. required Returns: Type Description TypeGuard[DeclarativeMeta] A boolean typeguard.","title":"is_plugin_supported_type()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.on_app_init","text":"on_app_init ( app ) If config has been passed to the plugin, it will initialize SQLAlchemy and add the dependencies as expected. Executed on the application's init process. Parameters: Name Type Description Default app Starlite The Starlite application instance. required Returns: Type Description None None","title":"on_app_init()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.to_dict","text":"to_dict ( model_instance ) Given a model instance, convert it to a dict of values that can be serialized. Parameters: Name Type Description Default model_instance DeclarativeMeta An SQLAlchemy declarative table instance. required Returns: Type Description Dict [ str , Any ] A string keyed dict of values.","title":"to_dict()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.plugin.SQLAlchemyPlugin.to_pydantic_model_class","text":"to_pydantic_model_class ( model_class , ** kwargs ) Generate a pydantic model for a given SQLAlchemy declarative table and any nested relations. Parameters: Name Type Description Default model_class Type [ DeclarativeMeta ] An SQLAlchemy declarative class instance. required **kwargs Any Kwargs to pass to the model. {} Returns: Type Description Type[BaseModel] A pydantic model instance.","title":"to_pydantic_model_class()"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemyConfig","text":"Bases: BaseModel Configuration for SQLAlchemy's sessionmaker . For details see: https://docs.sqlalchemy.org/en/14/orm/session_api.html","title":"SQLAlchemyConfig"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.before_send_handler","text":"before_send_handler : BeforeMessageSendHookHandler = default_before_send_handler Handler to call before the ASGI message is sent. The handler should handle closing the session stored in the ASGI scope, if its still open, and committing and uncommitted data.","title":"before_send_handler"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.connection_string","text":"connection_string : Optional [ str ] = None Database connection string in one of the formats supported by SQLAlchemy. Notes: - For async connections, the connection string must include the correct async prefix. e.g. 'postgresql+asyncpg://...' instead of 'postgresql://', and for sync connections its the opposite.","title":"connection_string"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.create_async_engine_callable","text":"create_async_engine_callable : Callable [[ str ], AsyncEngine ] = create_async_engine Callable that creates an 'AsyncEngine' instance or instance of its subclass.","title":"create_async_engine_callable"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.create_engine_callable","text":"create_engine_callable : Callable [[ str ], Union [ Engine , FutureEngine ]] = create_engine Callable that creates an 'Engine' or 'FutureEngine' instance or instance of its subclass.","title":"create_engine_callable"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.dependency_key","text":"dependency_key : str = 'db_session' Key to use for the dependency injection of database sessions.","title":"dependency_key"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine","text":"engine : Union [ Engine , FutureEngine , AsyncEngine ] Return an engine. If none exists yet, create one. Returns: Type Description Union [ Engine , FutureEngine , AsyncEngine ] Getter that returns the engine instance used by the plugin.","title":"engine"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine_app_state_key","text":"engine_app_state_key : str = 'db_engine' Key under which to store the SQLAlchemy engine in the application State instance.","title":"engine_app_state_key"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine_config","text":"engine_config : SQLAlchemyEngineConfig = SQLAlchemyEngineConfig () Configuration for the SQLAlchemy engine. The configuration options are documented in the SQLAlchemy documentation.","title":"engine_config"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.engine_instance","text":"engine_instance : Optional [ Union [ Engine , FutureEngine , AsyncEngine ]] = None Optional engine to use. If set, the plugin will use the provided instance rather than instantiate an engine.","title":"engine_instance"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_class","text":"session_class : Optional [ Union [ Type [ Session ], Type [ AsyncSession ]]] = None The session class to use. If not set, the session class will default to 'sqlalchemy.orm.Session' for sync connections and 'sqlalchemy.ext.asyncio.AsyncSession' for async ones.","title":"session_class"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_config","text":"session_config : SQLAlchemySessionConfig = SQLAlchemySessionConfig () Configuration options for the 'sessionmaker'. The configuration options are documented in the SQLAlchemy documentation.","title":"session_config"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker","text":"session_maker : sessionmaker Get a sessionmaker. If none exists yet, create one. Returns: Type Description sessionmaker Getter that returns the session_maker instance used by the plugin.","title":"session_maker"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker_app_state_key","text":"session_maker_app_state_key : str = 'session_maker_class' Key under which to store the SQLAlchemy 'sessionmaker' in the application State instance.","title":"session_maker_app_state_key"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker_class","text":"session_maker_class : Type [ SessionMakerTypeProtocol ] = sessionmaker Sessionmaker class to use.","title":"session_maker_class"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyConfig.session_maker_instance","text":"session_maker_instance : Optional [ SessionMakerInstanceProtocol ] = None Optional sessionmaker to use. If set, the plugin will use the provided instance rather than instantiate a sessionmaker.","title":"session_maker_instance"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemyEngineConfig","text":"Bases: BaseModel Configuration for SQLAlchemy's Engine . For details see: https://docs.sqlalchemy.org/en/14/core/engines.html","title":"SQLAlchemyEngineConfig"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.connect_args","text":"connect_args : Optional [ Dict [ str , Any ]] = None","title":"connect_args"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.echo","text":"echo : Optional [ bool ] = None","title":"echo"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.echo_pool","text":"echo_pool : Optional [ bool ] = None","title":"echo_pool"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.enable_from_linting","text":"enable_from_linting : Optional [ bool ] = None","title":"enable_from_linting"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.future","text":"future : bool = True","title":"future"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.hide_parameters","text":"hide_parameters : Optional [ bool ] = None","title":"hide_parameters"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.isolation_level","text":"isolation_level : Optional [ IsolationLevel ] = None","title":"isolation_level"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.json_deserializer","text":"json_deserializer : Callable [[ str ], Any ] = decode_json","title":"json_deserializer"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.json_serializer","text":"json_serializer : Callable [[ Any ], str ] = serializer","title":"json_serializer"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.label_length","text":"label_length : Optional [ int ] = None","title":"label_length"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.listeners","text":"listeners : Any = None","title":"listeners"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.logging_level","text":"logging_level : Optional [ Union [ int , str ]] = None","title":"logging_level"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.logging_name","text":"logging_name : Optional [ str ] = None","title":"logging_name"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.max_identifier_length","text":"max_identifier_length : Optional [ int ] = None","title":"max_identifier_length"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.max_overflow","text":"max_overflow : Optional [ int ] = None","title":"max_overflow"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.module","text":"module : Any = None","title":"module"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.paramstyle","text":"paramstyle : Optional [ Literal [ 'qmark' , 'numeric' , 'named' , 'format' , 'pyformat' ]] = None","title":"paramstyle"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.plugins","text":"plugins : Optional [ List [ str ]] = None","title":"plugins"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool","text":"pool : Optional [ Pool ] = None","title":"pool"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_logging_name","text":"pool_logging_name : Optional [ str ] = None","title":"pool_logging_name"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_pre_ping","text":"pool_pre_ping : Optional [ bool ] = None","title":"pool_pre_ping"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_recycle","text":"pool_recycle : Optional [ int ] = None","title":"pool_recycle"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_reset_on_return","text":"pool_reset_on_return : Optional [ Literal [ 'rollback' , 'commit' ]] = None","title":"pool_reset_on_return"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_size","text":"pool_size : Optional [ int ] = None","title":"pool_size"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_timeout","text":"pool_timeout : Optional [ int ] = None","title":"pool_timeout"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.pool_use_lifo","text":"pool_use_lifo : Optional [ bool ] = None","title":"pool_use_lifo"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.poolclass","text":"poolclass : Optional [ Type [ Pool ]] = None","title":"poolclass"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.query_cache_size","text":"query_cache_size : Optional [ int ] = None","title":"query_cache_size"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemyEngineConfig.strategy","text":"strategy : Optional [ str ] = None","title":"strategy"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.SQLAlchemySessionConfig","text":"Bases: BaseModel Configuration for a SQLAlchemy-Session.","title":"SQLAlchemySessionConfig"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.autocommit","text":"autocommit : Optional [ bool ] = None","title":"autocommit"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.autoflush","text":"autoflush : Optional [ bool ] = None","title":"autoflush"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.bind","text":"bind : Optional [ Any ] = None","title":"bind"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.binds","text":"binds : Optional [ Any ] = None","title":"binds"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.enable_baked_queries","text":"enable_baked_queries : Optional [ bool ] = None","title":"enable_baked_queries"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.expire_on_commit","text":"expire_on_commit : bool = False","title":"expire_on_commit"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.future","text":"future : Optional [ bool ] = None","title":"future"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.info","text":"info : Optional [ Dict [ str , Any ]] = None","title":"info"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.query_cls","text":"query_cls : Optional [ Type [ Query ]] = None","title":"query_cls"},{"location":"reference/plugins/1-sqlalchemy-plugin/#starlite.plugins.sql_alchemy.config.SQLAlchemySessionConfig.twophase","text":"twophase : Optional [ bool ] = None","title":"twophase"},{"location":"reference/plugins/2-piccolo-orm-plugin/","text":"PiccoloORM Plugin starlite.plugins.piccolo_orm.PiccoloORMPlugin Bases: PluginProtocol [ Table ] Support (de)serialization and OpenAPI generation for Piccolo ORM types. from_dict from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class. from_pydantic_model_instance from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. is_plugin_supported_type staticmethod is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin. to_dict to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values. to_pydantic_model_class to_pydantic_model_class ( model_class , ** kwargs ) Given a piccolo model_class instance, convert it to a subclass of the piccolo \"BaseModel\". Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in piccolo-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized. This function uses memoization to ensure we don't recompute unnecessarily.","title":"PiccoloORM Plugin"},{"location":"reference/plugins/2-piccolo-orm-plugin/#piccoloorm-plugin","text":"","title":"PiccoloORM Plugin"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin","text":"Bases: PluginProtocol [ Table ] Support (de)serialization and OpenAPI generation for Piccolo ORM types.","title":"PiccoloORMPlugin"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.from_dict","text":"from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class.","title":"from_dict()"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.from_pydantic_model_instance","text":"from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg.","title":"from_pydantic_model_instance()"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.is_plugin_supported_type","text":"is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin.","title":"is_plugin_supported_type()"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.to_dict","text":"to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values.","title":"to_dict()"},{"location":"reference/plugins/2-piccolo-orm-plugin/#starlite.plugins.piccolo_orm.PiccoloORMPlugin.to_pydantic_model_class","text":"to_pydantic_model_class ( model_class , ** kwargs ) Given a piccolo model_class instance, convert it to a subclass of the piccolo \"BaseModel\". Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in piccolo-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized. This function uses memoization to ensure we don't recompute unnecessarily.","title":"to_pydantic_model_class()"},{"location":"reference/plugins/3-tortoise-orm-plugin/","text":"TortoiseORM Plugin starlite.plugins.tortoise_orm.TortoiseORMPlugin Bases: PluginProtocol [ Model ] Support (de)serialization and OpenAPI generation for Tortoise ORMtypes. from_dict from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class. from_pydantic_model_instance from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. is_plugin_supported_type staticmethod is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin. to_dict async to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values. to_pydantic_model_class to_pydantic_model_class ( model_class , ** kwargs ) Given a tortoise model_class instance, convert it to a subclass of the tortoise PydanticModel. Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in tortoise-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized. This function uses memoization to ensure we don't recompute unnecessarily.","title":"TortoiseORM Plugin"},{"location":"reference/plugins/3-tortoise-orm-plugin/#tortoiseorm-plugin","text":"","title":"TortoiseORM Plugin"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin","text":"Bases: PluginProtocol [ Model ] Support (de)serialization and OpenAPI generation for Tortoise ORMtypes.","title":"TortoiseORMPlugin"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.from_dict","text":"from_dict ( model_class , ** kwargs ) Given a class supported by this plugin and a dict of values, create an instance of the class.","title":"from_dict()"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.from_pydantic_model_instance","text":"from_pydantic_model_instance ( model_class , pydantic_model_instance ) Given an instance of a pydantic model created using the plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg.","title":"from_pydantic_model_instance()"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.is_plugin_supported_type","text":"is_plugin_supported_type ( value ) Given a value of indeterminate type, determine if this value is supported by the plugin.","title":"is_plugin_supported_type()"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.to_dict","text":"to_dict ( model_instance ) Given an instance of a model supported by the plugin, return a dictionary of serializable values.","title":"to_dict()"},{"location":"reference/plugins/3-tortoise-orm-plugin/#starlite.plugins.tortoise_orm.TortoiseORMPlugin.to_pydantic_model_class","text":"to_pydantic_model_class ( model_class , ** kwargs ) Given a tortoise model_class instance, convert it to a subclass of the tortoise PydanticModel. Since incoming request body's cannot and should not include values for related fields, pk fields and read only fields in tortoise-orm, we generate two different kinds of pydantic models here: - the first is a regular pydantic model, and the other is for the \"data\" kwarg only, which is further sanitized. This function uses memoization to ensure we don't recompute unnecessarily.","title":"to_pydantic_model_class()"},{"location":"reference/response/0-base/","text":"Base HTTP Response starlite.response.Response Bases: Generic [ T ] Base Starlite HTTP response class, used as the basis for all other response classes. content_length property content_length : int Content length of the response if applicable. Returns: Type Description int The content length of the body (e.g. for use in a \"Content-Length\" header). int If the response does not have a body, this value is None __init__ __init__ ( content , * , status_code = HTTP_200_OK , media_type = MediaType . JSON , background = None , headers = None , cookies = None , encoding = \"utf-8\" , is_head_response = False ) Initialize the response. Parameters: Name Type Description Default content T A value for the response body that will be rendered into bytes string. required status_code int An HTTP status code. HTTP_200_OK media_type Union [ MediaType , OpenAPIMediaType , str ] A value for the response 'Content-Type' header. MediaType.JSON background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str The encoding to be used for the response headers. 'utf-8' is_head_response bool Whether the response should send only the headers (\"head\" request) or also the content. False __call__ async __call__ ( scope , receive , send ) ASGI callable of the Response . Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. required send Send The ASGI send function. required Returns: Type Description None None after_response async after_response () Execute after the response is sent. Returns: Type Description None None delete_cookie delete_cookie ( key , path = '/' , domain = None ) Delete a cookie. Parameters: Name Type Description Default key str Key of the cookie. required path str Path of the cookie. '/' domain Optional [ str ] Domain of the cookie. None Returns: Type Description None None. encode_headers encode_headers () Encode the response headers as a list of byte tuples. Notes A 'Content-Length' header will be added if appropriate and not provided by the user. Returns: Type Description List [ Tuple [ bytes , bytes ]] A list of tuples containing the headers and cookies of the request in a format ready for ASGI transmission. render render ( content ) Handle the rendering of content T into a bytes string. Parameters: Name Type Description Default content Any A value for the response body that will be rendered into bytes string. required Returns: Type Description bytes An encoded bytes string send_body async send_body ( send , receive ) Emit the response body. Parameters: Name Type Description Default send Send The ASGI send function. required receive Receive The ASGI receive function. required Notes Response subclasses should customize this method if there is a need to customize sending data. Returns: Type Description None None serializer classmethod serializer ( value ) Transform non-natively supported types into supported types using Response.type_encoders . Should raise TypeError if a type cannot be transformed into a supported type set_cookie set_cookie ( key , value = None , max_age = None , expires = None , path = \"/\" , domain = None , secure = False , httponly = False , samesite = \"lax\" , ) Set a cookie on the response. If passed a Cookie instance, keyword arguments will be ignored. Parameters: Name Type Description Default key Union [ str , Cookie ] Key for the cookie or a Cookie instance. required value Optional [ str ] Value for the cookie, if none given defaults to empty string. None max_age Optional [ int ] Maximal age of the cookie before its invalidated. None expires Optional [ int ] Expiration date as unix MS timestamp. None path str Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'. '/' domain Optional [ str ] Domain for which the cookie is valid. None secure bool Https is required for the cookie. False httponly bool Forbids javascript to access the cookie via 'Document.cookie'. False samesite Literal ['lax', 'strict', 'none'] Controls whether a cookie is sent with cross-site requests. Defaults to 'lax'. 'lax' Returns: Type Description None None. set_etag set_etag ( etag ) Set an etag header. Parameters: Name Type Description Default etag Union [ str , ETag ] An etag value. required Returns: Type Description None None set_header set_header ( key , value ) Set a header on the response. Parameters: Name Type Description Default key str Header key. required value str Header value. required Returns: Type Description None None. start_response async start_response ( send ) Emit the start event of the response. This event includes the headers and status codes. Parameters: Name Type Description Default send Send The ASGI send function. required Returns: Type Description None None","title":"Base HTTP Response"},{"location":"reference/response/0-base/#base-http-response","text":"","title":"Base HTTP Response"},{"location":"reference/response/0-base/#starlite.response.Response","text":"Bases: Generic [ T ] Base Starlite HTTP response class, used as the basis for all other response classes.","title":"Response"},{"location":"reference/response/0-base/#starlite.response.base.Response.content_length","text":"content_length : int Content length of the response if applicable. Returns: Type Description int The content length of the body (e.g. for use in a \"Content-Length\" header). int If the response does not have a body, this value is None","title":"content_length"},{"location":"reference/response/0-base/#starlite.response.base.Response.__init__","text":"__init__ ( content , * , status_code = HTTP_200_OK , media_type = MediaType . JSON , background = None , headers = None , cookies = None , encoding = \"utf-8\" , is_head_response = False ) Initialize the response. Parameters: Name Type Description Default content T A value for the response body that will be rendered into bytes string. required status_code int An HTTP status code. HTTP_200_OK media_type Union [ MediaType , OpenAPIMediaType , str ] A value for the response 'Content-Type' header. MediaType.JSON background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str The encoding to be used for the response headers. 'utf-8' is_head_response bool Whether the response should send only the headers (\"head\" request) or also the content. False","title":"__init__()"},{"location":"reference/response/0-base/#starlite.response.base.Response.__call__","text":"__call__ ( scope , receive , send ) ASGI callable of the Response . Parameters: Name Type Description Default scope Scope The ASGI connection scope. required receive Receive The ASGI receive function. required send Send The ASGI send function. required Returns: Type Description None None","title":"__call__()"},{"location":"reference/response/0-base/#starlite.response.base.Response.after_response","text":"after_response () Execute after the response is sent. Returns: Type Description None None","title":"after_response()"},{"location":"reference/response/0-base/#starlite.response.base.Response.delete_cookie","text":"delete_cookie ( key , path = '/' , domain = None ) Delete a cookie. Parameters: Name Type Description Default key str Key of the cookie. required path str Path of the cookie. '/' domain Optional [ str ] Domain of the cookie. None Returns: Type Description None None.","title":"delete_cookie()"},{"location":"reference/response/0-base/#starlite.response.base.Response.encode_headers","text":"encode_headers () Encode the response headers as a list of byte tuples. Notes A 'Content-Length' header will be added if appropriate and not provided by the user. Returns: Type Description List [ Tuple [ bytes , bytes ]] A list of tuples containing the headers and cookies of the request in a format ready for ASGI transmission.","title":"encode_headers()"},{"location":"reference/response/0-base/#starlite.response.base.Response.render","text":"render ( content ) Handle the rendering of content T into a bytes string. Parameters: Name Type Description Default content Any A value for the response body that will be rendered into bytes string. required Returns: Type Description bytes An encoded bytes string","title":"render()"},{"location":"reference/response/0-base/#starlite.response.base.Response.send_body","text":"send_body ( send , receive ) Emit the response body. Parameters: Name Type Description Default send Send The ASGI send function. required receive Receive The ASGI receive function. required Notes Response subclasses should customize this method if there is a need to customize sending data. Returns: Type Description None None","title":"send_body()"},{"location":"reference/response/0-base/#starlite.response.base.Response.serializer","text":"serializer ( value ) Transform non-natively supported types into supported types using Response.type_encoders . Should raise TypeError if a type cannot be transformed into a supported type","title":"serializer()"},{"location":"reference/response/0-base/#starlite.response.base.Response.set_cookie","text":"set_cookie ( key , value = None , max_age = None , expires = None , path = \"/\" , domain = None , secure = False , httponly = False , samesite = \"lax\" , ) Set a cookie on the response. If passed a Cookie instance, keyword arguments will be ignored. Parameters: Name Type Description Default key Union [ str , Cookie ] Key for the cookie or a Cookie instance. required value Optional [ str ] Value for the cookie, if none given defaults to empty string. None max_age Optional [ int ] Maximal age of the cookie before its invalidated. None expires Optional [ int ] Expiration date as unix MS timestamp. None path str Path fragment that must exist in the request url for the cookie to be valid. Defaults to '/'. '/' domain Optional [ str ] Domain for which the cookie is valid. None secure bool Https is required for the cookie. False httponly bool Forbids javascript to access the cookie via 'Document.cookie'. False samesite Literal ['lax', 'strict', 'none'] Controls whether a cookie is sent with cross-site requests. Defaults to 'lax'. 'lax' Returns: Type Description None None.","title":"set_cookie()"},{"location":"reference/response/0-base/#starlite.response.base.Response.set_etag","text":"set_etag ( etag ) Set an etag header. Parameters: Name Type Description Default etag Union [ str , ETag ] An etag value. required Returns: Type Description None None","title":"set_etag()"},{"location":"reference/response/0-base/#starlite.response.base.Response.set_header","text":"set_header ( key , value ) Set a header on the response. Parameters: Name Type Description Default key str Header key. required value str Header value. required Returns: Type Description None None.","title":"set_header()"},{"location":"reference/response/0-base/#starlite.response.base.Response.start_response","text":"start_response ( send ) Emit the start event of the response. This event includes the headers and status codes. Parameters: Name Type Description Default send Send The ASGI send function. required Returns: Type Description None None","title":"start_response()"},{"location":"reference/response/1-streaming/","text":"Streaming Response starlite.response.StreamingResponse Bases: Response [ StreamType [ Union [ str , bytes ]]] An HTTP response that streams the response data as a series of ASGI 'http.response.body' events. __init__ __init__ ( content , * , status_code = HTTP_200_OK , media_type = MediaType . JSON , background = None , headers = None , cookies = None , encoding = \"utf-8\" , is_head_response = False ) Initialize the response. Parameters: Name Type Description Default content StreamType [ Union [ str , bytes ]] A sync or async iterator or iterable. required status_code int An HTTP status code. HTTP_200_OK media_type Union [ MediaType , OpenAPIMediaType , str ] A value for the response 'Content-Type' header. MediaType.JSON background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str The encoding to be used for the response headers. 'utf-8' is_head_response bool Whether the response should send only the headers (\"head\" request) or also the content. False send_body async send_body ( send , receive ) Emit a stream of events correlating with the response body. Parameters: Name Type Description Default send Send The ASGI send function. required receive Receive The ASGI receive function. required Returns: Type Description None None","title":"Streaming Response"},{"location":"reference/response/1-streaming/#streaming-response","text":"","title":"Streaming Response"},{"location":"reference/response/1-streaming/#starlite.response.StreamingResponse","text":"Bases: Response [ StreamType [ Union [ str , bytes ]]] An HTTP response that streams the response data as a series of ASGI 'http.response.body' events.","title":"StreamingResponse"},{"location":"reference/response/1-streaming/#starlite.response.streaming.StreamingResponse.__init__","text":"__init__ ( content , * , status_code = HTTP_200_OK , media_type = MediaType . JSON , background = None , headers = None , cookies = None , encoding = \"utf-8\" , is_head_response = False ) Initialize the response. Parameters: Name Type Description Default content StreamType [ Union [ str , bytes ]] A sync or async iterator or iterable. required status_code int An HTTP status code. HTTP_200_OK media_type Union [ MediaType , OpenAPIMediaType , str ] A value for the response 'Content-Type' header. MediaType.JSON background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str The encoding to be used for the response headers. 'utf-8' is_head_response bool Whether the response should send only the headers (\"head\" request) or also the content. False","title":"__init__()"},{"location":"reference/response/1-streaming/#starlite.response.streaming.StreamingResponse.send_body","text":"send_body ( send , receive ) Emit a stream of events correlating with the response body. Parameters: Name Type Description Default send Send The ASGI send function. required receive Receive The ASGI receive function. required Returns: Type Description None None","title":"send_body()"},{"location":"reference/response/2-file/","text":"File Response starlite.response.FileResponse Bases: StreamingResponse A response, streaming a file as response body. content_length property content_length : int Content length of the response if applicable. Returns: Type Description int Returns the value of 'self.stat_result.st_size' to populate the 'Content-Length' header. __init__ __init__ ( path , * , background = None , chunk_size = ONE_MEGABYTE , content_disposition_type = \"attachment\" , cookies = None , encoding = \"utf-8\" , etag = None , file_system = None , filename = None , file_info = None , headers = None , is_head_response = False , media_type = None , stat_result = None , status_code = HTTP_200_OK ) Initialize FileResponse Notes This class extends the StreamingResponse class. Parameters: Name Type Description Default path Union [ str , PathLike , Path ] A file path in one of the supported formats. required status_code int An HTTP status code. HTTP_200_OK media_type Optional [ Union [ Literal [ MediaType . TEXT ], str ]] A value for the response 'Content-Type' header. If not provided, the value will be either derived from the filename if provided and supported by the stdlib, or will default to 'application/octet-stream'. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str The encoding to be used for the response headers. 'utf-8' is_head_response bool Whether the response should send only the headers (\"head\" request) or also the content. False filename Optional [ str ] An optional filename to set in the header. None stat_result Optional [ stat_result_type ] An optional result of calling 'os.stat'. If not provided, this will be done by the response constructor. None chunk_size int The chunk sizes to use when streaming the file. Defaults to 1MB. ONE_MEGABYTE content_disposition_type Literal ['attachment', 'inline'] The type of the 'Content-Disposition'. Either 'inline' or 'attachment'. 'attachment' etag Optional [ ETag ] An optional ETag instance. If not provided, an etag will be automatically generated. None file_system Optional [ FileSystemProtocol ] An implementation of the `FileSystemProtocol . If provided it will be used to load the file. None file_info Optional [ FileInfo ] The output of calling file_system.info(..) , equivalent to providing a stat_result . None send_body async send_body ( send , receive ) Emit a stream of events correlating with the response body. Parameters: Name Type Description Default send Send The ASGI send function. required receive Receive The ASGI receive function. required Returns: Type Description None None start_response async start_response ( send ) Emit the start event of the response. This event includes the headers and status codes. Parameters: Name Type Description Default send Send The ASGI send function. required Returns: Type Description None None","title":"File Response"},{"location":"reference/response/2-file/#file-response","text":"","title":"File Response"},{"location":"reference/response/2-file/#starlite.response.FileResponse","text":"Bases: StreamingResponse A response, streaming a file as response body.","title":"FileResponse"},{"location":"reference/response/2-file/#starlite.response.file.FileResponse.content_length","text":"content_length : int Content length of the response if applicable. Returns: Type Description int Returns the value of 'self.stat_result.st_size' to populate the 'Content-Length' header.","title":"content_length"},{"location":"reference/response/2-file/#starlite.response.file.FileResponse.__init__","text":"__init__ ( path , * , background = None , chunk_size = ONE_MEGABYTE , content_disposition_type = \"attachment\" , cookies = None , encoding = \"utf-8\" , etag = None , file_system = None , filename = None , file_info = None , headers = None , is_head_response = False , media_type = None , stat_result = None , status_code = HTTP_200_OK ) Initialize FileResponse Notes This class extends the StreamingResponse class. Parameters: Name Type Description Default path Union [ str , PathLike , Path ] A file path in one of the supported formats. required status_code int An HTTP status code. HTTP_200_OK media_type Optional [ Union [ Literal [ MediaType . TEXT ], str ]] A value for the response 'Content-Type' header. If not provided, the value will be either derived from the filename if provided and supported by the stdlib, or will default to 'application/octet-stream'. None background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str The encoding to be used for the response headers. 'utf-8' is_head_response bool Whether the response should send only the headers (\"head\" request) or also the content. False filename Optional [ str ] An optional filename to set in the header. None stat_result Optional [ stat_result_type ] An optional result of calling 'os.stat'. If not provided, this will be done by the response constructor. None chunk_size int The chunk sizes to use when streaming the file. Defaults to 1MB. ONE_MEGABYTE content_disposition_type Literal ['attachment', 'inline'] The type of the 'Content-Disposition'. Either 'inline' or 'attachment'. 'attachment' etag Optional [ ETag ] An optional ETag instance. If not provided, an etag will be automatically generated. None file_system Optional [ FileSystemProtocol ] An implementation of the `FileSystemProtocol . If provided it will be used to load the file. None file_info Optional [ FileInfo ] The output of calling file_system.info(..) , equivalent to providing a stat_result . None","title":"__init__()"},{"location":"reference/response/2-file/#starlite.response.file.FileResponse.send_body","text":"send_body ( send , receive ) Emit a stream of events correlating with the response body. Parameters: Name Type Description Default send Send The ASGI send function. required receive Receive The ASGI receive function. required Returns: Type Description None None","title":"send_body()"},{"location":"reference/response/2-file/#starlite.response.file.FileResponse.start_response","text":"start_response ( send ) Emit the start event of the response. This event includes the headers and status codes. Parameters: Name Type Description Default send Send The ASGI send function. required Returns: Type Description None None","title":"start_response()"},{"location":"reference/response/3-template/","text":"Template Response starlite.response.TemplateResponse Bases: Response [ bytes ] Template-based response, rendering a given template into a bytes string. __init__ __init__ ( template_name , * , template_engine , context , status_code = HTTP_200_OK , background = None , headers = None , cookies = None , encoding = \"utf-8\" , media_type = MediaType . HTML ) Handle the rendering of a given template into a bytes string. Parameters: Name Type Description Default template_name str Path-like name for the template to be rendered, e.g. \"index.html\". required template_engine TemplateEngineProtocol The template engine class to use to render the response. required status_code int A value for the response HTTP status code. HTTP_200_OK context Dict [ str , Any ] A dictionary of key/value pairs to be passed to the temple engine's render method. required background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str Content encoding 'utf-8' media_type Union [ MediaType , str ] A string or member of the MediaType enum. If not set, try to infer the media type based on the template name. If this fails, fall back to text/plain . MediaType.HTML","title":"Template Response"},{"location":"reference/response/3-template/#template-response","text":"","title":"Template Response"},{"location":"reference/response/3-template/#starlite.response.TemplateResponse","text":"Bases: Response [ bytes ] Template-based response, rendering a given template into a bytes string.","title":"TemplateResponse"},{"location":"reference/response/3-template/#starlite.response.template.TemplateResponse.__init__","text":"__init__ ( template_name , * , template_engine , context , status_code = HTTP_200_OK , background = None , headers = None , cookies = None , encoding = \"utf-8\" , media_type = MediaType . HTML ) Handle the rendering of a given template into a bytes string. Parameters: Name Type Description Default template_name str Path-like name for the template to be rendered, e.g. \"index.html\". required template_engine TemplateEngineProtocol The template engine class to use to render the response. required status_code int A value for the response HTTP status code. HTTP_200_OK context Dict [ str , Any ] A dictionary of key/value pairs to be passed to the temple engine's render method. required background Optional [ Union [ BackgroundTask , BackgroundTasks ]] A BackgroundTask instance or BackgroundTasks to execute after the response is finished. Defaults to None. None headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str Content encoding 'utf-8' media_type Union [ MediaType , str ] A string or member of the MediaType enum. If not set, try to infer the media type based on the template name. If this fails, fall back to text/plain . MediaType.HTML","title":"__init__()"},{"location":"reference/response/4-redirect/","text":"Redirect Response starlite.response.RedirectResponse Bases: Response [ Any ] A redirect response. __init__ __init__ ( url , * , status_code = HTTP_307_TEMPORARY_REDIRECT , background = None , headers = None , cookies = None , encoding = \"utf-8\" ) Initialize the response. Parameters: Name Type Description Default url str A url to redirect to. required status_code Literal [301, 302, 303, 307, 308] An HTTP status code. The status code should be one of 301, 302, 303, 307 or 308, otherwise an exception will be raised. . HTTP_307_TEMPORARY_REDIRECT headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str The encoding to be used for the response headers. 'utf-8' Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] If status code is not a redirect status code.","title":"Redirect Response"},{"location":"reference/response/4-redirect/#redirect-response","text":"","title":"Redirect Response"},{"location":"reference/response/4-redirect/#starlite.response.RedirectResponse","text":"Bases: Response [ Any ] A redirect response.","title":"RedirectResponse"},{"location":"reference/response/4-redirect/#starlite.response.redirect.RedirectResponse.__init__","text":"__init__ ( url , * , status_code = HTTP_307_TEMPORARY_REDIRECT , background = None , headers = None , cookies = None , encoding = \"utf-8\" ) Initialize the response. Parameters: Name Type Description Default url str A url to redirect to. required status_code Literal [301, 302, 303, 307, 308] An HTTP status code. The status code should be one of 301, 302, 303, 307 or 308, otherwise an exception will be raised. . HTTP_307_TEMPORARY_REDIRECT headers Optional [ Dict [ str , Any ]] A string keyed dictionary of response headers. Header keys are insensitive. None cookies Optional [ ResponseCookies ] A list of Cookie instances to be set under the response 'Set-Cookie' header. None encoding str The encoding to be used for the response headers. 'utf-8' Raises: Type Description [ ImproperlyConfiguredException ][ starlite . exceptions . ImproperlyConfiguredException ] If status code is not a redirect status code.","title":"__init__()"},{"location":"reference/security/0-base/","text":"Security Config starlite.security.AbstractSecurityConfig Bases: ABC , Generic [ UserType , AuthType ] , GenericModel A base class for Security Configs - this class can be used on the application level or be manually configured on the router / controller level to provide auth. authentication_middleware_class class-attribute authentication_middleware_class : Type [ AbstractAuthenticationMiddleware ] The authentication middleware class to use. Must inherit from AbstractAuthenticationMiddleware dependencies class-attribute dependencies : Optional [ Dict [ str , Provide ]] = None An optional dictionary of dependency providers. exclude class-attribute exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the authentication middleware. exclude_opt_key class-attribute exclude_opt_key : str = 'exclude_from_auth' An identifier to use on routes to disable authentication and authorization checks for a particular route. guards class-attribute guards : Optional [ Iterable [ Guard ]] = None An iterable of guards to call for requests, providing authorization functionalities. middleware property abstractmethod middleware : DefineMiddleware Create an instance of the config's 'authentication_middleware_class' attribute and any required kwargs, wrapping it in Starlite's DefineMiddleware . Returns: Type Description DefineMiddleware An instance of DefineMiddleware . openapi_components property abstractmethod openapi_components : Components Create OpenAPI documentation for the JWT auth schema used. Returns: Type Description Components An Components instance. retrieve_user_handler class-attribute retrieve_user_handler : Callable [[ Any , ASGIConnection ], SyncOrAsyncUnion [ Optional [ Any ]]] Callable that receives the 'auth' value from the authentication middleware and returns a 'user' value. Notes: - User and Auth can be any arbitrary values specified by the security backend. - The User and Auth values will be set by the middleware as scope[\"user\"] and scope[\"auth\"] respectively. Once provided, they can access via the connection.user and connection.auth properties. - The callable can be sync or async. If it is sync, it will be wrapped to support async. route_handlers class-attribute route_handlers : Optional [ Iterable [ ControllerRouterHandler ]] = None An optional iterable of route handlers to register. scopes class-attribute scopes : Optional [ Scopes ] = None ASGI scopes processed by the authentication middleware, if None both 'http' and 'websocket' will be processed. security_requirement property abstractmethod security_requirement : SecurityRequirement Return OpenAPI 3.1. SecurityRequirement for the auth backend. Returns: Type Description SecurityRequirement An OpenAPI 3.1 SecurityRequirement dictionary. on_app_init on_app_init ( app_config ) Handle app init by injecting middleware, guards etc. into the app. This method can be used only on the app level. Parameters: Name Type Description Default app_config AppConfig An instance of AppConfig required Returns: Type Description AppConfig The AppConfig .","title":"Security Config"},{"location":"reference/security/0-base/#security-config","text":"","title":"Security Config"},{"location":"reference/security/0-base/#starlite.security.AbstractSecurityConfig","text":"Bases: ABC , Generic [ UserType , AuthType ] , GenericModel A base class for Security Configs - this class can be used on the application level or be manually configured on the router / controller level to provide auth.","title":"AbstractSecurityConfig"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.authentication_middleware_class","text":"authentication_middleware_class : Type [ AbstractAuthenticationMiddleware ] The authentication middleware class to use. Must inherit from AbstractAuthenticationMiddleware","title":"authentication_middleware_class"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.dependencies","text":"dependencies : Optional [ Dict [ str , Provide ]] = None An optional dictionary of dependency providers.","title":"dependencies"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.exclude","text":"exclude : Optional [ Union [ str , List [ str ]]] = None A pattern or list of patterns to skip in the authentication middleware.","title":"exclude"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.exclude_opt_key","text":"exclude_opt_key : str = 'exclude_from_auth' An identifier to use on routes to disable authentication and authorization checks for a particular route.","title":"exclude_opt_key"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.guards","text":"guards : Optional [ Iterable [ Guard ]] = None An iterable of guards to call for requests, providing authorization functionalities.","title":"guards"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.middleware","text":"middleware : DefineMiddleware Create an instance of the config's 'authentication_middleware_class' attribute and any required kwargs, wrapping it in Starlite's DefineMiddleware . Returns: Type Description DefineMiddleware An instance of DefineMiddleware .","title":"middleware"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.openapi_components","text":"openapi_components : Components Create OpenAPI documentation for the JWT auth schema used. Returns: Type Description Components An Components instance.","title":"openapi_components"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.retrieve_user_handler","text":"retrieve_user_handler : Callable [[ Any , ASGIConnection ], SyncOrAsyncUnion [ Optional [ Any ]]] Callable that receives the 'auth' value from the authentication middleware and returns a 'user' value. Notes: - User and Auth can be any arbitrary values specified by the security backend. - The User and Auth values will be set by the middleware as scope[\"user\"] and scope[\"auth\"] respectively. Once provided, they can access via the connection.user and connection.auth properties. - The callable can be sync or async. If it is sync, it will be wrapped to support async.","title":"retrieve_user_handler"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.route_handlers","text":"route_handlers : Optional [ Iterable [ ControllerRouterHandler ]] = None An optional iterable of route handlers to register.","title":"route_handlers"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.scopes","text":"scopes : Optional [ Scopes ] = None ASGI scopes processed by the authentication middleware, if None both 'http' and 'websocket' will be processed.","title":"scopes"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.security_requirement","text":"security_requirement : SecurityRequirement Return OpenAPI 3.1. SecurityRequirement for the auth backend. Returns: Type Description SecurityRequirement An OpenAPI 3.1 SecurityRequirement dictionary.","title":"security_requirement"},{"location":"reference/security/0-base/#starlite.security.base.AbstractSecurityConfig.on_app_init","text":"on_app_init ( app_config ) Handle app init by injecting middleware, guards etc. into the app. This method can be used only on the app level. Parameters: Name Type Description Default app_config AppConfig An instance of AppConfig required Returns: Type Description AppConfig The AppConfig .","title":"on_app_init()"},{"location":"reference/security/1-session-auth/","text":"Session Auth starlite.security.session_auth.SessionAuth Bases: Generic [ UserType ] , AbstractSecurityConfig [ UserType , Dict [ str , Any ]] Session Based Security Backend. authentication_middleware_class class-attribute authentication_middleware_class : Type [ SessionAuthMiddleware ] = SessionAuthMiddleware The authentication middleware class to use. Must inherit from SessionAuthMiddleware middleware property middleware : DefineMiddleware Use this property to insert the config into a middleware list on one of the application layers. Examples: from typing import Any from os import urandom from starlite import Starlite , Request , get from starlite_session import SessionAuth async def retrieve_user_from_session ( session : dict [ str , Any ]) -> Any : # implement logic here to retrieve a 'user' datum given the session dictionary ... session_auth_config = SessionAuth ( secret = urandom ( 16 ), retrieve_user_handler = retrieve_user_from_session ) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ session_auth_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value. openapi_components property openapi_components : Components Create OpenAPI documentation for the Session Authentication schema used. Returns: Type Description Components An Components instance. security_requirement property security_requirement : SecurityRequirement Return OpenAPI 3.1. SecurityRequirement for the auth backend. Returns: Type Description SecurityRequirement An OpenAPI 3.1 SecurityRequirement dictionary. starlite.security.session_auth.middleware.SessionAuthMiddleware Bases: AbstractAuthenticationMiddleware Session Authentication Middleware. __init__ __init__ ( app , exclude , exclude_opt_key , scopes , retrieve_user_handler ) Session based authentication middleware. Parameters: Name Type Description Default app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip in the authentication middleware. required exclude_opt_key str An identifier to use on routes to disable authentication and authorization checks for a particular route. required scopes Optional [ Scopes ] ASGI scopes processed by the authentication middleware. required retrieve_user_handler AsyncCallable[[Dict[str, Any], ASGIConnection[Any, Any, Any]], Awaitable[Any]] Callable that receives the 'session' value from the authentication middleware and returns a 'user' value. required","title":"Session Auth"},{"location":"reference/security/1-session-auth/#session-auth","text":"","title":"Session Auth"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.SessionAuth","text":"Bases: Generic [ UserType ] , AbstractSecurityConfig [ UserType , Dict [ str , Any ]] Session Based Security Backend.","title":"SessionAuth"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.auth.SessionAuth.authentication_middleware_class","text":"authentication_middleware_class : Type [ SessionAuthMiddleware ] = SessionAuthMiddleware The authentication middleware class to use. Must inherit from SessionAuthMiddleware","title":"authentication_middleware_class"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.auth.SessionAuth.middleware","text":"middleware : DefineMiddleware Use this property to insert the config into a middleware list on one of the application layers. Examples: from typing import Any from os import urandom from starlite import Starlite , Request , get from starlite_session import SessionAuth async def retrieve_user_from_session ( session : dict [ str , Any ]) -> Any : # implement logic here to retrieve a 'user' datum given the session dictionary ... session_auth_config = SessionAuth ( secret = urandom ( 16 ), retrieve_user_handler = retrieve_user_from_session ) @get ( \"/\" ) def my_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ my_handler ], middleware = [ session_auth_config . middleware ]) Returns: Type Description DefineMiddleware An instance of DefineMiddleware including 'self' as the config kwarg value.","title":"middleware"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.auth.SessionAuth.openapi_components","text":"openapi_components : Components Create OpenAPI documentation for the Session Authentication schema used. Returns: Type Description Components An Components instance.","title":"openapi_components"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.auth.SessionAuth.security_requirement","text":"security_requirement : SecurityRequirement Return OpenAPI 3.1. SecurityRequirement for the auth backend. Returns: Type Description SecurityRequirement An OpenAPI 3.1 SecurityRequirement dictionary.","title":"security_requirement"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.middleware.SessionAuthMiddleware","text":"Bases: AbstractAuthenticationMiddleware Session Authentication Middleware.","title":"SessionAuthMiddleware"},{"location":"reference/security/1-session-auth/#starlite.security.session_auth.middleware.SessionAuthMiddleware.__init__","text":"__init__ ( app , exclude , exclude_opt_key , scopes , retrieve_user_handler ) Session based authentication middleware. Parameters: Name Type Description Default app ASGIApp An ASGIApp, this value is the next ASGI handler to call in the middleware stack. required exclude Optional [ Union [ str , List [ str ]]] A pattern or list of patterns to skip in the authentication middleware. required exclude_opt_key str An identifier to use on routes to disable authentication and authorization checks for a particular route. required scopes Optional [ Scopes ] ASGI scopes processed by the authentication middleware. required retrieve_user_handler AsyncCallable[[Dict[str, Any], ASGIConnection[Any, Any, Any]], Awaitable[Any]] Callable that receives the 'session' value from the authentication middleware and returns a 'user' value. required","title":"__init__()"},{"location":"reference/template/base/","text":"Templating starlite.template.base.TemplateProtocol Bases: Protocol Protocol Defining a 'Template'. Template is a class that has a render method which renders the template into a string. render render ( * args , ** kwargs ) Return the rendered template as a string. Parameters: Name Type Description Default **kwargs Any A string keyed mapping of values passed to the TemplateEngine {} Returns: Type Description str The rendered template string starlite.template.base.T_co module-attribute starlite . template . base . T_co = TypeVar ( 'T_co' , bound = TemplateProtocol , covariant = True ) starlite.template.base.TemplateEngineProtocol Bases: Protocol [ T_co ] Protocol for template engines. __init__ __init__ ( directory ) Initialize the template engine with a directory. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required get_template get_template ( template_name ) Retrieve a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description T_co Template instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found. register_template_callable register_template_callable ( key , template_callable ) Register a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"Templating"},{"location":"reference/template/base/#templating","text":"","title":"Templating"},{"location":"reference/template/base/#starlite.template.base.TemplateProtocol","text":"Bases: Protocol Protocol Defining a 'Template'. Template is a class that has a render method which renders the template into a string.","title":"TemplateProtocol"},{"location":"reference/template/base/#starlite.template.base.TemplateProtocol.render","text":"render ( * args , ** kwargs ) Return the rendered template as a string. Parameters: Name Type Description Default **kwargs Any A string keyed mapping of values passed to the TemplateEngine {} Returns: Type Description str The rendered template string","title":"render()"},{"location":"reference/template/base/#starlite.template.base.T_co","text":"starlite . template . base . T_co = TypeVar ( 'T_co' , bound = TemplateProtocol , covariant = True )","title":"T_co"},{"location":"reference/template/base/#starlite.template.base.TemplateEngineProtocol","text":"Bases: Protocol [ T_co ] Protocol for template engines.","title":"TemplateEngineProtocol"},{"location":"reference/template/base/#starlite.template.base.TemplateEngineProtocol.__init__","text":"__init__ ( directory ) Initialize the template engine with a directory. Parameters: Name Type Description Default directory Union [ DirectoryPath , List [ DirectoryPath ]] Direct path or list of directory paths from which to serve templates. required","title":"__init__()"},{"location":"reference/template/base/#starlite.template.base.TemplateEngineProtocol.get_template","text":"get_template ( template_name ) Retrieve a template by matching its name (dotted path) with files in the directory or directories provided. Parameters: Name Type Description Default template_name str A dotted path required Returns: Type Description T_co Template instance Raises: Type Description [ TemplateNotFoundException ][ starlite . exceptions . TemplateNotFoundException ] if no template is found.","title":"get_template()"},{"location":"reference/template/base/#starlite.template.base.TemplateEngineProtocol.register_template_callable","text":"register_template_callable ( key , template_callable ) Register a callable on the template engine. Parameters: Name Type Description Default key str The callable key, i.e. the value to use inside the template to call the callable. required template_callable Callable [[ Dict [ str , Any ]], Any ] A callable to register. required Returns: Type Description None None","title":"register_template_callable()"},{"location":"reference/testing/0-test-client/","text":"Test Client starlite.testing.TestClient Bases: Client , Generic [ T ] __init__ __init__ ( app , base_url = \"http://testserver.local\" , raise_server_exceptions = True , root_path = \"\" , backend = \"asyncio\" , backend_options = None , session_config = None , cookies = None , ) A client implementation providing a context manager for testing applications. Parameters: Name Type Description Default app T The instance of Starlite under test. required base_url str URL scheme and domain for test request paths, e.g. ' http://testserver '. 'http://testserver.local' raise_server_exceptions bool Flag for the underlying test client to raise server exceptions instead of wrapping them in an HTTP response. True root_path str Path prefix for requests. '' backend AnyIOBackend The async backend to use, options are \"asyncio\" or \"trio\". 'asyncio' backend_options Optional [ Dict [ str , Any ]] 'anyio' options. None session_config Optional [ BaseBackendConfig ] Configuration for Session Middleware class to create raw session cookies for request to the route handlers. None cookies Optional [ CookieTypes ] Cookies to set on the client. None __enter__ __enter__ () request request ( method , url , * , content = None , data = None , files = None , json = None , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a request. Parameters: Name Type Description Default method str An HTTP method. required url URLTypes URL or path for the request. required content Optional [ RequestContent ] Request content. None data Optional [ RequestData ] Form encoded data. None files Optional [ RequestFiles ] Multipart files to send. None json Optional [ Any ] JSON data to send. None params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Optional [ Union [ AuthTypes , UseClientDefault ]] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response. get get ( url , * , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a GET request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response. post post ( url , * , content = None , data = None , files = None , json = None , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a POST request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required content Optional [ RequestContent ] Request content. None data Optional [ RequestData ] Form encoded data. None files Optional [ RequestFiles ] Multipart files to send. None json Optional [ Any ] JSON data to send. None params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response. patch patch ( url , * , content = None , data = None , files = None , json = None , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a PATCH request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required content Optional [ RequestContent ] Request content. None data Optional [ RequestData ] Form encoded data. None files Optional [ RequestFiles ] Multipart files to send. None json Optional [ Any ] JSON data to send. None params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response. put put ( url , * , content = None , data = None , files = None , json = None , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a PUT request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required content Optional [ RequestContent ] Request content. None data Optional [ RequestData ] Form encoded data. None files Optional [ RequestFiles ] Multipart files to send. None json Optional [ Any ] JSON data to send. None params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response. delete delete ( url , * , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a DELETE request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response. options options ( url , * , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends an OPTIONS request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response. head head ( url , * , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a HEAD request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response. set_session_data set_session_data ( data ) Set session data. Parameters: Name Type Description Default data Dict [ str , Any ] Session data required Returns: Type Description None None Examples: from starlite import Starlite , get from starlite.middleware.session.memory_backend import MemoryBackendConfig session_config = MemoryBackendConfig () @get ( path = \"/test\" ) def get_session_data ( request : Request ) -> Dict [ str , Any ]: return request . session app = Starlite ( route_handlers = [ get_session_data ], middleware = [ session_config . middleware ] ) with TestClient ( app = app , session_config = session_config ) as client : client . set_session_data ({ \"foo\" : \"bar\" }) assert client . get ( \"/test\" ) . json () == { \"foo\" : \"bar\" } get_session_data get_session_data () Get session data. Returns: Type Description Dict [ str , Any ] A dictionary containing session data. Examples: from starlite import Starlite , post from starlite.middleware.session.memory_backend import MemoryBackendConfig session_config = MemoryBackendConfig () @post ( path = \"/test\" ) def set_session_data ( request : Request ) -> None : request . session [ \"foo\" ] == \"bar\" app = Starlite ( route_handlers = [ set_session_data ], middleware = [ session_config . middleware ] ) with TestClient ( app = app , session_config = session_config ) as client : client . post ( \"/test\" ) assert client . get_session_data () == { \"foo\" : \"bar\" } portal portal () Get a BlockingPortal. Returns: Type Description Generator [ BlockingPortal , None, None] A contextmanager for a BlockingPortal. starlite.testing.test_client.WebSocketTestSession close close ( code = WS_1000_NORMAL_CLOSURE ) Sends an 'websocket.disconnect' event. Parameters: Name Type Description Default code int status code for closing the connection. WS_1000_NORMAL_CLOSURE Returns: Type Description None None. receive receive () This is the base receive method. Notes you can use one of the other receive methods to extract the data from the message. Returns: Type Description WebSocketSendMessage A websocket message. receive_bytes receive_bytes () Returns: Type Description bytes A bytes string value. receive_json receive_json ( mode = 'text' ) Receives JSON. Parameters: Name Type Description Default mode Literal ['text', 'binary'] Either 'text' or 'binary' 'text' Returns: Type Description Any An arbitrary value receive_text receive_text () Returns: Type Description str A string value. send send ( data , mode = 'text' , encoding = 'utf-8' ) Sends a \"receive\" event. This is the inverse of the ASGI send method. Parameters: Name Type Description Default data Union [ str , bytes ] Either a string or a byte string. required mode Literal ['text', 'binary'] The key to use - 'text' or 'bytes' 'text' encoding str The encoding to use when encoding or decoding data. 'utf-8' Returns: Type Description None None. send_bytes send_bytes ( data , encoding = 'utf-8' ) Sends the data using the 'bytes' key. Parameters: Name Type Description Default data bytes Data to send. required encoding str Encoding to use. 'utf-8' Returns: Type Description None None send_json send_json ( data , mode = 'text' ) Sends the given data as JSON. Parameters: Name Type Description Default data Any The data to send. required mode Literal ['text', 'binary'] Either 'text' or 'binary' 'text' Returns: Type Description None None. send_text send_text ( data , encoding = 'utf-8' ) Sends the data using the 'text' key. Parameters: Name Type Description Default data str Data to send. required encoding str Encoding to use. 'utf-8' Returns: Type Description None None starlite.testing.create_test_client","title":"Test Client"},{"location":"reference/testing/0-test-client/#test-client","text":"","title":"Test Client"},{"location":"reference/testing/0-test-client/#starlite.testing.TestClient","text":"Bases: Client , Generic [ T ]","title":"TestClient"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.__init__","text":"__init__ ( app , base_url = \"http://testserver.local\" , raise_server_exceptions = True , root_path = \"\" , backend = \"asyncio\" , backend_options = None , session_config = None , cookies = None , ) A client implementation providing a context manager for testing applications. Parameters: Name Type Description Default app T The instance of Starlite under test. required base_url str URL scheme and domain for test request paths, e.g. ' http://testserver '. 'http://testserver.local' raise_server_exceptions bool Flag for the underlying test client to raise server exceptions instead of wrapping them in an HTTP response. True root_path str Path prefix for requests. '' backend AnyIOBackend The async backend to use, options are \"asyncio\" or \"trio\". 'asyncio' backend_options Optional [ Dict [ str , Any ]] 'anyio' options. None session_config Optional [ BaseBackendConfig ] Configuration for Session Middleware class to create raw session cookies for request to the route handlers. None cookies Optional [ CookieTypes ] Cookies to set on the client. None","title":"__init__()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.__enter__","text":"__enter__ ()","title":"__enter__()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.request","text":"request ( method , url , * , content = None , data = None , files = None , json = None , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a request. Parameters: Name Type Description Default method str An HTTP method. required url URLTypes URL or path for the request. required content Optional [ RequestContent ] Request content. None data Optional [ RequestData ] Form encoded data. None files Optional [ RequestFiles ] Multipart files to send. None json Optional [ Any ] JSON data to send. None params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Optional [ Union [ AuthTypes , UseClientDefault ]] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response.","title":"request()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.get","text":"get ( url , * , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a GET request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response.","title":"get()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.post","text":"post ( url , * , content = None , data = None , files = None , json = None , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a POST request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required content Optional [ RequestContent ] Request content. None data Optional [ RequestData ] Form encoded data. None files Optional [ RequestFiles ] Multipart files to send. None json Optional [ Any ] JSON data to send. None params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response.","title":"post()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.patch","text":"patch ( url , * , content = None , data = None , files = None , json = None , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a PATCH request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required content Optional [ RequestContent ] Request content. None data Optional [ RequestData ] Form encoded data. None files Optional [ RequestFiles ] Multipart files to send. None json Optional [ Any ] JSON data to send. None params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response.","title":"patch()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.put","text":"put ( url , * , content = None , data = None , files = None , json = None , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a PUT request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required content Optional [ RequestContent ] Request content. None data Optional [ RequestData ] Form encoded data. None files Optional [ RequestFiles ] Multipart files to send. None json Optional [ Any ] JSON data to send. None params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response.","title":"put()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.delete","text":"delete ( url , * , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a DELETE request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response.","title":"delete()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.options","text":"options ( url , * , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends an OPTIONS request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response.","title":"options()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.head","text":"head ( url , * , params = None , headers = None , cookies = None , auth = USE_CLIENT_DEFAULT , follow_redirects = USE_CLIENT_DEFAULT , timeout = USE_CLIENT_DEFAULT , extensions = None ) Sends a HEAD request. Parameters: Name Type Description Default url URLTypes URL or path for the request. required params Optional [ QueryParamTypes ] Query parameters. None headers Optional [ HeaderTypes ] Request headers. None cookies Optional [ CookieTypes ] Request cookies. None auth Union [ AuthTypes , UseClientDefault ] Auth headers. USE_CLIENT_DEFAULT follow_redirects Union [ bool , UseClientDefault ] Whether to follow redirects. USE_CLIENT_DEFAULT timeout Union [ TimeoutTypes , UseClientDefault ] Request timeout. USE_CLIENT_DEFAULT extensions Optional [ Dict [ str , Any ]] Dictionary of ASGI extensions. None Returns: Type Description Response An HTTPX Response.","title":"head()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.set_session_data","text":"set_session_data ( data ) Set session data. Parameters: Name Type Description Default data Dict [ str , Any ] Session data required Returns: Type Description None None Examples: from starlite import Starlite , get from starlite.middleware.session.memory_backend import MemoryBackendConfig session_config = MemoryBackendConfig () @get ( path = \"/test\" ) def get_session_data ( request : Request ) -> Dict [ str , Any ]: return request . session app = Starlite ( route_handlers = [ get_session_data ], middleware = [ session_config . middleware ] ) with TestClient ( app = app , session_config = session_config ) as client : client . set_session_data ({ \"foo\" : \"bar\" }) assert client . get ( \"/test\" ) . json () == { \"foo\" : \"bar\" }","title":"set_session_data()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.get_session_data","text":"get_session_data () Get session data. Returns: Type Description Dict [ str , Any ] A dictionary containing session data. Examples: from starlite import Starlite , post from starlite.middleware.session.memory_backend import MemoryBackendConfig session_config = MemoryBackendConfig () @post ( path = \"/test\" ) def set_session_data ( request : Request ) -> None : request . session [ \"foo\" ] == \"bar\" app = Starlite ( route_handlers = [ set_session_data ], middleware = [ session_config . middleware ] ) with TestClient ( app = app , session_config = session_config ) as client : client . post ( \"/test\" ) assert client . get_session_data () == { \"foo\" : \"bar\" }","title":"get_session_data()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.client.TestClient.portal","text":"portal () Get a BlockingPortal. Returns: Type Description Generator [ BlockingPortal , None, None] A contextmanager for a BlockingPortal.","title":"portal()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.WebSocketTestSession","text":"","title":"WebSocketTestSession"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.close","text":"close ( code = WS_1000_NORMAL_CLOSURE ) Sends an 'websocket.disconnect' event. Parameters: Name Type Description Default code int status code for closing the connection. WS_1000_NORMAL_CLOSURE Returns: Type Description None None.","title":"close()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.receive","text":"receive () This is the base receive method. Notes you can use one of the other receive methods to extract the data from the message. Returns: Type Description WebSocketSendMessage A websocket message.","title":"receive()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.receive_bytes","text":"receive_bytes () Returns: Type Description bytes A bytes string value.","title":"receive_bytes()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.receive_json","text":"receive_json ( mode = 'text' ) Receives JSON. Parameters: Name Type Description Default mode Literal ['text', 'binary'] Either 'text' or 'binary' 'text' Returns: Type Description Any An arbitrary value","title":"receive_json()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.receive_text","text":"receive_text () Returns: Type Description str A string value.","title":"receive_text()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.send","text":"send ( data , mode = 'text' , encoding = 'utf-8' ) Sends a \"receive\" event. This is the inverse of the ASGI send method. Parameters: Name Type Description Default data Union [ str , bytes ] Either a string or a byte string. required mode Literal ['text', 'binary'] The key to use - 'text' or 'bytes' 'text' encoding str The encoding to use when encoding or decoding data. 'utf-8' Returns: Type Description None None.","title":"send()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.send_bytes","text":"send_bytes ( data , encoding = 'utf-8' ) Sends the data using the 'bytes' key. Parameters: Name Type Description Default data bytes Data to send. required encoding str Encoding to use. 'utf-8' Returns: Type Description None None","title":"send_bytes()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.send_json","text":"send_json ( data , mode = 'text' ) Sends the given data as JSON. Parameters: Name Type Description Default data Any The data to send. required mode Literal ['text', 'binary'] Either 'text' or 'binary' 'text' Returns: Type Description None None.","title":"send_json()"},{"location":"reference/testing/0-test-client/#starlite.testing.test_client.websocket_test_session.WebSocketTestSession.send_text","text":"send_text ( data , encoding = 'utf-8' ) Sends the data using the 'text' key. Parameters: Name Type Description Default data str Data to send. required encoding str Encoding to use. 'utf-8' Returns: Type Description None None","title":"send_text()"},{"location":"reference/testing/0-test-client/#starlite.testing.create_test_client","text":"","title":"create_test_client"},{"location":"reference/testing/1-request-factory/","text":"Request Factory starlite.testing.RequestFactory Factory to create Request instances. __init__ __init__ ( app = None , server = 'test.org' , port = 3000 , root_path = '' , scheme = 'http' ) Initialize RequestFactory Parameters: Name Type Description Default app Optional [ Starlite ] An instance of Starlite to set as request.scope[\"app\"] . None server str The server's domain. 'test.org' port int The server's port. 3000 root_path str Root path for the server. '' scheme str Scheme for the server. 'http' Examples: from starlite import RequestEncodingType , Starlite , RequestFactory from tests import PersonFactory my_app = Starlite ( route_handlers = []) my_server = \"starlite.org\" # Create a GET request query_params = { \"id\" : 1 } get_user_request = RequestFactory ( app = my_app , server = my_server ) . get ( \"/person\" , query_params = query_params ) # Create a POST request new_person = PersonFactory . build () create_user_request = RequestFactory ( app = my_app , server = my_server ) . post ( \"/person\" , data = person ) # Create a request with a special header headers = { \"header1\" : \"value1\" } request_with_header = RequestFactory ( app = my_app , server = my_server ) . get ( \"/person\" , query_params = query_params , headers = headers ) # Create a request with a media type request_with_media_type = RequestFactory ( app = my_app , server = my_server ) . post ( \"/person\" , data = person , request_media_type = RequestEncodingType . MULTI_PART ) get get ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a GET Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance post post ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a POST Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance put put ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a PUT Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance patch patch ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a PATCH Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance delete delete ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a POST Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"Request Factory"},{"location":"reference/testing/1-request-factory/#request-factory","text":"","title":"Request Factory"},{"location":"reference/testing/1-request-factory/#starlite.testing.RequestFactory","text":"Factory to create Request instances.","title":"RequestFactory"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.__init__","text":"__init__ ( app = None , server = 'test.org' , port = 3000 , root_path = '' , scheme = 'http' ) Initialize RequestFactory Parameters: Name Type Description Default app Optional [ Starlite ] An instance of Starlite to set as request.scope[\"app\"] . None server str The server's domain. 'test.org' port int The server's port. 3000 root_path str Root path for the server. '' scheme str Scheme for the server. 'http' Examples: from starlite import RequestEncodingType , Starlite , RequestFactory from tests import PersonFactory my_app = Starlite ( route_handlers = []) my_server = \"starlite.org\" # Create a GET request query_params = { \"id\" : 1 } get_user_request = RequestFactory ( app = my_app , server = my_server ) . get ( \"/person\" , query_params = query_params ) # Create a POST request new_person = PersonFactory . build () create_user_request = RequestFactory ( app = my_app , server = my_server ) . post ( \"/person\" , data = person ) # Create a request with a special header headers = { \"header1\" : \"value1\" } request_with_header = RequestFactory ( app = my_app , server = my_server ) . get ( \"/person\" , query_params = query_params , headers = headers ) # Create a request with a media type request_with_media_type = RequestFactory ( app = my_app , server = my_server ) . post ( \"/person\" , data = person , request_media_type = RequestEncodingType . MULTI_PART )","title":"__init__()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.get","text":"get ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a GET Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"get()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.post","text":"post ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a POST Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"post()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.put","text":"put ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a PUT Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"put()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.patch","text":"patch ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , request_media_type = RequestEncodingType . JSON , data = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a PATCH Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None request_media_type RequestEncodingType The 'Content-Type' header of the request. RequestEncodingType.JSON data Optional [ Union [ Dict [ str , Any ], BaseModel ]] A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"patch()"},{"location":"reference/testing/1-request-factory/#starlite.testing.request_factory.RequestFactory.delete","text":"delete ( path = \"/\" , headers = None , cookies = None , session = None , user = None , auth = None , query_params = None , state = None , path_params = None , http_version = \"1.1\" , route_handler = None , ) Create a POST Request instance. Parameters: Name Type Description Default path str The request's path. '/' headers Optional [ Dict [ str , str ]] A dictionary of headers. None cookies Optional [ Union [ List [ Cookie ], str ]] A string representing the cookie header or a list of \"Cookie\" instances. This value can include multiple cookies. None session Optional [ Dict [ str , Any ]] A dictionary of session data. None user Any A value for request.scope[\"user\"] . None auth Any A value for request.scope[\"auth\"] . None query_params Optional [ Dict [ str , Union [ str , List [ str ]]]] A dictionary of values from which the request's query will be generated. None state Optional [ Dict [ str , Any ]] Arbitrary request state. None path_params Optional [ Dict [ str , str ]] A string keyed dictionary of path parameter values. None http_version Optional [ str ] HTTP version. Defaults to \"1.1\". '1.1' route_handler Optional [ RouteHandlerType ] A route handler instance or method. If not provided a default handler is set. None Returns: Type Description Request [ Any , Any ] A Request instance","title":"delete()"},{"location":"reference/types/0-types-intro/","text":"Types Starlite exports many types. Some types are meant for internal usage only, and are as such undocumented in this section.","title":"Types"},{"location":"reference/types/0-types-intro/#types","text":"Starlite exports many types. Some types are meant for internal usage only, and are as such undocumented in this section.","title":"Types"},{"location":"reference/types/1-callable-types/","text":"Callable Types Callables types represent callables - functions, methods or classes that implement the __call__ dunder method. starlite.types.AfterExceptionHookHandler module-attribute starlite . types . AfterExceptionHookHandler = Callable [ [ Exception , Scope , State ], SyncOrAsyncUnion [ None ] ] starlite.types.AfterRequestHookHandler module-attribute starlite . types . AfterRequestHookHandler = Union [ Callable [[ ASGIApp ], SyncOrAsyncUnion [ ASGIApp ]], Callable [[ Response ], SyncOrAsyncUnion [ Response ]] ] starlite.types.AfterResponseHookHandler module-attribute starlite . types . AfterResponseHookHandler = Callable [[ Request ], SyncOrAsyncUnion [ None ]] starlite.types.AnyCallable module-attribute starlite . types . AnyCallable = Callable [ Ellipsis , Any ] starlite.types.AsyncAnyCallable module-attribute starlite . types . AsyncAnyCallable = Callable [ Ellipsis , Awaitable [ Any ]] starlite.types.BeforeMessageSendHookHandler module-attribute starlite . types . BeforeMessageSendHookHandler = Union [ Callable [[ Message , State , Scope ], SyncOrAsyncUnion [ None ]], Callable [[ Message , State ], SyncOrAsyncUnion [ None ]], ] starlite.types.BeforeRequestHookHandler module-attribute starlite . types . BeforeRequestHookHandler = Callable [[ Request ], Union [ Any , Awaitable [ Any ]]] starlite.types.CacheKeyBuilder module-attribute starlite . types . CacheKeyBuilder = Callable [[ Request ], str ] starlite.types.ExceptionHandler module-attribute starlite . types . ExceptionHandler = Callable [[ Request , _ExceptionT ], Response ] starlite.types.Guard module-attribute starlite . types . Guard = Callable [[ ASGIConnection , BaseRouteHandler ], SyncOrAsyncUnion [ None ]] starlite.types.LifeSpanHandler module-attribute starlite . types . LifeSpanHandler = Union [ Callable [[], SyncOrAsyncUnion [ Any ]], Callable [[ State ], SyncOrAsyncUnion [ Any ]] ] starlite.types.LifeSpanHookHandler module-attribute starlite . types . LifeSpanHookHandler = Callable [[ StarliteType ], SyncOrAsyncUnion [ None ]] starlite.types.OnAppInitHandler module-attribute starlite . types . OnAppInitHandler = Callable [[ AppConfig ], AppConfig ] starlite.types.Serializer module-attribute starlite . types . Serializer = Callable [[ Any ], Any ]","title":"Callable Types"},{"location":"reference/types/1-callable-types/#callable-types","text":"Callables types represent callables - functions, methods or classes that implement the __call__ dunder method.","title":"Callable Types"},{"location":"reference/types/1-callable-types/#starlite.types.AfterExceptionHookHandler","text":"starlite . types . AfterExceptionHookHandler = Callable [ [ Exception , Scope , State ], SyncOrAsyncUnion [ None ] ]","title":"AfterExceptionHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.AfterRequestHookHandler","text":"starlite . types . AfterRequestHookHandler = Union [ Callable [[ ASGIApp ], SyncOrAsyncUnion [ ASGIApp ]], Callable [[ Response ], SyncOrAsyncUnion [ Response ]] ]","title":"AfterRequestHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.AfterResponseHookHandler","text":"starlite . types . AfterResponseHookHandler = Callable [[ Request ], SyncOrAsyncUnion [ None ]]","title":"AfterResponseHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.AnyCallable","text":"starlite . types . AnyCallable = Callable [ Ellipsis , Any ]","title":"AnyCallable"},{"location":"reference/types/1-callable-types/#starlite.types.AsyncAnyCallable","text":"starlite . types . AsyncAnyCallable = Callable [ Ellipsis , Awaitable [ Any ]]","title":"AsyncAnyCallable"},{"location":"reference/types/1-callable-types/#starlite.types.BeforeMessageSendHookHandler","text":"starlite . types . BeforeMessageSendHookHandler = Union [ Callable [[ Message , State , Scope ], SyncOrAsyncUnion [ None ]], Callable [[ Message , State ], SyncOrAsyncUnion [ None ]], ]","title":"BeforeMessageSendHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.BeforeRequestHookHandler","text":"starlite . types . BeforeRequestHookHandler = Callable [[ Request ], Union [ Any , Awaitable [ Any ]]]","title":"BeforeRequestHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.CacheKeyBuilder","text":"starlite . types . CacheKeyBuilder = Callable [[ Request ], str ]","title":"CacheKeyBuilder"},{"location":"reference/types/1-callable-types/#starlite.types.ExceptionHandler","text":"starlite . types . ExceptionHandler = Callable [[ Request , _ExceptionT ], Response ]","title":"ExceptionHandler"},{"location":"reference/types/1-callable-types/#starlite.types.Guard","text":"starlite . types . Guard = Callable [[ ASGIConnection , BaseRouteHandler ], SyncOrAsyncUnion [ None ]]","title":"Guard"},{"location":"reference/types/1-callable-types/#starlite.types.LifeSpanHandler","text":"starlite . types . LifeSpanHandler = Union [ Callable [[], SyncOrAsyncUnion [ Any ]], Callable [[ State ], SyncOrAsyncUnion [ Any ]] ]","title":"LifeSpanHandler"},{"location":"reference/types/1-callable-types/#starlite.types.LifeSpanHookHandler","text":"starlite . types . LifeSpanHookHandler = Callable [[ StarliteType ], SyncOrAsyncUnion [ None ]]","title":"LifeSpanHookHandler"},{"location":"reference/types/1-callable-types/#starlite.types.OnAppInitHandler","text":"starlite . types . OnAppInitHandler = Callable [[ AppConfig ], AppConfig ]","title":"OnAppInitHandler"},{"location":"reference/types/1-callable-types/#starlite.types.Serializer","text":"starlite . types . Serializer = Callable [[ Any ], Any ]","title":"Serializer"},{"location":"reference/types/2-asgi-types/","text":"ASGI Types starlite.types.Method module-attribute starlite . types . Method = Literal [ \"GET\" , \"POST\" , \"DELETE\" , \"PATCH\" , \"PUT\" , \"HEAD\" , \"TRACE\" , \"OPTIONS\" ] ASGI Application starlite.types.ASGIApp module-attribute starlite . types . ASGIApp = Callable [[ Scope , Receive , Send ], Awaitable [ None ]] ASGI Application Parameters starlite.types.Scope module-attribute starlite . types . Scope = Union [ HTTPScope , WebSocketScope ] starlite.types.Receive module-attribute starlite . types . Receive = Callable [ Ellipsis , Awaitable [ Union [ HTTPReceiveMessage , WebSocketReceiveMessage ]] ] starlite.types.Send module-attribute starlite . types . Send = Callable [[ Message ], Awaitable [ None ]] ASGI Scopes starlite.types.ASGIVersion Bases: TypedDict ASGI spec version. starlite.types.BaseScope Bases: HeaderScope Base ASGI-scope. starlite.types.WebSocketScope Bases: BaseScope WebSocket-ASGI-scope. starlite.types.HTTPScope Bases: BaseScope HTTP-ASGI-scope. starlite.types.LifeSpanScope Bases: TypedDict Lifespan-ASGI-scope. ASGI Events starlite.types.HTTPRequestEvent Bases: TypedDict ASGI http.request event. starlite.types.HTTPResponseStartEvent Bases: HeaderScope ASGI http.response.start event. starlite.types.HTTPResponseBodyEvent Bases: TypedDict ASGI http.response.body event. starlite.types.HTTPServerPushEvent Bases: HeaderScope ASGI http.response.push event. starlite.types.HTTPDisconnectEvent Bases: TypedDict ASGI http.disconnect event. starlite.types.WebSocketConnectEvent Bases: TypedDict ASGI websocket.connect event. starlite.types.WebSocketAcceptEvent Bases: HeaderScope ASGI websocket.accept event. starlite.types.WebSocketReceiveEvent Bases: TypedDict ASGI websocket.receive event. starlite.types.WebSocketSendEvent Bases: TypedDict ASGI websocket.send event. starlite.types.WebSocketResponseStartEvent Bases: HeaderScope ASGI websocket.http.response.start event. starlite.types.WebSocketResponseBodyEvent Bases: TypedDict ASGI websocket.http.response.body event. starlite.types.WebSocketDisconnectEvent Bases: TypedDict ASGI websocket.disconnect event. starlite.types.WebSocketCloseEvent Bases: TypedDict ASGI websocket.close event. starlite.types.LifeSpanStartupEvent Bases: TypedDict ASGI lifespan.startup event. starlite.types.LifeSpanShutdownEvent Bases: TypedDict ASGI lifespan.shutdown event. starlite.types.LifeSpanStartupCompleteEvent Bases: TypedDict ASGI lifespan.startup.complete event. starlite.types.LifeSpanStartupFailedEvent Bases: TypedDict ASGI lifespan.startup.failed event. starlite.types.LifeSpanShutdownCompleteEvent Bases: TypedDict ASGI lifespan.shutdown.complete event. starlite.types.LifeSpanShutdownFailedEvent Bases: TypedDict ASGI lifespan.shutdown.failed event. Event Groupings starlite.types.HTTPReceiveMessage module-attribute starlite . types . HTTPReceiveMessage = Union [ HTTPRequestEvent , HTTPDisconnectEvent ] starlite.types.WebSocketReceiveMessage module-attribute starlite . types . WebSocketReceiveMessage = Union [ WebSocketConnectEvent , WebSocketReceiveEvent , WebSocketDisconnectEvent ] starlite.types.LifeSpanReceiveMessage module-attribute starlite . types . LifeSpanReceiveMessage = Union [ LifeSpanStartupEvent , LifeSpanShutdownEvent ] starlite.types.HTTPSendMessage module-attribute starlite . types . HTTPSendMessage = Union [ HTTPResponseStartEvent , HTTPResponseBodyEvent , HTTPServerPushEvent , HTTPDisconnectEvent ] starlite.types.WebSocketSendMessage module-attribute starlite . types . WebSocketSendMessage = Union [ WebSocketAcceptEvent , WebSocketSendEvent , WebSocketResponseStartEvent , WebSocketResponseBodyEvent , WebSocketCloseEvent , ] starlite.types.LifeSpanSendMessage module-attribute starlite . types . LifeSpanSendMessage = Union [ LifeSpanStartupCompleteEvent , LifeSpanStartupFailedEvent , LifeSpanShutdownCompleteEvent , LifeSpanShutdownFailedEvent , ] starlite.types.LifeSpanReceive module-attribute starlite . types . LifeSpanReceive = Callable [ Ellipsis , Awaitable [ LifeSpanReceiveMessage ]] starlite.types.LifeSpanSend module-attribute starlite . types . LifeSpanSend = Callable [[ LifeSpanSendMessage ], Awaitable [ None ]] Send / Receive Parameter Types starlite.types.Message module-attribute starlite . types . Message = Union [ HTTPSendMessage , WebSocketSendMessage ] starlite.types.ReceiveMessage module-attribute starlite . types . ReceiveMessage = Union [ HTTPReceiveMessage , WebSocketReceiveMessage ]","title":"ASGI Types"},{"location":"reference/types/2-asgi-types/#asgi-types","text":"","title":"ASGI Types"},{"location":"reference/types/2-asgi-types/#starlite.types.Method","text":"starlite . types . Method = Literal [ \"GET\" , \"POST\" , \"DELETE\" , \"PATCH\" , \"PUT\" , \"HEAD\" , \"TRACE\" , \"OPTIONS\" ]","title":"Method"},{"location":"reference/types/2-asgi-types/#asgi-application","text":"","title":"ASGI Application"},{"location":"reference/types/2-asgi-types/#starlite.types.ASGIApp","text":"starlite . types . ASGIApp = Callable [[ Scope , Receive , Send ], Awaitable [ None ]]","title":"ASGIApp"},{"location":"reference/types/2-asgi-types/#asgi-application-parameters","text":"","title":"ASGI Application Parameters"},{"location":"reference/types/2-asgi-types/#starlite.types.Scope","text":"starlite . types . Scope = Union [ HTTPScope , WebSocketScope ]","title":"Scope"},{"location":"reference/types/2-asgi-types/#starlite.types.Receive","text":"starlite . types . Receive = Callable [ Ellipsis , Awaitable [ Union [ HTTPReceiveMessage , WebSocketReceiveMessage ]] ]","title":"Receive"},{"location":"reference/types/2-asgi-types/#starlite.types.Send","text":"starlite . types . Send = Callable [[ Message ], Awaitable [ None ]]","title":"Send"},{"location":"reference/types/2-asgi-types/#asgi-scopes","text":"","title":"ASGI Scopes"},{"location":"reference/types/2-asgi-types/#starlite.types.ASGIVersion","text":"Bases: TypedDict ASGI spec version.","title":"ASGIVersion"},{"location":"reference/types/2-asgi-types/#starlite.types.BaseScope","text":"Bases: HeaderScope Base ASGI-scope.","title":"BaseScope"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketScope","text":"Bases: BaseScope WebSocket-ASGI-scope.","title":"WebSocketScope"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPScope","text":"Bases: BaseScope HTTP-ASGI-scope.","title":"HTTPScope"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanScope","text":"Bases: TypedDict Lifespan-ASGI-scope.","title":"LifeSpanScope"},{"location":"reference/types/2-asgi-types/#asgi-events","text":"","title":"ASGI Events"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPRequestEvent","text":"Bases: TypedDict ASGI http.request event.","title":"HTTPRequestEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPResponseStartEvent","text":"Bases: HeaderScope ASGI http.response.start event.","title":"HTTPResponseStartEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPResponseBodyEvent","text":"Bases: TypedDict ASGI http.response.body event.","title":"HTTPResponseBodyEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPServerPushEvent","text":"Bases: HeaderScope ASGI http.response.push event.","title":"HTTPServerPushEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPDisconnectEvent","text":"Bases: TypedDict ASGI http.disconnect event.","title":"HTTPDisconnectEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketConnectEvent","text":"Bases: TypedDict ASGI websocket.connect event.","title":"WebSocketConnectEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketAcceptEvent","text":"Bases: HeaderScope ASGI websocket.accept event.","title":"WebSocketAcceptEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketReceiveEvent","text":"Bases: TypedDict ASGI websocket.receive event.","title":"WebSocketReceiveEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketSendEvent","text":"Bases: TypedDict ASGI websocket.send event.","title":"WebSocketSendEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketResponseStartEvent","text":"Bases: HeaderScope ASGI websocket.http.response.start event.","title":"WebSocketResponseStartEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketResponseBodyEvent","text":"Bases: TypedDict ASGI websocket.http.response.body event.","title":"WebSocketResponseBodyEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketDisconnectEvent","text":"Bases: TypedDict ASGI websocket.disconnect event.","title":"WebSocketDisconnectEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketCloseEvent","text":"Bases: TypedDict ASGI websocket.close event.","title":"WebSocketCloseEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanStartupEvent","text":"Bases: TypedDict ASGI lifespan.startup event.","title":"LifeSpanStartupEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanShutdownEvent","text":"Bases: TypedDict ASGI lifespan.shutdown event.","title":"LifeSpanShutdownEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanStartupCompleteEvent","text":"Bases: TypedDict ASGI lifespan.startup.complete event.","title":"LifeSpanStartupCompleteEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanStartupFailedEvent","text":"Bases: TypedDict ASGI lifespan.startup.failed event.","title":"LifeSpanStartupFailedEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanShutdownCompleteEvent","text":"Bases: TypedDict ASGI lifespan.shutdown.complete event.","title":"LifeSpanShutdownCompleteEvent"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanShutdownFailedEvent","text":"Bases: TypedDict ASGI lifespan.shutdown.failed event.","title":"LifeSpanShutdownFailedEvent"},{"location":"reference/types/2-asgi-types/#event-groupings","text":"","title":"Event Groupings"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPReceiveMessage","text":"starlite . types . HTTPReceiveMessage = Union [ HTTPRequestEvent , HTTPDisconnectEvent ]","title":"HTTPReceiveMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketReceiveMessage","text":"starlite . types . WebSocketReceiveMessage = Union [ WebSocketConnectEvent , WebSocketReceiveEvent , WebSocketDisconnectEvent ]","title":"WebSocketReceiveMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanReceiveMessage","text":"starlite . types . LifeSpanReceiveMessage = Union [ LifeSpanStartupEvent , LifeSpanShutdownEvent ]","title":"LifeSpanReceiveMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.HTTPSendMessage","text":"starlite . types . HTTPSendMessage = Union [ HTTPResponseStartEvent , HTTPResponseBodyEvent , HTTPServerPushEvent , HTTPDisconnectEvent ]","title":"HTTPSendMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.WebSocketSendMessage","text":"starlite . types . WebSocketSendMessage = Union [ WebSocketAcceptEvent , WebSocketSendEvent , WebSocketResponseStartEvent , WebSocketResponseBodyEvent , WebSocketCloseEvent , ]","title":"WebSocketSendMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanSendMessage","text":"starlite . types . LifeSpanSendMessage = Union [ LifeSpanStartupCompleteEvent , LifeSpanStartupFailedEvent , LifeSpanShutdownCompleteEvent , LifeSpanShutdownFailedEvent , ]","title":"LifeSpanSendMessage"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanReceive","text":"starlite . types . LifeSpanReceive = Callable [ Ellipsis , Awaitable [ LifeSpanReceiveMessage ]]","title":"LifeSpanReceive"},{"location":"reference/types/2-asgi-types/#starlite.types.LifeSpanSend","text":"starlite . types . LifeSpanSend = Callable [[ LifeSpanSendMessage ], Awaitable [ None ]]","title":"LifeSpanSend"},{"location":"reference/types/2-asgi-types/#send-receive-parameter-types","text":"","title":"Send / Receive Parameter Types"},{"location":"reference/types/2-asgi-types/#starlite.types.Message","text":"starlite . types . Message = Union [ HTTPSendMessage , WebSocketSendMessage ]","title":"Message"},{"location":"reference/types/2-asgi-types/#starlite.types.ReceiveMessage","text":"starlite . types . ReceiveMessage = Union [ HTTPReceiveMessage , WebSocketReceiveMessage ]","title":"ReceiveMessage"},{"location":"reference/types/3-helper-types/","text":"Helper Types Helper types are useful generic types that can be used. starlite.types.SyncOrAsyncUnion module-attribute starlite . types . SyncOrAsyncUnion = Union [ T , Awaitable [ T ]] Types 'T' as a union of T and awaitable T. starlite.types.SingleOrList module-attribute starlite . types . SingleOrList = Union [ T , List [ T ]] Types 'T' as a single value or a list T.","title":"Helper Types"},{"location":"reference/types/3-helper-types/#helper-types","text":"Helper types are useful generic types that can be used.","title":"Helper Types"},{"location":"reference/types/3-helper-types/#starlite.types.SyncOrAsyncUnion","text":"starlite . types . SyncOrAsyncUnion = Union [ T , Awaitable [ T ]] Types 'T' as a union of T and awaitable T.","title":"SyncOrAsyncUnion"},{"location":"reference/types/3-helper-types/#starlite.types.SingleOrList","text":"starlite . types . SingleOrList = Union [ T , List [ T ]] Types 'T' as a single value or a list T.","title":"SingleOrList"},{"location":"reference/types/4-protocol-types/","text":"Protocols starlite.types.Logger Bases: Protocol Logger protocol.","title":"Protocols"},{"location":"reference/types/4-protocol-types/#protocols","text":"","title":"Protocols"},{"location":"reference/types/4-protocol-types/#starlite.types.Logger","text":"Bases: Protocol Logger protocol.","title":"Logger"},{"location":"reference/types/5-composite-types/","text":"Composite Types starlite.types.Dependencies module-attribute starlite . types . Dependencies = Dict [ str , Provide ] starlite.types.ExceptionHandlersMap module-attribute starlite . types . ExceptionHandlersMap = Dict [ Union [ int , Type [ Exception ]], ExceptionHandler ] starlite.types.Middleware module-attribute starlite . types . Middleware = Union [ Callable [ Ellipsis , ASGIApp ], DefineMiddleware , Iterator [ Tuple [ ASGIApp , Dict [ str , Any ]]], Type [ MiddlewareProtocol ], ] starlite.types.ResponseCookies module-attribute starlite . types . ResponseCookies = List [ Cookie ] starlite.types.ResponseHeadersMap module-attribute starlite . types . ResponseHeadersMap = Dict [ str , ResponseHeader ] starlite.types.PathType module-attribute starlite . types . PathType = Union [ Path , PathLike , str ]","title":"Composite Types"},{"location":"reference/types/5-composite-types/#composite-types","text":"","title":"Composite Types"},{"location":"reference/types/5-composite-types/#starlite.types.Dependencies","text":"starlite . types . Dependencies = Dict [ str , Provide ]","title":"Dependencies"},{"location":"reference/types/5-composite-types/#starlite.types.ExceptionHandlersMap","text":"starlite . types . ExceptionHandlersMap = Dict [ Union [ int , Type [ Exception ]], ExceptionHandler ]","title":"ExceptionHandlersMap"},{"location":"reference/types/5-composite-types/#starlite.types.Middleware","text":"starlite . types . Middleware = Union [ Callable [ Ellipsis , ASGIApp ], DefineMiddleware , Iterator [ Tuple [ ASGIApp , Dict [ str , Any ]]], Type [ MiddlewareProtocol ], ]","title":"Middleware"},{"location":"reference/types/5-composite-types/#starlite.types.ResponseCookies","text":"starlite . types . ResponseCookies = List [ Cookie ]","title":"ResponseCookies"},{"location":"reference/types/5-composite-types/#starlite.types.ResponseHeadersMap","text":"starlite . types . ResponseHeadersMap = Dict [ str , ResponseHeader ]","title":"ResponseHeadersMap"},{"location":"reference/types/5-composite-types/#starlite.types.PathType","text":"starlite . types . PathType = Union [ Path , PathLike , str ]","title":"PathType"},{"location":"reference/types/6-partial-types/","text":"Partial starlite.types.partial.T module-attribute starlite . types . partial . T = TypeVar ( 'T' ) starlite.types.partial.Partial Bases: Generic [ T ] Type generation for PATCH routes. Partial is a special typing helper that takes a generic T, which must be a TypedDict , dataclass or pydantic model class, and returns to static type checkers a version of this T in which all fields - and nested fields - are optional.","title":"Partial"},{"location":"reference/types/6-partial-types/#partial","text":"","title":"Partial"},{"location":"reference/types/6-partial-types/#starlite.types.partial.T","text":"starlite . types . partial . T = TypeVar ( 'T' )","title":"T"},{"location":"reference/types/6-partial-types/#starlite.types.partial.Partial","text":"Bases: Generic [ T ] Type generation for PATCH routes. Partial is a special typing helper that takes a generic T, which must be a TypedDict , dataclass or pydantic model class, and returns to static type checkers a version of this T in which all fields - and nested fields - are optional.","title":"Partial"},{"location":"reference/types/7-file-types/","text":"File Types starlite.types.FileInfo Bases: TypedDict File information gathered from a file system. created class-attribute created : float Created time stamp, equal to 'stat_result.st_ctime'. destination class-attribute destination : NotRequired [ Optional [ bytes ]] Output of loading a symbolic link. gid class-attribute gid : int Group ID of owner. ino class-attribute ino : int inode value. islink class-attribute islink : bool True if the file is a symbolic link. mode class-attribute mode : int Protection mode. mtime class-attribute mtime : float Modified time stamp. name class-attribute name : str The path of the file. nlink class-attribute nlink : int Number of hard links. size class-attribute size : int Total size, in bytes. type class-attribute type : Literal [ 'file' , 'directory' , 'other' ] The type of the file system object. uid class-attribute uid : int User ID of owner. starlite.types.FileSystemProtocol Bases: Protocol Base protocol used to interact with a file-system. This protocol is commensurable with the file systems exported by the fsspec library. info info ( path , ** kwargs ) Retrieve information about a given file path. Parameters: Name Type Description Default path PathType A file path. required **kwargs Any Any additional kwargs. {} Returns: Type Description Union [ FileInfo , Awaitable [ FileInfo ]] A dictionary of file info. open open ( file , mode , buffering =- 1 ) Return a file-like object from the filesystem. Notes The return value must function correctly in a context with block. Parameters: Name Type Description Default file PathType Path to the target file. required mode str Mode, similar to the built open . required buffering int Buffer size. -1","title":"File Types"},{"location":"reference/types/7-file-types/#file-types","text":"","title":"File Types"},{"location":"reference/types/7-file-types/#starlite.types.FileInfo","text":"Bases: TypedDict File information gathered from a file system.","title":"FileInfo"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.created","text":"created : float Created time stamp, equal to 'stat_result.st_ctime'.","title":"created"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.destination","text":"destination : NotRequired [ Optional [ bytes ]] Output of loading a symbolic link.","title":"destination"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.gid","text":"gid : int Group ID of owner.","title":"gid"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.ino","text":"ino : int inode value.","title":"ino"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.islink","text":"islink : bool True if the file is a symbolic link.","title":"islink"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.mode","text":"mode : int Protection mode.","title":"mode"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.mtime","text":"mtime : float Modified time stamp.","title":"mtime"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.name","text":"name : str The path of the file.","title":"name"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.nlink","text":"nlink : int Number of hard links.","title":"nlink"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.size","text":"size : int Total size, in bytes.","title":"size"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.type","text":"type : Literal [ 'file' , 'directory' , 'other' ] The type of the file system object.","title":"type"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileInfo.uid","text":"uid : int User ID of owner.","title":"uid"},{"location":"reference/types/7-file-types/#starlite.types.FileSystemProtocol","text":"Bases: Protocol Base protocol used to interact with a file-system. This protocol is commensurable with the file systems exported by the fsspec library.","title":"FileSystemProtocol"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileSystemProtocol.info","text":"info ( path , ** kwargs ) Retrieve information about a given file path. Parameters: Name Type Description Default path PathType A file path. required **kwargs Any Any additional kwargs. {} Returns: Type Description Union [ FileInfo , Awaitable [ FileInfo ]] A dictionary of file info.","title":"info()"},{"location":"reference/types/7-file-types/#starlite.types.file_types.FileSystemProtocol.open","text":"open ( file , mode , buffering =- 1 ) Return a file-like object from the filesystem. Notes The return value must function correctly in a context with block. Parameters: Name Type Description Default file PathType Path to the target file. required mode str Mode, similar to the built open . required buffering int Buffer size. -1","title":"open()"},{"location":"reference/utils/0-predicate-utils/","text":"Predicate Utils starlite.utils.predicates.P module-attribute starlite . utils . predicates . P = ParamSpec ( 'P' ) starlite.utils.predicates.T module-attribute starlite . utils . predicates . T = TypeVar ( 'T' ) starlite.utils.predicates.is_class_and_subclass starlite . utils . predicates . is_class_and_subclass ( value , t_type ) Return True if value is a class and is a subtype of t_type . See https://github.com/starlite-api/starlite/issues/367 Parameters: Name Type Description Default value Any The value to check if is class and subclass of t_type . required t_type Type [ T ] Type used for issubclass() check of value required Returns: Type Description TypeGuard [ Type [ T ]] bool starlite.utils.predicates.is_dataclass_class_or_instance_typeguard starlite . utils . predicates . is_dataclass_class_or_instance_typeguard ( value ) Wrap is_dataclass() in a TypeGuard . Parameters: Name Type Description Default value Any tested to determine if instance or type of dataclass . required Returns: Type Description TypeGuard[DataclassClassOrInstance] True if instance or type of dataclass . starlite.utils.predicates.is_dataclass_class_typeguard starlite . utils . predicates . is_dataclass_class_typeguard ( value ) Wrap is_dataclass() in a TypeGuard , narrowing to type only, not instance. Parameters: Name Type Description Default value Any tested to determine if type of dataclass . required Returns: Type Description TypeGuard[DataclassClass] True if value is a dataclass type. starlite.utils.predicates.is_optional_union starlite . utils . predicates . is_optional_union ( annotation ) Given a type annotation determine if the annotation infers an optional union. Parameters: Name Type Description Default annotation Any A type. required Returns: Type Description bool True for a union, False otherwise. starlite.utils.predicates.is_typeddict_typeguard starlite . utils . predicates . is_typeddict_typeguard ( value ) Wrap is_typeddict() in a TypeGuard . Parameters: Name Type Description Default value Any tested to determine if instance or type of dataclass . required Returns: Type Description TypeGuard[TypedDictClass] True if instance or type of dataclass .","title":"Predicate Utils"},{"location":"reference/utils/0-predicate-utils/#predicate-utils","text":"","title":"Predicate Utils"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.P","text":"starlite . utils . predicates . P = ParamSpec ( 'P' )","title":"P"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.T","text":"starlite . utils . predicates . T = TypeVar ( 'T' )","title":"T"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_class_and_subclass","text":"starlite . utils . predicates . is_class_and_subclass ( value , t_type ) Return True if value is a class and is a subtype of t_type . See https://github.com/starlite-api/starlite/issues/367 Parameters: Name Type Description Default value Any The value to check if is class and subclass of t_type . required t_type Type [ T ] Type used for issubclass() check of value required Returns: Type Description TypeGuard [ Type [ T ]] bool","title":"is_class_and_subclass()"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_dataclass_class_or_instance_typeguard","text":"starlite . utils . predicates . is_dataclass_class_or_instance_typeguard ( value ) Wrap is_dataclass() in a TypeGuard . Parameters: Name Type Description Default value Any tested to determine if instance or type of dataclass . required Returns: Type Description TypeGuard[DataclassClassOrInstance] True if instance or type of dataclass .","title":"is_dataclass_class_or_instance_typeguard()"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_dataclass_class_typeguard","text":"starlite . utils . predicates . is_dataclass_class_typeguard ( value ) Wrap is_dataclass() in a TypeGuard , narrowing to type only, not instance. Parameters: Name Type Description Default value Any tested to determine if type of dataclass . required Returns: Type Description TypeGuard[DataclassClass] True if value is a dataclass type.","title":"is_dataclass_class_typeguard()"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_optional_union","text":"starlite . utils . predicates . is_optional_union ( annotation ) Given a type annotation determine if the annotation infers an optional union. Parameters: Name Type Description Default annotation Any A type. required Returns: Type Description bool True for a union, False otherwise.","title":"is_optional_union()"},{"location":"reference/utils/0-predicate-utils/#starlite.utils.predicates.is_typeddict_typeguard","text":"starlite . utils . predicates . is_typeddict_typeguard ( value ) Wrap is_typeddict() in a TypeGuard . Parameters: Name Type Description Default value Any tested to determine if instance or type of dataclass . required Returns: Type Description TypeGuard[TypedDictClass] True if instance or type of dataclass .","title":"is_typeddict_typeguard()"},{"location":"reference/utils/1-sync-utils/","text":"Async Utils starlite.utils.sync.P module-attribute starlite . utils . sync . P = ParamSpec ( 'P' ) starlite.utils.sync.T module-attribute starlite . utils . sync . T = TypeVar ( 'T' ) starlite.utils.is_async_callable starlite . utils . is_async_callable ( value ) Extend asyncio.iscoroutinefunction() to additionally detect async partial objects and class instances with async def __call__() defined. Parameters: Name Type Description Default value Callable [ P , T ] Any required Returns: Type Description TypeGuard [ Callable [ P , Awaitable [ T ]]] Bool determining if type of value is an awaitable. starlite.utils.AsyncCallable Bases: Generic [ P , T ] Wrap a callable into an asynchronous callable. __init__ __init__ ( fn ) Initialize the wrapper from any callable. Parameters: Name Type Description Default fn Callable [ P , T ] Callable to wrap - can be any sync or async callable. required __call__ async __call__ ( * args , ** kwargs ) Proxy the wrapped function's call method. Parameters: Name Type Description Default *args P . args Args of the wrapped function. () **kwargs P . kwargs Kwargs of the wrapper function. {} Returns: Type Description T The return value of the wrapped function. starlite.utils.as_async_callable_list starlite . utils . as_async_callable_list ( value ) Wrap callables in AsyncCallable s. Parameters: Name Type Description Default value Union [ Callable , List [ Callable ]] A callable or list of callables. required Returns: Type Description List [ AsyncCallable ] A list of AsyncCallable instances starlite.utils.async_partial starlite . utils . async_partial ( fn ) Wrap a given sync function making it async. In difference to the 'asyncio.run_sync' function, it allows for passing kwargs. Parameters: Name Type Description Default fn Callable A sync callable to wrap. required Returns: Type Description Callable A wrapper starlite.utils.AsyncIteratorWrapper Bases: Generic [ T ] Asynchronous generator, wrapping an iterable or iterator. __init__ __init__ ( iterator ) Take a sync iterator or iterable and yields values from it asynchronously. Parameters: Name Type Description Default iterator Union [ Iterator [ T ], Iterable [ T ]] A sync iterator or iterable. required","title":"Async Utils"},{"location":"reference/utils/1-sync-utils/#async-utils","text":"","title":"Async Utils"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.P","text":"starlite . utils . sync . P = ParamSpec ( 'P' )","title":"P"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.T","text":"starlite . utils . sync . T = TypeVar ( 'T' )","title":"T"},{"location":"reference/utils/1-sync-utils/#starlite.utils.is_async_callable","text":"starlite . utils . is_async_callable ( value ) Extend asyncio.iscoroutinefunction() to additionally detect async partial objects and class instances with async def __call__() defined. Parameters: Name Type Description Default value Callable [ P , T ] Any required Returns: Type Description TypeGuard [ Callable [ P , Awaitable [ T ]]] Bool determining if type of value is an awaitable.","title":"is_async_callable()"},{"location":"reference/utils/1-sync-utils/#starlite.utils.AsyncCallable","text":"Bases: Generic [ P , T ] Wrap a callable into an asynchronous callable.","title":"AsyncCallable"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.AsyncCallable.__init__","text":"__init__ ( fn ) Initialize the wrapper from any callable. Parameters: Name Type Description Default fn Callable [ P , T ] Callable to wrap - can be any sync or async callable. required","title":"__init__()"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.AsyncCallable.__call__","text":"__call__ ( * args , ** kwargs ) Proxy the wrapped function's call method. Parameters: Name Type Description Default *args P . args Args of the wrapped function. () **kwargs P . kwargs Kwargs of the wrapper function. {} Returns: Type Description T The return value of the wrapped function.","title":"__call__()"},{"location":"reference/utils/1-sync-utils/#starlite.utils.as_async_callable_list","text":"starlite . utils . as_async_callable_list ( value ) Wrap callables in AsyncCallable s. Parameters: Name Type Description Default value Union [ Callable , List [ Callable ]] A callable or list of callables. required Returns: Type Description List [ AsyncCallable ] A list of AsyncCallable instances","title":"as_async_callable_list()"},{"location":"reference/utils/1-sync-utils/#starlite.utils.async_partial","text":"starlite . utils . async_partial ( fn ) Wrap a given sync function making it async. In difference to the 'asyncio.run_sync' function, it allows for passing kwargs. Parameters: Name Type Description Default fn Callable A sync callable to wrap. required Returns: Type Description Callable A wrapper","title":"async_partial()"},{"location":"reference/utils/1-sync-utils/#starlite.utils.AsyncIteratorWrapper","text":"Bases: Generic [ T ] Asynchronous generator, wrapping an iterable or iterator.","title":"AsyncIteratorWrapper"},{"location":"reference/utils/1-sync-utils/#starlite.utils.sync.AsyncIteratorWrapper.__init__","text":"__init__ ( iterator ) Take a sync iterator or iterable and yields values from it asynchronously. Parameters: Name Type Description Default iterator Union [ Iterator [ T ], Iterable [ T ]] A sync iterator or iterable. required","title":"__init__()"},{"location":"reference/utils/2-scope-utils/","text":"Scope Utils starlite.utils.get_serializer_from_scope starlite . utils . get_serializer_from_scope ( scope ) Return a serializer given a scope object. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description Optional [ Serializer ] A serializer function","title":"Scope Utils"},{"location":"reference/utils/2-scope-utils/#scope-utils","text":"","title":"Scope Utils"},{"location":"reference/utils/2-scope-utils/#starlite.utils.get_serializer_from_scope","text":"starlite . utils . get_serializer_from_scope ( scope ) Return a serializer given a scope object. Parameters: Name Type Description Default scope Scope The ASGI connection scope. required Returns: Type Description Optional [ Serializer ] A serializer function","title":"get_serializer_from_scope()"},{"location":"reference/utils/3-exception-utils/","text":"Exception Utils starlite.utils.get_exception_handler starlite . utils . get_exception_handler ( exception_handlers , exc ) Given a dictionary that maps exceptions and status codes to handler functions, and an exception, returns the appropriate handler if existing. Status codes are given preference over exception type. If no status code match exists, each class in the MRO of the exception type is checked and the first matching handler is returned. Finally, if a 500 handler is registered, it will be returned for any exception that isn't a subclass of HTTPException . Parameters: Name Type Description Default exception_handlers ExceptionHandlersMap Mapping of status codes and exception types to handlers. required exc Exception Exception Instance to be resolved to a handler. required Returns: Type Description Optional [ ExceptionHandler ] Optional exception handler callable. starlite.utils.ExceptionResponseContent Bases: BaseModel Represent the contents of an exception-response. starlite.utils.create_exception_response starlite . utils . create_exception_response ( exc ) Construct a response from an exception. Notes: - For instances of HTTPException or other exception classes that have a status_code attribute (e.g. Starlette exceptions), the status code is drawn from the exception, otherwise response status is HTTP_500_INTERNAL_SERVER_ERROR . Parameters: Name Type Description Default exc Exception An exception. required Returns: Name Type Description Response Response HTTP response constructed from exception details.","title":"Exception Utils"},{"location":"reference/utils/3-exception-utils/#exception-utils","text":"","title":"Exception Utils"},{"location":"reference/utils/3-exception-utils/#starlite.utils.get_exception_handler","text":"starlite . utils . get_exception_handler ( exception_handlers , exc ) Given a dictionary that maps exceptions and status codes to handler functions, and an exception, returns the appropriate handler if existing. Status codes are given preference over exception type. If no status code match exists, each class in the MRO of the exception type is checked and the first matching handler is returned. Finally, if a 500 handler is registered, it will be returned for any exception that isn't a subclass of HTTPException . Parameters: Name Type Description Default exception_handlers ExceptionHandlersMap Mapping of status codes and exception types to handlers. required exc Exception Exception Instance to be resolved to a handler. required Returns: Type Description Optional [ ExceptionHandler ] Optional exception handler callable.","title":"get_exception_handler()"},{"location":"reference/utils/3-exception-utils/#starlite.utils.ExceptionResponseContent","text":"Bases: BaseModel Represent the contents of an exception-response.","title":"ExceptionResponseContent"},{"location":"reference/utils/3-exception-utils/#starlite.utils.create_exception_response","text":"starlite . utils . create_exception_response ( exc ) Construct a response from an exception. Notes: - For instances of HTTPException or other exception classes that have a status_code attribute (e.g. Starlette exceptions), the status code is drawn from the exception, otherwise response status is HTTP_500_INTERNAL_SERVER_ERROR . Parameters: Name Type Description Default exc Exception An exception. required Returns: Name Type Description Response Response HTTP response constructed from exception details.","title":"create_exception_response()"},{"location":"reference/utils/4-extractor-utils/","text":"Extraction Utils starlite.utils.extractors.ResponseExtractorField module-attribute starlite . utils . extractors . ResponseExtractorField = Literal [ \"status_code\" , \"headers\" , \"body\" , \"cookies\" ] starlite.utils.extractors.ConnectionDataExtractor Utility class to extract data from an. ASGIConnection , Request or WebSocket instance. __init__ __init__ ( extract_body = True , extract_client = True , extract_content_type = True , extract_cookies = True , extract_headers = True , extract_method = True , extract_path = True , extract_path_params = True , extract_query = True , extract_scheme = True , obfuscate_cookies = None , obfuscate_headers = None , parse_body = False , parse_query = False , ) Initialize ConnectionDataExtractor Parameters: Name Type Description Default extract_body bool Whether to extract body, (for requests only). True extract_client bool Whether to extract the client (host, port) mapping. True extract_content_type bool Whether to extract the content type and any options. True extract_cookies bool Whether to extract cookies. True extract_headers bool Whether to extract headers. True extract_method bool Whether to extract the HTTP method, (for requests only). True extract_path bool Whether to extract the path. True extract_path_params bool Whether to extract path parameters. True extract_query bool Whether to extract query parameters. True extract_scheme bool Whether to extract the http scheme. True obfuscate_headers Optional [ Set [ str ]] headers keys to obfuscate. Obfuscated values are replaced with ' * '. None obfuscate_cookies Optional [ Set [ str ]] cookie keys to obfuscate. Obfuscated values are replaced with ' * '. None parse_body bool Whether to parse the body value or return the raw byte string, (for requests only). False parse_query bool Whether to parse query parameters or return the raw byte string. False __call__ __call__ ( connection ) Extract data from the connection, returning a dictionary of values. Notes The value for 'body' - if present - is an unresolved Coroutine and as such should be awaited by the receiver. Parameters: Name Type Description Default connection ASGIConnection[Any, Any, Any] An ASGI connection or its subclasses. required Returns: Type Description ExtractedRequestData A string keyed dictionary of extracted values. starlite.utils.extractors.ExtractedResponseData Bases: TypedDict Dictionary representing extracted response data. starlite.utils.extractors.ResponseExtractorField module-attribute starlite . utils . extractors . ResponseExtractorField = Literal [ \"status_code\" , \"headers\" , \"body\" , \"cookies\" ] starlite.utils.extractors.RequestExtractorField module-attribute starlite . utils . extractors . RequestExtractorField = Literal [ \"path\" , \"method\" , \"content_type\" , \"headers\" , \"cookies\" , \"query\" , \"path_params\" , \"body\" , \"scheme\" , \"client\" , ] starlite.utils.extractors.ExtractedRequestData Bases: TypedDict Dictionary representing extracted request data. starlite.utils.extractors.obfuscate starlite . utils . extractors . obfuscate ( values , fields_to_obfuscate ) Obfuscate values in a dictionary, replacing values with ****** Parameters: Name Type Description Default values Dict [ str , Any ] A dictionary of strings required fields_to_obfuscate Set [ str ] keys to obfuscate required Returns: Type Description Dict [ str , Any ] A dictionary with obfuscated strings","title":"Extraction Utils"},{"location":"reference/utils/4-extractor-utils/#extraction-utils","text":"","title":"Extraction Utils"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ResponseExtractorField","text":"starlite . utils . extractors . ResponseExtractorField = Literal [ \"status_code\" , \"headers\" , \"body\" , \"cookies\" ]","title":"ResponseExtractorField"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ConnectionDataExtractor","text":"Utility class to extract data from an. ASGIConnection , Request or WebSocket instance.","title":"ConnectionDataExtractor"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ConnectionDataExtractor.__init__","text":"__init__ ( extract_body = True , extract_client = True , extract_content_type = True , extract_cookies = True , extract_headers = True , extract_method = True , extract_path = True , extract_path_params = True , extract_query = True , extract_scheme = True , obfuscate_cookies = None , obfuscate_headers = None , parse_body = False , parse_query = False , ) Initialize ConnectionDataExtractor Parameters: Name Type Description Default extract_body bool Whether to extract body, (for requests only). True extract_client bool Whether to extract the client (host, port) mapping. True extract_content_type bool Whether to extract the content type and any options. True extract_cookies bool Whether to extract cookies. True extract_headers bool Whether to extract headers. True extract_method bool Whether to extract the HTTP method, (for requests only). True extract_path bool Whether to extract the path. True extract_path_params bool Whether to extract path parameters. True extract_query bool Whether to extract query parameters. True extract_scheme bool Whether to extract the http scheme. True obfuscate_headers Optional [ Set [ str ]] headers keys to obfuscate. Obfuscated values are replaced with ' * '. None obfuscate_cookies Optional [ Set [ str ]] cookie keys to obfuscate. Obfuscated values are replaced with ' * '. None parse_body bool Whether to parse the body value or return the raw byte string, (for requests only). False parse_query bool Whether to parse query parameters or return the raw byte string. False","title":"__init__()"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ConnectionDataExtractor.__call__","text":"__call__ ( connection ) Extract data from the connection, returning a dictionary of values. Notes The value for 'body' - if present - is an unresolved Coroutine and as such should be awaited by the receiver. Parameters: Name Type Description Default connection ASGIConnection[Any, Any, Any] An ASGI connection or its subclasses. required Returns: Type Description ExtractedRequestData A string keyed dictionary of extracted values.","title":"__call__()"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ExtractedResponseData","text":"Bases: TypedDict Dictionary representing extracted response data.","title":"ExtractedResponseData"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ResponseExtractorField","text":"starlite . utils . extractors . ResponseExtractorField = Literal [ \"status_code\" , \"headers\" , \"body\" , \"cookies\" ]","title":"ResponseExtractorField"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.RequestExtractorField","text":"starlite . utils . extractors . RequestExtractorField = Literal [ \"path\" , \"method\" , \"content_type\" , \"headers\" , \"cookies\" , \"query\" , \"path_params\" , \"body\" , \"scheme\" , \"client\" , ]","title":"RequestExtractorField"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.ExtractedRequestData","text":"Bases: TypedDict Dictionary representing extracted request data.","title":"ExtractedRequestData"},{"location":"reference/utils/4-extractor-utils/#starlite.utils.extractors.obfuscate","text":"starlite . utils . extractors . obfuscate ( values , fields_to_obfuscate ) Obfuscate values in a dictionary, replacing values with ****** Parameters: Name Type Description Default values Dict [ str , Any ] A dictionary of strings required fields_to_obfuscate Set [ str ] keys to obfuscate required Returns: Type Description Dict [ str , Any ] A dictionary with obfuscated strings","title":"obfuscate()"},{"location":"reference/utils/5-sequence-utils/","text":"Sequence Utils starlite.utils.sequence.T module-attribute starlite . utils . sequence . T = TypeVar ( 'T' ) starlite.utils.find_index starlite . utils . find_index ( target_list , predicate ) Find element in list given a key and value. List elements can be dicts or classes starlite.utils.unique starlite . utils . unique ( value ) Return all unique values in a given sequence or iterator.","title":"Sequence Utils"},{"location":"reference/utils/5-sequence-utils/#sequence-utils","text":"","title":"Sequence Utils"},{"location":"reference/utils/5-sequence-utils/#starlite.utils.sequence.T","text":"starlite . utils . sequence . T = TypeVar ( 'T' )","title":"T"},{"location":"reference/utils/5-sequence-utils/#starlite.utils.find_index","text":"starlite . utils . find_index ( target_list , predicate ) Find element in list given a key and value. List elements can be dicts or classes","title":"find_index()"},{"location":"reference/utils/5-sequence-utils/#starlite.utils.unique","text":"starlite . utils . unique ( value ) Return all unique values in a given sequence or iterator.","title":"unique()"},{"location":"reference/utils/6-path-utils/","text":"Path Utils starlite.utils.normalize_path starlite . utils . normalize_path ( path ) Normalize a given path by ensuring it starts with a slash and does not end with a slash. Parameters: Name Type Description Default path str Path string required Returns: Type Description str Path string starlite.utils.join_paths starlite . utils . join_paths ( paths ) Normalize and joins path fragments. Parameters: Name Type Description Default paths Iterable [ str ] An iterable of path fragments. required Returns: Type Description str A normalized joined path string.","title":"Path Utils"},{"location":"reference/utils/6-path-utils/#path-utils","text":"","title":"Path Utils"},{"location":"reference/utils/6-path-utils/#starlite.utils.normalize_path","text":"starlite . utils . normalize_path ( path ) Normalize a given path by ensuring it starts with a slash and does not end with a slash. Parameters: Name Type Description Default path str Path string required Returns: Type Description str Path string","title":"normalize_path()"},{"location":"reference/utils/6-path-utils/#starlite.utils.join_paths","text":"starlite . utils . join_paths ( paths ) Normalize and joins path fragments. Parameters: Name Type Description Default paths Iterable [ str ] An iterable of path fragments. required Returns: Type Description str A normalized joined path string.","title":"join_paths()"},{"location":"reference/utils/7-serialization-utils/","text":"Serialization Utils starlite.utils.default_serializer starlite . utils . default_serializer ( value , type_encoders = None ) Transform values non-natively supported by msgspec Parameters: Name Type Description Default value Any A value to serialize# required type_encoders Optional [ Dict [ Any , Callable [[ Any ], Any ]]] Mapping of types to callables to transforming types None Returns: Type Description Any A serialized value Raises: Type Description TypeError if value is not supported","title":"Serialization Utils"},{"location":"reference/utils/7-serialization-utils/#serialization-utils","text":"","title":"Serialization Utils"},{"location":"reference/utils/7-serialization-utils/#starlite.utils.default_serializer","text":"starlite . utils . default_serializer ( value , type_encoders = None ) Transform values non-natively supported by msgspec Parameters: Name Type Description Default value Any A value to serialize# required type_encoders Optional [ Dict [ Any , Callable [[ Any ], Any ]]] Mapping of types to callables to transforming types None Returns: Type Description Any A serialized value Raises: Type Description TypeError if value is not supported","title":"default_serializer()"},{"location":"usage/0-the-starlite-app/","text":"The Starlite App Application object At the root of every Starlite application is an instance of the Starlite class. Typically, this code will be placed in a file called main.py at the project's root directory. Creating an app is straightforward \u2013 the only required arg is a list of Controllers , Routers or Route Handlers : Python 3.8+ Python 3.9+ Hello World from typing import Dict from starlite import Starlite , get @get ( \"/\" ) def hello_world () -> Dict [ str , str ]: \"\"\"Handler function that returns a greeting dictionary.\"\"\" return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ hello_world ]) Hello World from starlite import Starlite , get @get ( \"/\" ) def hello_world () -> dict [ str , str ]: \"\"\"Handler function that returns a greeting dictionary.\"\"\" return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ hello_world ]) Run it > curl http://127.0.0.1:8000/ { \"hello\" : \"world\" } The app instance is the root level of the app - it has the base path of / and all root level Controllers, Routers and Route Handlers should be registered on it. Learn more To learn more about registering routes, check out this chapter in the documentation: registering routes See the API Reference for details on the Starlite class and the kwargs it accepts. Startup and Shutdown You can pass a list of callables - either sync or async functions, methods or class instances - to the on_startup / on_shutdown kwargs of the Starlite instance . Those will be called in order, once the ASGI server (uvicorn, daphne etc.) emits the respective event. flowchart LR Startup[ASGI-Event: lifespan.startup] --> before_startup --> on_startup --> after_startup Shutdown[ASGI-Event: lifespan.shutdown] --> before_shutdown --> on_shutdown --> after_shutdown A classic use case for this is database connectivity. Often, we want to establish a database connection on application startup, and then close it gracefully upon shutdown. For example, lets create a database connection using the async engine from SQLAlchemy . We create two functions, one to get or establish the connection, and another to close it, and then pass them to the Starlite constructor: Startup and Shutdown from typing import cast from pydantic import BaseSettings from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlite import Starlite , State class AppSettings ( BaseSettings ): DATABASE_URI : str = \"postgresql+asyncpg://postgres:mysecretpassword@pg.db:5432/db\" settings = AppSettings () def get_db_connection ( state : State ) -> AsyncEngine : \"\"\"Returns the db engine. If it doesn't exist, creates it and saves it in on the application state object \"\"\" if not getattr ( state , \"engine\" , None ): state . engine = create_async_engine ( settings . DATABASE_URI ) return cast ( \"AsyncEngine\" , state . engine ) async def close_db_connection ( state : State ) -> None : \"\"\"Closes the db connection stored in the application State object.\"\"\" if getattr ( state , \"engine\" , None ): await cast ( \"AsyncEngine\" , state . engine ) . dispose () app = Starlite ( route_handlers = [], on_startup = [ get_db_connection ], on_shutdown = [ close_db_connection ]) Using Application State As seen in the examples for the on_startup / on_shutdown , callables passed to these hooks can receive an optional kwarg called state , which is the application's state object. The advantage of using application state , is that it can be accessed during multiple stages of the connection, and it can be injected into dependencies and route handlers. The Application State is an instance of the State datastructure, and it is accessible via the app.state attribute. As such it can be accessed wherever the app instance is accessible. It's important to understand in this context that the application instance is injected into the ASGI scope mapping for each connection (i.e. request or websocket connection) as scope[\"app\"].state . This makes the application accessible wherever the scope mapping is available, e.g. in middleware, on Request and Websocket instances (accessible as request.app / socket.app ) and many other places. Therefore, state offers an easy way to share contextual data between disparate parts of the application, as seen below: Using Application State import logging from typing import TYPE_CHECKING , Any from starlite import Provide , Request , Starlite , State , get if TYPE_CHECKING : from starlite.types import ASGIApp , Receive , Scope , Send logger = logging . getLogger ( __name__ ) def set_state_on_startup ( state : State ) -> None : \"\"\"Startup and shutdown hooks can receive `State` as a keyword arg.\"\"\" state . value = \"abc123\" def middleware_factory ( * , app : \"ASGIApp\" ) -> \"ASGIApp\" : \"\"\"A middleware can access application state via `scope`.\"\"\" async def my_middleware ( scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" ) -> None : state = scope [ \"app\" ] . state logger . info ( \"state value in middleware: %s \" , state . value ) await app ( scope , receive , send ) return my_middleware def my_dependency ( state : State ) -> Any : \"\"\"Dependencies can receive state via injection.\"\"\" logger . info ( \"state value in dependency: %s \" , state . value ) @get ( \"/\" , dependencies = { \"dep\" : Provide ( my_dependency )}, middleware = [ middleware_factory ]) def get_handler ( state : State , request : Request , dep : Any ) -> None : # pylint: disable=unused-argument \"\"\"Handlers can receive state via injection.\"\"\" logger . info ( \"state value in handler from `State`: %s \" , state . value ) logger . info ( \"state value in handler from `Request`: %s \" , request . app . state . value ) app = Starlite ( route_handlers = [ get_handler ], on_startup = [ set_state_on_startup ], debug = True ) Initializing Application State You can pass an object from which the application state will be instantiated using the initial_state kwarg of the Starlite constructor: Using Application State from starlite import Starlite , State , get @get ( \"/\" ) def handler ( state : State ) -> dict : return state . dict () app = Starlite ( route_handlers = [ handler ], initial_state = { \"count\" : 100 }) Note The initial_state can be a dictionary, an instance of ImmutableState or State , or a list of tuples containing key/value pairs. Important Any value passed to initial_state will be deep copied - to prevent mutation from outside the application context. Injecting Application State into Route Handlers and Dependencies As seen in the above example, Starlite offers an easy way to inject state into route handlers and dependencies - simply by specifying state as a kwarg to the handler function. I.e., you can simply do this in handler function or dependency to access the application state: from starlite import get , State @get ( \"/\" ) def handler ( state : State ) -> None : ... When using this pattern you can specify the class to use for the state object. This type is not merely for type checkers, rather Starlite will instantiate a new state instance based on the type you set there. This allows users to use custom classes for State, e.g.: While this is very powerful, it might encourage users to follow anti-patterns: it's important to emphasize that using state can lead to code that's hard to reason about and bugs that are difficult to understand, due to changes in different ASGI contexts. As such, this pattern should be used only when it is the best choice and in a limited fashion. To discourage its use, Starlite also offers a builtin ImmutableState class. You can use this class to type state and ensure that no mutation of state is allowed: Using Custom State from starlite import ImmutableState , Starlite , get @get ( \"/\" ) def handler ( state : ImmutableState ) -> dict : setattr ( state , \"count\" , 1 ) # raises AttributeError return state . dict () app = Starlite ( route_handlers = [ handler ]) Static Files Static files are served by the app from predefined locations. To configure static file serving, either pass an instance of StaticFilesConfig or a list thereof to the Starlite constructor using the static_files_config kwarg. For example, lets say our Starlite app is going to serve regular files from the my_app/static folder and html documents from the my_app/html folder, and we would like to serve the static files on the /files path, and the html files on the /html path: from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/files\" ), StaticFilesConfig ( directories = [ \"html\" ], path = \"/html\" , html_mode = True ), ], ) Matching is done based on filename, for example, assume we have a request that is trying to retrieve the path /files/file.txt , the directory for the base path /files will be searched for the file file.txt . If it is found, the file will be sent, otherwise a 404 response will be sent. If html_mode is enabled and no specific file is requested, the application will fall back to serving index.html . If no file is found the application will look for a 404.html file in order to render a response, otherwise a 404 NotFoundException will be returned. You can provide a name parameter to StaticFilesConfig to identify the given config and generate links to files in folders belonging to that config. name should be a unique string across all static configs and route handlers . from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/some_folder/static/path\" , name = \"static\" ), ], ) url_path = app . url_for_static_asset ( \"static\" , \"file.pdf\" ) # /some_folder/static/path/file.pdf Sending files as attachments By default, files are sent \"inline\", meaning they will have a Content-Disposition: inline header. To send them as attachments, use the send_as_attachment=True flag, which will add a Content-Disposition: attachment header: from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/some_folder/static/path\" , name = \"static\" , send_as_attachment = True , ), ], ) File System support and Cloud Files The StaticFilesConfig class accepts a value called file_system , which can be any class adhering to the Starlite FileSystemProtocol . This protocol is similar to the file systems defined by fsspec , which cover all major cloud providers and a wide range of other use cases (e.g. HTTP based file service, ftp etc.). In order to use any file system, simply use fsspec or one of the libraries based upon it, or provide a custom implementation adhering to the FileSystemProtocol . Logging Starlite has builtin pydantic based logging configuration that allows users to easily define logging: from starlite import Starlite , LoggingConfig , Request , get @get ( \"/\" ) def my_router_handler ( request : Request ) -> None : request . logger . info ( \"inside a request\" ) return None logging_config = LoggingConfig ( loggers = { \"my_app\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ], } } ) app = Starlite ( route_handlers = [ my_router_handler ], logging_config = logging_config ) Important Starlite configures a non-blocking QueueListenerHandler which is keyed as queue_listener in the logging configuration. The above example is using this handler, which is optimal for async applications. Make sure to use it in your own loggers as in the above example. Using Picologging Picologging is a high performance logging library that is developed by Microsoft. Starlite will default to using this library automatically if its installed - requiring zero configuration on the part of the user. That is, if picologging is present the previous example will work with it automatically. Using StructLog StructLog is a powerful structured-logging library. Starlite ships with a dedicated logging config for using it: from starlite import Starlite , StructLoggingConfig , Request , get @get ( \"/\" ) def my_router_handler ( request : Request ) -> None : request . logger . info ( \"inside a request\" ) return None logging_config = StructLoggingConfig () app = Starlite ( route_handlers = [ my_router_handler ], logging_config = logging_config ) Subclass Logging Configs You can easily create you own LoggingConfig class by subclassing BaseLoggingConfig and implementing the configure method. Application Hooks Starlite includes several application level hooks that allow users to run their own sync or async callables. While you are free to use these hooks as you see fit, the design intention behind them is to allow for easy instrumentation for observability (monitoring, tracing, logging etc.). Note All application hook kwargs detailed below receive either a single callable or a list of callables. If a list is provided, it is called in the order it is given. Before / After Startup The before_startup and after_startup hooks take a sync or async callable that receives the Starlite application as an argument and run during the ASGI startup event. The callable is invoked respectively before or after the list of callables defined in the on_startup list of callables. Before and After Startup Hooks import logging from asyncio import sleep from datetime import datetime from starlite import Starlite logger = logging . getLogger () async def startup_callable () -> None : \"\"\"Function called during 'on_startup'.\"\"\" await sleep ( 0.5 ) def before_startup_handler ( app_instance : Starlite ) -> None : \"\"\"Function called before 'on_startup'.\"\"\" start_time = datetime . now () app_instance . state . start_time = start_time . timestamp () logger . info ( \"startup sequence begin at %s \" , start_time . isoformat ()) def after_startup_handler ( app_instance : Starlite ) -> None : \"\"\"Function called after 'on_startup'.\"\"\" logger . info ( \"startup sequence ended at: %s , time elapsed: %d \" , datetime . now () . isoformat (), datetime . now () . timestamp () - app_instance . state . start_time , ) app = Starlite ( [], on_startup = [ startup_callable ], before_startup = before_startup_handler , after_startup = after_startup_handler , ) Before / After Shutdown The before_shutdown and after_shutdown are basically identical, with the difference being that the callable they receive in callable is invoked respectively before or after the list of callables defined in the on_shutdown list of callables. Before and After Shutdown Hooks import logging from asyncio import sleep from datetime import datetime from starlite import Starlite logger = logging . getLogger () async def shutdown_callable () -> None : \"\"\"Function called during 'on_shutdown'.\"\"\" await sleep ( 0.5 ) def before_shutdown_handler ( app_instance : Starlite ) -> None : \"\"\"Function called before 'on_shutdown'.\"\"\" start_time = datetime . now () app_instance . state . start_time = start_time . timestamp () logger . info ( \"shutdown sequence begin at %s \" , start_time . isoformat ()) def after_shutdown_handler ( app_instance : Starlite ) -> None : \"\"\"Function called after 'on_shutdown'.\"\"\" logger . info ( \"shutdown sequence ended at: %s , time elapsed: %d \" , datetime . now () . isoformat (), datetime . now () . timestamp () - app_instance . state . start_time , ) app = Starlite ( [], on_shutdown = [ shutdown_callable ], before_shutdown = before_shutdown_handler , after_shutdown = after_shutdown_handler , ) After Exception The after_exception hook takes a sync or async callable that is called with three arguments: the exception that occurred, the ASGI scope of the request or websocket connection and the application state . After Exception Hook import logging from typing import TYPE_CHECKING from starlite import HTTPException , Starlite , get from starlite.status_codes import HTTP_400_BAD_REQUEST logger = logging . getLogger () if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Scope @get ( \"/some-path\" ) def my_handler () -> None : \"\"\"Route handler that raises an exception.\"\"\" raise HTTPException ( detail = \"bad request\" , status_code = HTTP_400_BAD_REQUEST ) async def after_exception_handler ( exc : Exception , scope : \"Scope\" , state : \"State\" ) -> None : \"\"\"Hook function that will be invoked after each exception.\"\"\" if not hasattr ( state , \"error_count\" ): state . error_count = 1 else : state . error_count += 1 logger . info ( \"an exception of type %s has occurred for requested path %s and the application error count is %d .\" , type ( exc ) . __name__ , scope [ \"path\" ], state . error_count , ) app = Starlite ([ my_handler ], after_exception = after_exception_handler ) Important This hook is not meant to handle exceptions - it just receives them to allow for side effects. To handle exceptions you should define exception handlers . Before Send The before_send hook takes a sync or async callable that is called when an ASGI message is sent. The hook receives the message instance and the application state. Python 3.8+ Python 3.9+ Before Send Hook from typing import TYPE_CHECKING , Dict from starlite import Starlite , get from starlite.datastructures import MutableScopeHeaders if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Message @get ( \"/test\" ) def handler () -> Dict [ str , str ]: \"\"\"Example Handler function.\"\"\" return { \"key\" : \"value\" } async def before_send_hook_handler ( message : \"Message\" , state : \"State\" ) -> None : \"\"\"The function will be called on each ASGI message. We therefore ensure it runs only on the message start event. \"\"\" if message [ \"type\" ] == \"http.response.start\" : headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"My Header\" ] = state . message def on_startup ( state : \"State\" ) -> None : \"\"\"A function that will populate the app state before any requests are received.\"\"\" state . message = \"value injected during send\" app = Starlite ( route_handlers = [ handler ], on_startup = [ on_startup ], before_send = before_send_hook_handler ) Before Send Hook from typing import TYPE_CHECKING from starlite import Starlite , get from starlite.datastructures import MutableScopeHeaders if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Message @get ( \"/test\" ) def handler () -> dict [ str , str ]: \"\"\"Example Handler function.\"\"\" return { \"key\" : \"value\" } async def before_send_hook_handler ( message : \"Message\" , state : \"State\" ) -> None : \"\"\"The function will be called on each ASGI message. We therefore ensure it runs only on the message start event. \"\"\" if message [ \"type\" ] == \"http.response.start\" : headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"My Header\" ] = state . message def on_startup ( state : \"State\" ) -> None : \"\"\"A function that will populate the app state before any requests are received.\"\"\" state . message = \"value injected during send\" app = Starlite ( route_handlers = [ handler ], on_startup = [ on_startup ], before_send = before_send_hook_handler ) Application Init Starlite includes a hook for intercepting the arguments passed to the Starlite constructor , before they are used to instantiate the application. Handlers can be passed to the on_app_init parameter on construction of the application, and in turn, each will receive an instance of AppConfig and must return an instance of same. This hook is useful for applying common configuration between applications, and for use by developers who may wish to develop third-party application configuration systems. Note on_app_init handlers cannot be async def functions, as they are called within Starlite.__init__() , outside of an async context. After Exception Hook from typing import TYPE_CHECKING from starlite import Starlite if TYPE_CHECKING : from starlite.config import AppConfig async def close_db_connection () -> None : \"\"\"Closes the database connection on application shutdown.\"\"\" def receive_app_config ( app_config : \"AppConfig\" ) -> \"AppConfig\" : \"\"\"Receives parameters from the application. In reality, this would be a library of boilerplate that is carried from one application to another, or a third-party developed application configuration tool. \"\"\" app_config . on_shutdown . append ( close_db_connection ) return app_config app = Starlite ([], on_app_init = [ receive_app_config ]) Layered architecture Starlite has a layered architecture compromising of (generally speaking) 4 layers: The application object Routers Controllers Handlers There are many parameters that can be defined on every layer, in which case the parameter defined on the layer closest to the handler takes precedence. This allows for maximum flexibility and simplicity when configuring complex applications and enables transparent overriding of parameters. Parameters that support layering are: after_request after_response before_request cache_control dependencies etag exception_handlers guards middleware opt response_class response_cookies response_headers security tags","title":"The Starlite App"},{"location":"usage/0-the-starlite-app/#the-starlite-app","text":"","title":"The Starlite App"},{"location":"usage/0-the-starlite-app/#application-object","text":"At the root of every Starlite application is an instance of the Starlite class. Typically, this code will be placed in a file called main.py at the project's root directory. Creating an app is straightforward \u2013 the only required arg is a list of Controllers , Routers or Route Handlers : Python 3.8+ Python 3.9+ Hello World from typing import Dict from starlite import Starlite , get @get ( \"/\" ) def hello_world () -> Dict [ str , str ]: \"\"\"Handler function that returns a greeting dictionary.\"\"\" return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ hello_world ]) Hello World from starlite import Starlite , get @get ( \"/\" ) def hello_world () -> dict [ str , str ]: \"\"\"Handler function that returns a greeting dictionary.\"\"\" return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ hello_world ]) Run it > curl http://127.0.0.1:8000/ { \"hello\" : \"world\" } The app instance is the root level of the app - it has the base path of / and all root level Controllers, Routers and Route Handlers should be registered on it. Learn more To learn more about registering routes, check out this chapter in the documentation: registering routes See the API Reference for details on the Starlite class and the kwargs it accepts.","title":"Application object"},{"location":"usage/0-the-starlite-app/#startup-and-shutdown","text":"You can pass a list of callables - either sync or async functions, methods or class instances - to the on_startup / on_shutdown kwargs of the Starlite instance . Those will be called in order, once the ASGI server (uvicorn, daphne etc.) emits the respective event. flowchart LR Startup[ASGI-Event: lifespan.startup] --> before_startup --> on_startup --> after_startup Shutdown[ASGI-Event: lifespan.shutdown] --> before_shutdown --> on_shutdown --> after_shutdown A classic use case for this is database connectivity. Often, we want to establish a database connection on application startup, and then close it gracefully upon shutdown. For example, lets create a database connection using the async engine from SQLAlchemy . We create two functions, one to get or establish the connection, and another to close it, and then pass them to the Starlite constructor: Startup and Shutdown from typing import cast from pydantic import BaseSettings from sqlalchemy.ext.asyncio import AsyncEngine , create_async_engine from starlite import Starlite , State class AppSettings ( BaseSettings ): DATABASE_URI : str = \"postgresql+asyncpg://postgres:mysecretpassword@pg.db:5432/db\" settings = AppSettings () def get_db_connection ( state : State ) -> AsyncEngine : \"\"\"Returns the db engine. If it doesn't exist, creates it and saves it in on the application state object \"\"\" if not getattr ( state , \"engine\" , None ): state . engine = create_async_engine ( settings . DATABASE_URI ) return cast ( \"AsyncEngine\" , state . engine ) async def close_db_connection ( state : State ) -> None : \"\"\"Closes the db connection stored in the application State object.\"\"\" if getattr ( state , \"engine\" , None ): await cast ( \"AsyncEngine\" , state . engine ) . dispose () app = Starlite ( route_handlers = [], on_startup = [ get_db_connection ], on_shutdown = [ close_db_connection ])","title":"Startup and Shutdown"},{"location":"usage/0-the-starlite-app/#using-application-state","text":"As seen in the examples for the on_startup / on_shutdown , callables passed to these hooks can receive an optional kwarg called state , which is the application's state object. The advantage of using application state , is that it can be accessed during multiple stages of the connection, and it can be injected into dependencies and route handlers. The Application State is an instance of the State datastructure, and it is accessible via the app.state attribute. As such it can be accessed wherever the app instance is accessible. It's important to understand in this context that the application instance is injected into the ASGI scope mapping for each connection (i.e. request or websocket connection) as scope[\"app\"].state . This makes the application accessible wherever the scope mapping is available, e.g. in middleware, on Request and Websocket instances (accessible as request.app / socket.app ) and many other places. Therefore, state offers an easy way to share contextual data between disparate parts of the application, as seen below: Using Application State import logging from typing import TYPE_CHECKING , Any from starlite import Provide , Request , Starlite , State , get if TYPE_CHECKING : from starlite.types import ASGIApp , Receive , Scope , Send logger = logging . getLogger ( __name__ ) def set_state_on_startup ( state : State ) -> None : \"\"\"Startup and shutdown hooks can receive `State` as a keyword arg.\"\"\" state . value = \"abc123\" def middleware_factory ( * , app : \"ASGIApp\" ) -> \"ASGIApp\" : \"\"\"A middleware can access application state via `scope`.\"\"\" async def my_middleware ( scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" ) -> None : state = scope [ \"app\" ] . state logger . info ( \"state value in middleware: %s \" , state . value ) await app ( scope , receive , send ) return my_middleware def my_dependency ( state : State ) -> Any : \"\"\"Dependencies can receive state via injection.\"\"\" logger . info ( \"state value in dependency: %s \" , state . value ) @get ( \"/\" , dependencies = { \"dep\" : Provide ( my_dependency )}, middleware = [ middleware_factory ]) def get_handler ( state : State , request : Request , dep : Any ) -> None : # pylint: disable=unused-argument \"\"\"Handlers can receive state via injection.\"\"\" logger . info ( \"state value in handler from `State`: %s \" , state . value ) logger . info ( \"state value in handler from `Request`: %s \" , request . app . state . value ) app = Starlite ( route_handlers = [ get_handler ], on_startup = [ set_state_on_startup ], debug = True )","title":"Using Application State"},{"location":"usage/0-the-starlite-app/#initializing-application-state","text":"You can pass an object from which the application state will be instantiated using the initial_state kwarg of the Starlite constructor: Using Application State from starlite import Starlite , State , get @get ( \"/\" ) def handler ( state : State ) -> dict : return state . dict () app = Starlite ( route_handlers = [ handler ], initial_state = { \"count\" : 100 }) Note The initial_state can be a dictionary, an instance of ImmutableState or State , or a list of tuples containing key/value pairs. Important Any value passed to initial_state will be deep copied - to prevent mutation from outside the application context.","title":"Initializing Application State"},{"location":"usage/0-the-starlite-app/#injecting-application-state-into-route-handlers-and-dependencies","text":"As seen in the above example, Starlite offers an easy way to inject state into route handlers and dependencies - simply by specifying state as a kwarg to the handler function. I.e., you can simply do this in handler function or dependency to access the application state: from starlite import get , State @get ( \"/\" ) def handler ( state : State ) -> None : ... When using this pattern you can specify the class to use for the state object. This type is not merely for type checkers, rather Starlite will instantiate a new state instance based on the type you set there. This allows users to use custom classes for State, e.g.: While this is very powerful, it might encourage users to follow anti-patterns: it's important to emphasize that using state can lead to code that's hard to reason about and bugs that are difficult to understand, due to changes in different ASGI contexts. As such, this pattern should be used only when it is the best choice and in a limited fashion. To discourage its use, Starlite also offers a builtin ImmutableState class. You can use this class to type state and ensure that no mutation of state is allowed: Using Custom State from starlite import ImmutableState , Starlite , get @get ( \"/\" ) def handler ( state : ImmutableState ) -> dict : setattr ( state , \"count\" , 1 ) # raises AttributeError return state . dict () app = Starlite ( route_handlers = [ handler ])","title":"Injecting Application State into Route Handlers and Dependencies"},{"location":"usage/0-the-starlite-app/#static-files","text":"Static files are served by the app from predefined locations. To configure static file serving, either pass an instance of StaticFilesConfig or a list thereof to the Starlite constructor using the static_files_config kwarg. For example, lets say our Starlite app is going to serve regular files from the my_app/static folder and html documents from the my_app/html folder, and we would like to serve the static files on the /files path, and the html files on the /html path: from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/files\" ), StaticFilesConfig ( directories = [ \"html\" ], path = \"/html\" , html_mode = True ), ], ) Matching is done based on filename, for example, assume we have a request that is trying to retrieve the path /files/file.txt , the directory for the base path /files will be searched for the file file.txt . If it is found, the file will be sent, otherwise a 404 response will be sent. If html_mode is enabled and no specific file is requested, the application will fall back to serving index.html . If no file is found the application will look for a 404.html file in order to render a response, otherwise a 404 NotFoundException will be returned. You can provide a name parameter to StaticFilesConfig to identify the given config and generate links to files in folders belonging to that config. name should be a unique string across all static configs and route handlers . from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/some_folder/static/path\" , name = \"static\" ), ], ) url_path = app . url_for_static_asset ( \"static\" , \"file.pdf\" ) # /some_folder/static/path/file.pdf","title":"Static Files"},{"location":"usage/0-the-starlite-app/#sending-files-as-attachments","text":"By default, files are sent \"inline\", meaning they will have a Content-Disposition: inline header. To send them as attachments, use the send_as_attachment=True flag, which will add a Content-Disposition: attachment header: from starlite import Starlite , StaticFilesConfig app = Starlite ( route_handlers = [ ... ], static_files_config = [ StaticFilesConfig ( directories = [ \"static\" ], path = \"/some_folder/static/path\" , name = \"static\" , send_as_attachment = True , ), ], )","title":"Sending files as attachments"},{"location":"usage/0-the-starlite-app/#file-system-support-and-cloud-files","text":"The StaticFilesConfig class accepts a value called file_system , which can be any class adhering to the Starlite FileSystemProtocol . This protocol is similar to the file systems defined by fsspec , which cover all major cloud providers and a wide range of other use cases (e.g. HTTP based file service, ftp etc.). In order to use any file system, simply use fsspec or one of the libraries based upon it, or provide a custom implementation adhering to the FileSystemProtocol .","title":"File System support and Cloud Files"},{"location":"usage/0-the-starlite-app/#logging","text":"Starlite has builtin pydantic based logging configuration that allows users to easily define logging: from starlite import Starlite , LoggingConfig , Request , get @get ( \"/\" ) def my_router_handler ( request : Request ) -> None : request . logger . info ( \"inside a request\" ) return None logging_config = LoggingConfig ( loggers = { \"my_app\" : { \"level\" : \"INFO\" , \"handlers\" : [ \"queue_listener\" ], } } ) app = Starlite ( route_handlers = [ my_router_handler ], logging_config = logging_config ) Important Starlite configures a non-blocking QueueListenerHandler which is keyed as queue_listener in the logging configuration. The above example is using this handler, which is optimal for async applications. Make sure to use it in your own loggers as in the above example.","title":"Logging"},{"location":"usage/0-the-starlite-app/#using-picologging","text":"Picologging is a high performance logging library that is developed by Microsoft. Starlite will default to using this library automatically if its installed - requiring zero configuration on the part of the user. That is, if picologging is present the previous example will work with it automatically.","title":"Using Picologging"},{"location":"usage/0-the-starlite-app/#using-structlog","text":"StructLog is a powerful structured-logging library. Starlite ships with a dedicated logging config for using it: from starlite import Starlite , StructLoggingConfig , Request , get @get ( \"/\" ) def my_router_handler ( request : Request ) -> None : request . logger . info ( \"inside a request\" ) return None logging_config = StructLoggingConfig () app = Starlite ( route_handlers = [ my_router_handler ], logging_config = logging_config )","title":"Using StructLog"},{"location":"usage/0-the-starlite-app/#subclass-logging-configs","text":"You can easily create you own LoggingConfig class by subclassing BaseLoggingConfig and implementing the configure method.","title":"Subclass Logging Configs"},{"location":"usage/0-the-starlite-app/#application-hooks","text":"Starlite includes several application level hooks that allow users to run their own sync or async callables. While you are free to use these hooks as you see fit, the design intention behind them is to allow for easy instrumentation for observability (monitoring, tracing, logging etc.). Note All application hook kwargs detailed below receive either a single callable or a list of callables. If a list is provided, it is called in the order it is given.","title":"Application Hooks"},{"location":"usage/0-the-starlite-app/#before-after-startup","text":"The before_startup and after_startup hooks take a sync or async callable that receives the Starlite application as an argument and run during the ASGI startup event. The callable is invoked respectively before or after the list of callables defined in the on_startup list of callables. Before and After Startup Hooks import logging from asyncio import sleep from datetime import datetime from starlite import Starlite logger = logging . getLogger () async def startup_callable () -> None : \"\"\"Function called during 'on_startup'.\"\"\" await sleep ( 0.5 ) def before_startup_handler ( app_instance : Starlite ) -> None : \"\"\"Function called before 'on_startup'.\"\"\" start_time = datetime . now () app_instance . state . start_time = start_time . timestamp () logger . info ( \"startup sequence begin at %s \" , start_time . isoformat ()) def after_startup_handler ( app_instance : Starlite ) -> None : \"\"\"Function called after 'on_startup'.\"\"\" logger . info ( \"startup sequence ended at: %s , time elapsed: %d \" , datetime . now () . isoformat (), datetime . now () . timestamp () - app_instance . state . start_time , ) app = Starlite ( [], on_startup = [ startup_callable ], before_startup = before_startup_handler , after_startup = after_startup_handler , )","title":"Before / After Startup"},{"location":"usage/0-the-starlite-app/#before-after-shutdown","text":"The before_shutdown and after_shutdown are basically identical, with the difference being that the callable they receive in callable is invoked respectively before or after the list of callables defined in the on_shutdown list of callables. Before and After Shutdown Hooks import logging from asyncio import sleep from datetime import datetime from starlite import Starlite logger = logging . getLogger () async def shutdown_callable () -> None : \"\"\"Function called during 'on_shutdown'.\"\"\" await sleep ( 0.5 ) def before_shutdown_handler ( app_instance : Starlite ) -> None : \"\"\"Function called before 'on_shutdown'.\"\"\" start_time = datetime . now () app_instance . state . start_time = start_time . timestamp () logger . info ( \"shutdown sequence begin at %s \" , start_time . isoformat ()) def after_shutdown_handler ( app_instance : Starlite ) -> None : \"\"\"Function called after 'on_shutdown'.\"\"\" logger . info ( \"shutdown sequence ended at: %s , time elapsed: %d \" , datetime . now () . isoformat (), datetime . now () . timestamp () - app_instance . state . start_time , ) app = Starlite ( [], on_shutdown = [ shutdown_callable ], before_shutdown = before_shutdown_handler , after_shutdown = after_shutdown_handler , )","title":"Before / After Shutdown"},{"location":"usage/0-the-starlite-app/#after-exception","text":"The after_exception hook takes a sync or async callable that is called with three arguments: the exception that occurred, the ASGI scope of the request or websocket connection and the application state . After Exception Hook import logging from typing import TYPE_CHECKING from starlite import HTTPException , Starlite , get from starlite.status_codes import HTTP_400_BAD_REQUEST logger = logging . getLogger () if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Scope @get ( \"/some-path\" ) def my_handler () -> None : \"\"\"Route handler that raises an exception.\"\"\" raise HTTPException ( detail = \"bad request\" , status_code = HTTP_400_BAD_REQUEST ) async def after_exception_handler ( exc : Exception , scope : \"Scope\" , state : \"State\" ) -> None : \"\"\"Hook function that will be invoked after each exception.\"\"\" if not hasattr ( state , \"error_count\" ): state . error_count = 1 else : state . error_count += 1 logger . info ( \"an exception of type %s has occurred for requested path %s and the application error count is %d .\" , type ( exc ) . __name__ , scope [ \"path\" ], state . error_count , ) app = Starlite ([ my_handler ], after_exception = after_exception_handler ) Important This hook is not meant to handle exceptions - it just receives them to allow for side effects. To handle exceptions you should define exception handlers .","title":"After Exception"},{"location":"usage/0-the-starlite-app/#before-send","text":"The before_send hook takes a sync or async callable that is called when an ASGI message is sent. The hook receives the message instance and the application state. Python 3.8+ Python 3.9+ Before Send Hook from typing import TYPE_CHECKING , Dict from starlite import Starlite , get from starlite.datastructures import MutableScopeHeaders if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Message @get ( \"/test\" ) def handler () -> Dict [ str , str ]: \"\"\"Example Handler function.\"\"\" return { \"key\" : \"value\" } async def before_send_hook_handler ( message : \"Message\" , state : \"State\" ) -> None : \"\"\"The function will be called on each ASGI message. We therefore ensure it runs only on the message start event. \"\"\" if message [ \"type\" ] == \"http.response.start\" : headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"My Header\" ] = state . message def on_startup ( state : \"State\" ) -> None : \"\"\"A function that will populate the app state before any requests are received.\"\"\" state . message = \"value injected during send\" app = Starlite ( route_handlers = [ handler ], on_startup = [ on_startup ], before_send = before_send_hook_handler ) Before Send Hook from typing import TYPE_CHECKING from starlite import Starlite , get from starlite.datastructures import MutableScopeHeaders if TYPE_CHECKING : from starlite.datastructures import State from starlite.types import Message @get ( \"/test\" ) def handler () -> dict [ str , str ]: \"\"\"Example Handler function.\"\"\" return { \"key\" : \"value\" } async def before_send_hook_handler ( message : \"Message\" , state : \"State\" ) -> None : \"\"\"The function will be called on each ASGI message. We therefore ensure it runs only on the message start event. \"\"\" if message [ \"type\" ] == \"http.response.start\" : headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"My Header\" ] = state . message def on_startup ( state : \"State\" ) -> None : \"\"\"A function that will populate the app state before any requests are received.\"\"\" state . message = \"value injected during send\" app = Starlite ( route_handlers = [ handler ], on_startup = [ on_startup ], before_send = before_send_hook_handler )","title":"Before Send"},{"location":"usage/0-the-starlite-app/#application-init","text":"Starlite includes a hook for intercepting the arguments passed to the Starlite constructor , before they are used to instantiate the application. Handlers can be passed to the on_app_init parameter on construction of the application, and in turn, each will receive an instance of AppConfig and must return an instance of same. This hook is useful for applying common configuration between applications, and for use by developers who may wish to develop third-party application configuration systems. Note on_app_init handlers cannot be async def functions, as they are called within Starlite.__init__() , outside of an async context. After Exception Hook from typing import TYPE_CHECKING from starlite import Starlite if TYPE_CHECKING : from starlite.config import AppConfig async def close_db_connection () -> None : \"\"\"Closes the database connection on application shutdown.\"\"\" def receive_app_config ( app_config : \"AppConfig\" ) -> \"AppConfig\" : \"\"\"Receives parameters from the application. In reality, this would be a library of boilerplate that is carried from one application to another, or a third-party developed application configuration tool. \"\"\" app_config . on_shutdown . append ( close_db_connection ) return app_config app = Starlite ([], on_app_init = [ receive_app_config ])","title":"Application Init"},{"location":"usage/0-the-starlite-app/#layered-architecture","text":"Starlite has a layered architecture compromising of (generally speaking) 4 layers: The application object Routers Controllers Handlers There are many parameters that can be defined on every layer, in which case the parameter defined on the layer closest to the handler takes precedence. This allows for maximum flexibility and simplicity when configuring complex applications and enables transparent overriding of parameters. Parameters that support layering are: after_request after_response before_request cache_control dependencies etag exception_handlers guards middleware opt response_class response_cookies response_headers security tags","title":"Layered architecture"},{"location":"usage/13-lifecycle-hooks/","text":"Life Cycle Hooks Life cycle hooks allows a user to execute a function at a certain point, as indicated by the hook's name, during the request-response cycle. Before Request The before_request hook runs immediately before calling the route handler function. It accepts either a sync or async function that receives the Request instance as its sole parameter. While the handler function does not need to return a value, if it does return a value other than None , then the route handler will not be called and this value will instead be used for the response. Thus, the before_request handler allows bypassing the route handler selectively. from starlite import Starlite , Request async def my_before_request_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], before_request = my_before_request_handler ) After Request The after_request hook is called after the route handler function returned and the response object has been resolved. It receives either a sync or async function that receives the Response object, which can be either an instance of starlite.response.Response or any subclass of the Starlette Response object. This function must return a Response object - either the one that was passed in, or a different one. The after_response hook allows users to modify responses, e.g. placing cookies or headers on them, or even to completely replace them given certain conditions. from starlite import Starlite , Response async def my_after_request_handler ( response : Response ) -> Response : ... app = Starlite ( route_handlers = [ ... ], after_request = my_after_request_handler ) After Response The after_response hook is called after the response has been awaited, that is - after a response has been sent to the requester. It receives either a sync or async function that receives the Request object. The function should not return any values. This hook is meant for data post-processing, transmission of data to third party services, gathering of metrics etc. from starlite import Starlite , Request async def my_after_response_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], after_response = my_after_response_handler ) Overriding Handlers You can configure life cycle hook handlers on all layers of your application, that is - on the Starlite instance itself, on routers, controllers or individual route handlers. Each layer overrides the layer above it - thus, the handlers defined for a specific function will override those defined on its router, which will in turn override those defined on the app level. from starlite import Starlite , Router , Controller , get # this overrides the router and app class MyController ( Controller ): path = \"/my-path\" # this overrides the controller, router and app @get ( after_request =... , before_request =... ) def my_handler ( self ) -> None : ... # this overrides the app, for all routes below the router these functions will be used router = Router ( route_handlers = [ MyController ], after_request =... , before_request =... ) # this is top level app = Starlite ( route_handlers = [ router ], after_request =... , before_request =... )","title":"Life Cycle Hooks"},{"location":"usage/13-lifecycle-hooks/#life-cycle-hooks","text":"Life cycle hooks allows a user to execute a function at a certain point, as indicated by the hook's name, during the request-response cycle.","title":"Life Cycle Hooks"},{"location":"usage/13-lifecycle-hooks/#before-request","text":"The before_request hook runs immediately before calling the route handler function. It accepts either a sync or async function that receives the Request instance as its sole parameter. While the handler function does not need to return a value, if it does return a value other than None , then the route handler will not be called and this value will instead be used for the response. Thus, the before_request handler allows bypassing the route handler selectively. from starlite import Starlite , Request async def my_before_request_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], before_request = my_before_request_handler )","title":"Before Request"},{"location":"usage/13-lifecycle-hooks/#after-request","text":"The after_request hook is called after the route handler function returned and the response object has been resolved. It receives either a sync or async function that receives the Response object, which can be either an instance of starlite.response.Response or any subclass of the Starlette Response object. This function must return a Response object - either the one that was passed in, or a different one. The after_response hook allows users to modify responses, e.g. placing cookies or headers on them, or even to completely replace them given certain conditions. from starlite import Starlite , Response async def my_after_request_handler ( response : Response ) -> Response : ... app = Starlite ( route_handlers = [ ... ], after_request = my_after_request_handler )","title":"After Request"},{"location":"usage/13-lifecycle-hooks/#after-response","text":"The after_response hook is called after the response has been awaited, that is - after a response has been sent to the requester. It receives either a sync or async function that receives the Request object. The function should not return any values. This hook is meant for data post-processing, transmission of data to third party services, gathering of metrics etc. from starlite import Starlite , Request async def my_after_response_handler ( request : Request ) -> None : ... app = Starlite ( route_handlers = [ ... ], after_response = my_after_response_handler )","title":"After Response"},{"location":"usage/13-lifecycle-hooks/#overriding-handlers","text":"You can configure life cycle hook handlers on all layers of your application, that is - on the Starlite instance itself, on routers, controllers or individual route handlers. Each layer overrides the layer above it - thus, the handlers defined for a specific function will override those defined on its router, which will in turn override those defined on the app level. from starlite import Starlite , Router , Controller , get # this overrides the router and app class MyController ( Controller ): path = \"/my-path\" # this overrides the controller, router and app @get ( after_request =... , before_request =... ) def my_handler ( self ) -> None : ... # this overrides the app, for all routes below the router these functions will be used router = Router ( route_handlers = [ MyController ], after_request =... , before_request =... ) # this is top level app = Starlite ( route_handlers = [ router ], after_request =... , before_request =... )","title":"Overriding Handlers"},{"location":"usage/17-exceptions/","text":"Exceptions and Exception Handling Starlite define a base error called StarliteException which serves as a basis to all other exceptions. In general, Starlite will raise two types of exceptions - exceptions that arise during application init, which fall under the broad scope of configurations errors, and exceptions that are raised as part of the normal application flow, i.e. exceptions in route handlers, dependencies and middleware that should be serialized in some fashion. Configuration Exceptions For missing extra dependencies, Starlite will raise either MissingDependencyException . For example, if you try to use the SQLAlchemyPLugin without having SQLAlchemy installed, this will be raised when you start the application. For other configuration issues, Starlite will raise ImproperlyConfiguredException with a message explaining the issue. Application Exceptions For application exceptions, Starlite uses the class HTTPException , which inherits from StarliteException . See the API Reference for full details on the HTTPException class and the kwargs it accepts. { \"status_code\" : 500 , \"detail\" : \"Internal Server Error\" , \"extra\" : {} } Starlite also offers several pre-configured exception subclasses with pre-set error codes that you can use, such as: ImproperlyConfiguredException : status code 500. Used internally for configuration errors. ValidationException : status code 400. This is the exception raised when validation or parsing fails. NotFoundException : status code 404. NotAuthorizedException : status code 401. PermissionDeniedException : status code 403. InternalServerException : status code 500. ServiceUnavailableException : status code 503. When a value fails pydantic validation, the result will be a ValidationException with the extra key set to the pydantic validation errors. Thus, this data will be made available for the API consumers by default. See the API Reference section for exceptions for full reference. Exception Handling Starlite handles all errors by default by transforming them into JSON responses . If the errors are instances of HTTPException , the responses will include the appropriate status_code . Otherwise, the responses will default to 500 - \"Internal Server Error\". You can customize exception handling by passing a dictionary \u2013 mapping either error status codes , or exception classes , to callables. For example, if you would like to replace the default exception handler with a handler that returns plain-text responses you could do this: from starlite.status_codes import HTTP_500_INTERNAL_SERVER_ERROR from starlite import HTTPException , MediaType , Request , Response , Starlite def plain_text_exception_handler ( _ : Request , exc : Exception ) -> Response : \"\"\"Default handler for exceptions subclassed from HTTPException\"\"\" status_code = HTTP_500_INTERNAL_SERVER_ERROR detail = \"\" if hasattr ( exc , \"detail\" ): detail = exc . detail if hasattr ( exc , \"status_code\" ): status_code = exc . status_code return Response ( media_type = MediaType . TEXT , content = detail , status_code = status_code , ) app = Starlite ( route_handlers = [ ... ], exception_handlers = { HTTPException : plain_text_exception_handler }, ) The above will define a top level exception handler that will apply the plain_text_exception_handler function to all exceptions that inherit from HTTPException . You could of course be more granular: from starlite.status_codes import HTTP_500_INTERNAL_SERVER_ERROR from starlite import ValidationException , Request , Response , Starlite def first_exception_handler ( request : Request , exc : Exception ) -> Response : ... def second_exception_handler ( request : Request , exc : Exception ) -> Response : ... def third_exception_handler ( request : Request , exc : Exception ) -> Response : ... app = Starlite ( route_handlers = [ ... ], exception_handlers = { ValidationException : first_exception_handler , HTTP_500_INTERNAL_SERVER_ERROR : second_exception_handler , ValueError : third_exception_handler , }, ) The choice whether to use a single function that has switching logic inside it, or multiple functions depends on your specific needs. While it does not make much sense to have different functions with a top-level exception handling, Starlite supports defining exception handlers on all levels of the app, with the lower levels overriding levels above them. Thus, in the following example, the exception handler for the route handler function will handle the ValidationException related to it: from starlite import ( HTTPException , ValidationException , Request , Response , Starlite , get , ) def top_level_handler ( request : Request , exc : Exception ) -> Response : ... def handler_level_handler ( request : Request , exc : Exception ) -> Response : ... @get ( \"/greet\" , exception_handlers = { ValidationException : top_level_handler }) def my_route_handler ( name : str ) -> str : return f \"hello { name } \" app = Starlite ( route_handlers = [ my_route_handler ], exception_handlers = { HTTPException : top_level_handler }, ) Exception Handling Layers Since Starlite allows users to define both exception handlers and middlewares in a layered fashion, i.e. on individual route handlers, controllers, routers or the app layer, multiple layers of exception handlers are required to ensure that exceptions are handled correctly: Exception Handlers Because of the above structure, the exceptions raised by the ASGI Router itself, namely 404 Not Found and 405 Method Not Allowed are handled only by exception handlers defined on the app layer. Thus, if you want to affect these exceptions, you will need to pass the exception handlers for them to the Starlite constructor and cannot use other layers for this purpose. Examples Logging Exception Handler Note The create_exception_response function is used internally to produce default error responses if no handler has been registered to a route. This is available as part of the public API of Starlite so that you can apply it wherever necessary to ensure consistent error responses across your application. import logging from starlite.status_codes import HTTP_500_INTERNAL_SERVER_ERROR from starlite.response import Response from starlite.utils import create_exception_response from starlite.connection import Request from starlite import Starlite logger = logging . getLogger ( __name__ ) def logging_exception_handler ( request : Request , exc : Exception ) -> Response : \"\"\" Logs exception and returns appropriate response. Parameters ---------- request : Request The request that caused the exception. exc : The exception caught by the Starlite exception handling middleware and passed to the callback. Returns ------- Response \"\"\" logger . error ( \"Application Exception\" , exc_info = exc ) return create_exception_response ( exc ) app = Starlite ( ... , exception_handlers = { HTTP_500_INTERNAL_SERVER_ERROR : logging_exception_handler }, )","title":"Exceptions and Exception Handling"},{"location":"usage/17-exceptions/#exceptions-and-exception-handling","text":"Starlite define a base error called StarliteException which serves as a basis to all other exceptions. In general, Starlite will raise two types of exceptions - exceptions that arise during application init, which fall under the broad scope of configurations errors, and exceptions that are raised as part of the normal application flow, i.e. exceptions in route handlers, dependencies and middleware that should be serialized in some fashion.","title":"Exceptions and Exception Handling"},{"location":"usage/17-exceptions/#configuration-exceptions","text":"For missing extra dependencies, Starlite will raise either MissingDependencyException . For example, if you try to use the SQLAlchemyPLugin without having SQLAlchemy installed, this will be raised when you start the application. For other configuration issues, Starlite will raise ImproperlyConfiguredException with a message explaining the issue.","title":"Configuration Exceptions"},{"location":"usage/17-exceptions/#application-exceptions","text":"For application exceptions, Starlite uses the class HTTPException , which inherits from StarliteException . See the API Reference for full details on the HTTPException class and the kwargs it accepts. { \"status_code\" : 500 , \"detail\" : \"Internal Server Error\" , \"extra\" : {} } Starlite also offers several pre-configured exception subclasses with pre-set error codes that you can use, such as: ImproperlyConfiguredException : status code 500. Used internally for configuration errors. ValidationException : status code 400. This is the exception raised when validation or parsing fails. NotFoundException : status code 404. NotAuthorizedException : status code 401. PermissionDeniedException : status code 403. InternalServerException : status code 500. ServiceUnavailableException : status code 503. When a value fails pydantic validation, the result will be a ValidationException with the extra key set to the pydantic validation errors. Thus, this data will be made available for the API consumers by default. See the API Reference section for exceptions for full reference.","title":"Application Exceptions"},{"location":"usage/17-exceptions/#exception-handling","text":"Starlite handles all errors by default by transforming them into JSON responses . If the errors are instances of HTTPException , the responses will include the appropriate status_code . Otherwise, the responses will default to 500 - \"Internal Server Error\". You can customize exception handling by passing a dictionary \u2013 mapping either error status codes , or exception classes , to callables. For example, if you would like to replace the default exception handler with a handler that returns plain-text responses you could do this: from starlite.status_codes import HTTP_500_INTERNAL_SERVER_ERROR from starlite import HTTPException , MediaType , Request , Response , Starlite def plain_text_exception_handler ( _ : Request , exc : Exception ) -> Response : \"\"\"Default handler for exceptions subclassed from HTTPException\"\"\" status_code = HTTP_500_INTERNAL_SERVER_ERROR detail = \"\" if hasattr ( exc , \"detail\" ): detail = exc . detail if hasattr ( exc , \"status_code\" ): status_code = exc . status_code return Response ( media_type = MediaType . TEXT , content = detail , status_code = status_code , ) app = Starlite ( route_handlers = [ ... ], exception_handlers = { HTTPException : plain_text_exception_handler }, ) The above will define a top level exception handler that will apply the plain_text_exception_handler function to all exceptions that inherit from HTTPException . You could of course be more granular: from starlite.status_codes import HTTP_500_INTERNAL_SERVER_ERROR from starlite import ValidationException , Request , Response , Starlite def first_exception_handler ( request : Request , exc : Exception ) -> Response : ... def second_exception_handler ( request : Request , exc : Exception ) -> Response : ... def third_exception_handler ( request : Request , exc : Exception ) -> Response : ... app = Starlite ( route_handlers = [ ... ], exception_handlers = { ValidationException : first_exception_handler , HTTP_500_INTERNAL_SERVER_ERROR : second_exception_handler , ValueError : third_exception_handler , }, ) The choice whether to use a single function that has switching logic inside it, or multiple functions depends on your specific needs. While it does not make much sense to have different functions with a top-level exception handling, Starlite supports defining exception handlers on all levels of the app, with the lower levels overriding levels above them. Thus, in the following example, the exception handler for the route handler function will handle the ValidationException related to it: from starlite import ( HTTPException , ValidationException , Request , Response , Starlite , get , ) def top_level_handler ( request : Request , exc : Exception ) -> Response : ... def handler_level_handler ( request : Request , exc : Exception ) -> Response : ... @get ( \"/greet\" , exception_handlers = { ValidationException : top_level_handler }) def my_route_handler ( name : str ) -> str : return f \"hello { name } \" app = Starlite ( route_handlers = [ my_route_handler ], exception_handlers = { HTTPException : top_level_handler }, )","title":"Exception Handling"},{"location":"usage/17-exceptions/#exception-handling-layers","text":"Since Starlite allows users to define both exception handlers and middlewares in a layered fashion, i.e. on individual route handlers, controllers, routers or the app layer, multiple layers of exception handlers are required to ensure that exceptions are handled correctly: Exception Handlers Because of the above structure, the exceptions raised by the ASGI Router itself, namely 404 Not Found and 405 Method Not Allowed are handled only by exception handlers defined on the app layer. Thus, if you want to affect these exceptions, you will need to pass the exception handlers for them to the Starlite constructor and cannot use other layers for this purpose.","title":"Exception Handling Layers"},{"location":"usage/17-exceptions/#examples","text":"","title":"Examples"},{"location":"usage/17-exceptions/#logging-exception-handler","text":"Note The create_exception_response function is used internally to produce default error responses if no handler has been registered to a route. This is available as part of the public API of Starlite so that you can apply it wherever necessary to ensure consistent error responses across your application. import logging from starlite.status_codes import HTTP_500_INTERNAL_SERVER_ERROR from starlite.response import Response from starlite.utils import create_exception_response from starlite.connection import Request from starlite import Starlite logger = logging . getLogger ( __name__ ) def logging_exception_handler ( request : Request , exc : Exception ) -> Response : \"\"\" Logs exception and returns appropriate response. Parameters ---------- request : Request The request that caused the exception. exc : The exception caught by the Starlite exception handling middleware and passed to the callback. Returns ------- Response \"\"\" logger . error ( \"Application Exception\" , exc_info = exc ) return create_exception_response ( exc ) app = Starlite ( ... , exception_handlers = { HTTP_500_INTERNAL_SERVER_ERROR : logging_exception_handler }, )","title":"Logging Exception Handler"},{"location":"usage/19-cli/","text":"CLI Starlite optionally provides a simple command line interface, for running and managing Starlite applications, powered by click and rich . Enabling the CLI Dependencies for the CLI are not included by default, to keep the packages needed to install Starlite to a minimum. To enable the CLI, Starlite has to be installed with the cli or standard extra: pip install starlite [ cli ] pip install starlite [ standard ] After installing any of these two, the starlite command will be available as the entrypoint to the CLI. Autodiscovery Starlite will automatically discover Starlite applications in certain places: app.py application.py asgi.py app/__init__.py If any of these files contains an instance of the Starlite class, the CLI will pick it up. Commands Starlite The starlite command is the main entrypoint to the CLI. If the --app flag is not passed, the app will be automatically discovered as described in the section above Options Flag Environment variable Description --app STARLITE_APP Module path to the app in the format of <modulename>.<submodule>:<app instance> Run The run command runs a Starlite application using uvicorn . starlite run Warning This feature is intended for development purposes only and should not be used to deploy production applications Options Flag Environment variable Description -r , --reload STARLITE_RELOAD Reload the application when files in its directory are changed -p , --port STARLITE_PORT Bind the the server to this port [default: 8000] --host STARLITE_HOST Bind the server to this host [default: 127.0.0.1] --debug STARLITE_DEBUG Run the application in debug mode --app STARLITE_APP Module path to the app in the format of <modulename>.<submodule>:<app instance> Info The info command displays useful information about the selected application and its configuration starlite info Routes The routes command displays a tree view of the routing table starlite routes Sessions This command and its subcommands provide management utilities for server-side session backends . Delete The delete subcommand deletes a specific session from the backend. starlite sessions delete cc3debc7-1ab6-4dc8-a220-91934a473717 Clear The clear subcommand clears all sessions from the backend. starlite sessions clear Extending the CLI Starlite's CLI is built with click , and can be easily extended. All that's needed to add subcommands under the starlite command is adding an entry point , pointing to a click.Command or click.Group , under the starlite.commands group. setup.py Poetry from setuptools import setup setup ( name = \"my-starlite-plugin\" , ... , entry_points = { \"starlite.commands\" : [ \"my_command=my_starlite_plugin.cli:main\" ], }, ) [tool.poetry.plugins.\"starlite.commands\"] my_command = \"my_starlite_plugin.cli:main\" Accessing the app instance When extending the Starlite CLI, you most likely need access to the loaded Starlite instance. This can be achieved by adding the special app parameter to your CLI functions. This will cause Starlite instance to be injected into the function whenever it is being called from a click-context. import click from starlite import Starlite @click . command () def my_command ( app : Starlite ) -> None : ...","title":"CLI"},{"location":"usage/19-cli/#cli","text":"Starlite optionally provides a simple command line interface, for running and managing Starlite applications, powered by click and rich .","title":"CLI"},{"location":"usage/19-cli/#enabling-the-cli","text":"Dependencies for the CLI are not included by default, to keep the packages needed to install Starlite to a minimum. To enable the CLI, Starlite has to be installed with the cli or standard extra: pip install starlite [ cli ] pip install starlite [ standard ] After installing any of these two, the starlite command will be available as the entrypoint to the CLI.","title":"Enabling the CLI"},{"location":"usage/19-cli/#autodiscovery","text":"Starlite will automatically discover Starlite applications in certain places: app.py application.py asgi.py app/__init__.py If any of these files contains an instance of the Starlite class, the CLI will pick it up.","title":"Autodiscovery"},{"location":"usage/19-cli/#commands","text":"","title":"Commands"},{"location":"usage/19-cli/#starlite","text":"The starlite command is the main entrypoint to the CLI. If the --app flag is not passed, the app will be automatically discovered as described in the section above","title":"Starlite"},{"location":"usage/19-cli/#options","text":"Flag Environment variable Description --app STARLITE_APP Module path to the app in the format of <modulename>.<submodule>:<app instance>","title":"Options"},{"location":"usage/19-cli/#run","text":"The run command runs a Starlite application using uvicorn . starlite run Warning This feature is intended for development purposes only and should not be used to deploy production applications","title":"Run"},{"location":"usage/19-cli/#options_1","text":"Flag Environment variable Description -r , --reload STARLITE_RELOAD Reload the application when files in its directory are changed -p , --port STARLITE_PORT Bind the the server to this port [default: 8000] --host STARLITE_HOST Bind the server to this host [default: 127.0.0.1] --debug STARLITE_DEBUG Run the application in debug mode --app STARLITE_APP Module path to the app in the format of <modulename>.<submodule>:<app instance>","title":"Options"},{"location":"usage/19-cli/#info","text":"The info command displays useful information about the selected application and its configuration starlite info","title":"Info"},{"location":"usage/19-cli/#routes","text":"The routes command displays a tree view of the routing table starlite routes","title":"Routes"},{"location":"usage/19-cli/#sessions","text":"This command and its subcommands provide management utilities for server-side session backends .","title":"Sessions"},{"location":"usage/19-cli/#delete","text":"The delete subcommand deletes a specific session from the backend. starlite sessions delete cc3debc7-1ab6-4dc8-a220-91934a473717","title":"Delete"},{"location":"usage/19-cli/#clear","text":"The clear subcommand clears all sessions from the backend. starlite sessions clear","title":"Clear"},{"location":"usage/19-cli/#extending-the-cli","text":"Starlite's CLI is built with click , and can be easily extended. All that's needed to add subcommands under the starlite command is adding an entry point , pointing to a click.Command or click.Group , under the starlite.commands group. setup.py Poetry from setuptools import setup setup ( name = \"my-starlite-plugin\" , ... , entry_points = { \"starlite.commands\" : [ \"my_command=my_starlite_plugin.cli:main\" ], }, ) [tool.poetry.plugins.\"starlite.commands\"] my_command = \"my_starlite_plugin.cli:main\"","title":"Extending the CLI"},{"location":"usage/19-cli/#accessing-the-app-instance","text":"When extending the Starlite CLI, you most likely need access to the loaded Starlite instance. This can be achieved by adding the special app parameter to your CLI functions. This will cause Starlite instance to be injected into the function whenever it is being called from a click-context. import click from starlite import Starlite @click . command () def my_command ( app : Starlite ) -> None : ...","title":"Accessing the app instance"},{"location":"usage/4-request-data/","text":"Request Data Request body The body of HTTP requests can be accessed using the special data parameter in a handler function. Python 3.8+ Python 3.9+ from typing import Dict from starlite import Starlite , post @post ( path = \"/\" ) async def index ( data : Dict [ str , str ]) -> Dict [ str , str ]: return data app = Starlite ( route_handlers = [ index ]) from starlite import Starlite , post @post ( path = \"/\" ) async def index ( data : dict [ str , str ]) -> dict [ str , str ]: return data app = Starlite ( route_handlers = [ index ]) The type of data an be any supported type, including dataclasses TypedDict s Pydantic models Arbitrary stdlib types Typed supported via plugins from dataclasses import dataclass from starlite import Starlite , post @dataclass class User : id : int name : str @post ( path = \"/\" ) async def index ( data : User ) -> User : return data app = Starlite ( route_handlers = [ index ]) Validation and customizing OpenAPI documentation With the help of Body , you have fine-grained control over the validation of the request body, and can also customize the OpenAPI documentation: from dataclasses import dataclass from starlite import Body , Starlite , post @dataclass class User : id : int name : str @post ( path = \"/\" ) async def create_user ( data : User = Body ( title = \"Create User\" , description = \"Create a new user.\" ), ) -> User : return data app = Starlite ( route_handlers = [ create_user ]) Specifying a content-type By default, Starlite will try to parse the request body as JSON. While this may be desired in most cases, you might want to specify a different type. You can do so by passing a RequestEncodingType to Body . This will also help to generate the correct media-type in the OpenAPI schema. URL Encoded Form Data To access data sent as url-encoded form data , i.e. application/x-www-form-urlencoded Content-Type header, use Body and specify RequestEncodingType.URL_ENCODED as the media_type : from dataclasses import dataclass from starlite import Body , RequestEncodingType , Starlite , post @dataclass class User : id : int name : str @post ( path = \"/\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . URL_ENCODED ), ) -> User : return data app = Starlite ( route_handlers = [ create_user ]) Info URL encoded data is inherently less versatile than JSON data - for example, it cannot handle complex dictionaries and deeply nested data. It should only be used for simple data structures. MultiPart Form Data You can access data uploaded using a request with a multipart/form-data Content-Type header by specifying it in the Body function: from dataclasses import dataclass from starlite import Body , RequestEncodingType , Starlite , post @dataclass class User : id : int name : str @post ( path = \"/\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> User : return data app = Starlite ( route_handlers = [ create_user ]) File uploads In case of files uploaded, Starlite transforms the results into an instance of UploadFile class, which offer a convenient interface for working with files. Therefore, you need to type your file uploads accordingly. To access a single file simply type data as UploadFile : Async Sync from starlite import Body , MediaType , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" , media_type = MediaType . TEXT ) async def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> str : content = await data . read () filename = data . filename return f \" { filename } , { content . decode () } \" app = Starlite ( route_handlers = [ handle_file_upload ]) from starlite import Body , MediaType , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" , media_type = MediaType . TEXT ) def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> str : content = data . file . read () filename = data . filename return f \" { filename } , { content . decode () } \" app = Starlite ( route_handlers = [ handle_file_upload ]) Technical details UploadFile.read wraps SpooledTemporaryFile so it can be used asynchronously. Inside of a synchronous function we don't need this wrapper, so we can use SpooledTemporaryFile.read() directly. Multiple files To access multiple files with known filenames, you can use a pydantic model: Python 3.8+ Python 3.9+ from typing import Dict from pydantic import BaseConfig , BaseModel from starlite import Body , RequestEncodingType , Starlite , UploadFile , post class FormData ( BaseModel ): cv : UploadFile diploma : UploadFile class Config ( BaseConfig ): arbitrary_types_allowed = True @post ( path = \"/\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> Dict : cv_content = await data . cv . read () diploma_content = await data . diploma . read () return { \"cv\" : cv_content . decode (), \"diploma\" : diploma_content . decode ()} app = Starlite ( route_handlers = [ handle_file_upload ]) from pydantic import BaseConfig , BaseModel from starlite import Body , RequestEncodingType , Starlite , UploadFile , post class FormData ( BaseModel ): cv : UploadFile diploma : UploadFile class Config ( BaseConfig ): arbitrary_types_allowed = True @post ( path = \"/\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> dict : cv_content = await data . cv . read () diploma_content = await data . diploma . read () return { \"cv\" : cv_content . decode (), \"diploma\" : diploma_content . decode ()} app = Starlite ( route_handlers = [ handle_file_upload ]) Files as a dictionary If you do not care about parsing and validation and only want to access the form data as a dictionary, you can use a dict instead: Python 3.8+ Python 3.9+ from typing import Dict from starlite import Body , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" ) async def handle_file_upload ( data : Dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> Dict [ str , str ]: file_contents = {} for name , file in data . items (): content = await file . read () file_contents [ name ] = content . decode () return file_contents app = Starlite ( route_handlers = [ handle_file_upload ]) from starlite import Body , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" ) async def handle_file_upload ( data : dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> dict [ str , str ]: file_contents = {} for name , file in data . items (): content = await file . read () file_contents [ name ] = content . decode () return file_contents app = Starlite ( route_handlers = [ handle_file_upload ]) Files as a list Finally, you can also access the files as a list without the filenames: Python 3.8+ Python 3.9+ from typing import Dict , List from starlite import Body , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" ) async def handle_file_upload ( data : List [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> Dict [ str , str ]: file_contents = {} for file in data : content = await file . read () file_contents [ file . filename ] = content . decode () return file_contents app = Starlite ( route_handlers = [ handle_file_upload ]) from starlite import Body , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" ) async def handle_file_upload ( data : list [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> dict [ str , str ]: file_contents = {} for file in data : content = await file . read () file_contents [ file . filename ] = content . decode () return file_contents app = Starlite ( route_handlers = [ handle_file_upload ]) MessagePack data To receive MessagePack data, specify the appropriate Content-Type for Body , by using RequestEncodingType.MESSAGEPACK : Python 3.8+ Python 3.9+ msgpack_request.py from typing import Dict from starlite import Body , RequestEncodingType , Starlite , post @post ( path = \"/\" ) def msgpack_handler ( data : Dict = Body ( media_type = RequestEncodingType . MESSAGEPACK )) -> Dict : # This will try to parse the request body as `MessagePack` regardless of the # `Content-Type` return data app = Starlite ( route_handlers = [ msgpack_handler ]) msgpack_request.py from starlite import Body , RequestEncodingType , Starlite , post @post ( path = \"/\" ) def msgpack_handler ( data : dict = Body ( media_type = RequestEncodingType . MESSAGEPACK )) -> dict : # This will try to parse the request body as `MessagePack` regardless of the # `Content-Type` return data app = Starlite ( route_handlers = [ msgpack_handler ])","title":"Request Data"},{"location":"usage/4-request-data/#request-data","text":"","title":"Request Data"},{"location":"usage/4-request-data/#request-body","text":"The body of HTTP requests can be accessed using the special data parameter in a handler function. Python 3.8+ Python 3.9+ from typing import Dict from starlite import Starlite , post @post ( path = \"/\" ) async def index ( data : Dict [ str , str ]) -> Dict [ str , str ]: return data app = Starlite ( route_handlers = [ index ]) from starlite import Starlite , post @post ( path = \"/\" ) async def index ( data : dict [ str , str ]) -> dict [ str , str ]: return data app = Starlite ( route_handlers = [ index ]) The type of data an be any supported type, including dataclasses TypedDict s Pydantic models Arbitrary stdlib types Typed supported via plugins from dataclasses import dataclass from starlite import Starlite , post @dataclass class User : id : int name : str @post ( path = \"/\" ) async def index ( data : User ) -> User : return data app = Starlite ( route_handlers = [ index ])","title":"Request body"},{"location":"usage/4-request-data/#validation-and-customizing-openapi-documentation","text":"With the help of Body , you have fine-grained control over the validation of the request body, and can also customize the OpenAPI documentation: from dataclasses import dataclass from starlite import Body , Starlite , post @dataclass class User : id : int name : str @post ( path = \"/\" ) async def create_user ( data : User = Body ( title = \"Create User\" , description = \"Create a new user.\" ), ) -> User : return data app = Starlite ( route_handlers = [ create_user ])","title":"Validation and customizing OpenAPI documentation"},{"location":"usage/4-request-data/#specifying-a-content-type","text":"By default, Starlite will try to parse the request body as JSON. While this may be desired in most cases, you might want to specify a different type. You can do so by passing a RequestEncodingType to Body . This will also help to generate the correct media-type in the OpenAPI schema.","title":"Specifying a content-type"},{"location":"usage/4-request-data/#url-encoded-form-data","text":"To access data sent as url-encoded form data , i.e. application/x-www-form-urlencoded Content-Type header, use Body and specify RequestEncodingType.URL_ENCODED as the media_type : from dataclasses import dataclass from starlite import Body , RequestEncodingType , Starlite , post @dataclass class User : id : int name : str @post ( path = \"/\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . URL_ENCODED ), ) -> User : return data app = Starlite ( route_handlers = [ create_user ]) Info URL encoded data is inherently less versatile than JSON data - for example, it cannot handle complex dictionaries and deeply nested data. It should only be used for simple data structures.","title":"URL Encoded Form Data"},{"location":"usage/4-request-data/#multipart-form-data","text":"You can access data uploaded using a request with a multipart/form-data Content-Type header by specifying it in the Body function: from dataclasses import dataclass from starlite import Body , RequestEncodingType , Starlite , post @dataclass class User : id : int name : str @post ( path = \"/\" ) async def create_user ( data : User = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> User : return data app = Starlite ( route_handlers = [ create_user ])","title":"MultiPart Form Data"},{"location":"usage/4-request-data/#file-uploads","text":"In case of files uploaded, Starlite transforms the results into an instance of UploadFile class, which offer a convenient interface for working with files. Therefore, you need to type your file uploads accordingly. To access a single file simply type data as UploadFile : Async Sync from starlite import Body , MediaType , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" , media_type = MediaType . TEXT ) async def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> str : content = await data . read () filename = data . filename return f \" { filename } , { content . decode () } \" app = Starlite ( route_handlers = [ handle_file_upload ]) from starlite import Body , MediaType , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" , media_type = MediaType . TEXT ) def handle_file_upload ( data : UploadFile = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> str : content = data . file . read () filename = data . filename return f \" { filename } , { content . decode () } \" app = Starlite ( route_handlers = [ handle_file_upload ]) Technical details UploadFile.read wraps SpooledTemporaryFile so it can be used asynchronously. Inside of a synchronous function we don't need this wrapper, so we can use SpooledTemporaryFile.read() directly.","title":"File uploads"},{"location":"usage/4-request-data/#multiple-files","text":"To access multiple files with known filenames, you can use a pydantic model: Python 3.8+ Python 3.9+ from typing import Dict from pydantic import BaseConfig , BaseModel from starlite import Body , RequestEncodingType , Starlite , UploadFile , post class FormData ( BaseModel ): cv : UploadFile diploma : UploadFile class Config ( BaseConfig ): arbitrary_types_allowed = True @post ( path = \"/\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> Dict : cv_content = await data . cv . read () diploma_content = await data . diploma . read () return { \"cv\" : cv_content . decode (), \"diploma\" : diploma_content . decode ()} app = Starlite ( route_handlers = [ handle_file_upload ]) from pydantic import BaseConfig , BaseModel from starlite import Body , RequestEncodingType , Starlite , UploadFile , post class FormData ( BaseModel ): cv : UploadFile diploma : UploadFile class Config ( BaseConfig ): arbitrary_types_allowed = True @post ( path = \"/\" ) async def handle_file_upload ( data : FormData = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> dict : cv_content = await data . cv . read () diploma_content = await data . diploma . read () return { \"cv\" : cv_content . decode (), \"diploma\" : diploma_content . decode ()} app = Starlite ( route_handlers = [ handle_file_upload ])","title":"Multiple files"},{"location":"usage/4-request-data/#files-as-a-dictionary","text":"If you do not care about parsing and validation and only want to access the form data as a dictionary, you can use a dict instead: Python 3.8+ Python 3.9+ from typing import Dict from starlite import Body , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" ) async def handle_file_upload ( data : Dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> Dict [ str , str ]: file_contents = {} for name , file in data . items (): content = await file . read () file_contents [ name ] = content . decode () return file_contents app = Starlite ( route_handlers = [ handle_file_upload ]) from starlite import Body , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" ) async def handle_file_upload ( data : dict [ str , UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> dict [ str , str ]: file_contents = {} for name , file in data . items (): content = await file . read () file_contents [ name ] = content . decode () return file_contents app = Starlite ( route_handlers = [ handle_file_upload ])","title":"Files as a dictionary"},{"location":"usage/4-request-data/#files-as-a-list","text":"Finally, you can also access the files as a list without the filenames: Python 3.8+ Python 3.9+ from typing import Dict , List from starlite import Body , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" ) async def handle_file_upload ( data : List [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> Dict [ str , str ]: file_contents = {} for file in data : content = await file . read () file_contents [ file . filename ] = content . decode () return file_contents app = Starlite ( route_handlers = [ handle_file_upload ]) from starlite import Body , RequestEncodingType , Starlite , UploadFile , post @post ( path = \"/\" ) async def handle_file_upload ( data : list [ UploadFile ] = Body ( media_type = RequestEncodingType . MULTI_PART ), ) -> dict [ str , str ]: file_contents = {} for file in data : content = await file . read () file_contents [ file . filename ] = content . decode () return file_contents app = Starlite ( route_handlers = [ handle_file_upload ])","title":"Files as a list"},{"location":"usage/4-request-data/#messagepack-data","text":"To receive MessagePack data, specify the appropriate Content-Type for Body , by using RequestEncodingType.MESSAGEPACK : Python 3.8+ Python 3.9+ msgpack_request.py from typing import Dict from starlite import Body , RequestEncodingType , Starlite , post @post ( path = \"/\" ) def msgpack_handler ( data : Dict = Body ( media_type = RequestEncodingType . MESSAGEPACK )) -> Dict : # This will try to parse the request body as `MessagePack` regardless of the # `Content-Type` return data app = Starlite ( route_handlers = [ msgpack_handler ]) msgpack_request.py from starlite import Body , RequestEncodingType , Starlite , post @post ( path = \"/\" ) def msgpack_handler ( data : dict = Body ( media_type = RequestEncodingType . MESSAGEPACK )) -> dict : # This will try to parse the request body as `MessagePack` regardless of the # `Content-Type` return data app = Starlite ( route_handlers = [ msgpack_handler ])","title":"MessagePack data"},{"location":"usage/1-routing/0-routing/","text":"Routing Starlite implements its routing solution that is based on the concept of a radix tree or trie . Why Radix Based Routing? The regex matching used by Starlette (and FastAPI etc.) is very good at resolving path parameters fast, giving it an advantage when a URL has a lot of path parameters - what we can think of as vertical scaling. On the other hand, it is not good at scaling horizontally - the more routes, the less performant it becomes. Thus, there is an inverse relation between performance and application size with this approach that strongly favors very small microservices. The trie based approach used by Starlite is agnostic to the number of routes of the application giving it better horizontal scaling characteristics at the expense of somewhat slower resolution of path parameters. Tip If you are interested in the technical aspects of the implementation, refer to this GitHub issue - it includes an indepth discussion of the pertinent code.","title":"Routing"},{"location":"usage/1-routing/0-routing/#routing","text":"Starlite implements its routing solution that is based on the concept of a radix tree or trie .","title":"Routing"},{"location":"usage/1-routing/0-routing/#why-radix-based-routing","text":"The regex matching used by Starlette (and FastAPI etc.) is very good at resolving path parameters fast, giving it an advantage when a URL has a lot of path parameters - what we can think of as vertical scaling. On the other hand, it is not good at scaling horizontally - the more routes, the less performant it becomes. Thus, there is an inverse relation between performance and application size with this approach that strongly favors very small microservices. The trie based approach used by Starlite is agnostic to the number of routes of the application giving it better horizontal scaling characteristics at the expense of somewhat slower resolution of path parameters. Tip If you are interested in the technical aspects of the implementation, refer to this GitHub issue - it includes an indepth discussion of the pertinent code.","title":"Why Radix Based Routing?"},{"location":"usage/1-routing/1-registering-routes/","text":"Registering Routes At the root of every Starlite application there is an instance of the Starlite class, on which the root level controllers, routers and route handler functions are registered using the route_handlers kwarg: from starlite import Starlite , get @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... @get () def root_handler () -> None : ... app = Starlite ( route_handlers = [ root_handler , sub_path_handler ]) Components registered on the app are appended to the root path. Thus, the root_handler function will be called for the path \"/\", whereas the sub_path_handler will be called for \"/sub-path\". You can also declare a function to handle multiple paths, e.g.: from starlite import get , Starlite @get ([ \"/\" , \"/sub-path\" ]) def handler () -> None : ... app = Starlite ( route_handlers = [ handler ]) To handle more complex path schemas you should use routers and controller Dynamic Route Registration Occasionally there is a need for dynamic route registration. Starlite supports this via the .register method exposed by the Starlite app instance: from starlite import Starlite , get @get () def root_handler () -> None : ... app = Starlite ( route_handlers = [ root_handler ]) @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... app . register ( sub_path_handler ) Since the app instance is attached to all instances of ASGIConnection , Request and WebSocket objects, you can in effect call the .register method inside route handler functions, middlewares and even injected dependencies. For example: from typing import Any from starlite import Starlite , Request , get @get ( \"/some-path\" ) def route_handler ( request : Request [ Any , Any ]) -> None : @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... request . app . register ( sub_path_handler ) app = Starlite ( route_handlers = [ route_handler ]) In the above we dynamically created the sub-path_handler and registered it inside the route_handler function. Warning Although Starlite exposes the .register method, it should not be abused. Dynamic route registration increases the application complexity and makes it harder to reason about the code. It should therefore be used only when absolutely required.","title":"Registering Routes"},{"location":"usage/1-routing/1-registering-routes/#registering-routes","text":"At the root of every Starlite application there is an instance of the Starlite class, on which the root level controllers, routers and route handler functions are registered using the route_handlers kwarg: from starlite import Starlite , get @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... @get () def root_handler () -> None : ... app = Starlite ( route_handlers = [ root_handler , sub_path_handler ]) Components registered on the app are appended to the root path. Thus, the root_handler function will be called for the path \"/\", whereas the sub_path_handler will be called for \"/sub-path\". You can also declare a function to handle multiple paths, e.g.: from starlite import get , Starlite @get ([ \"/\" , \"/sub-path\" ]) def handler () -> None : ... app = Starlite ( route_handlers = [ handler ]) To handle more complex path schemas you should use routers and controller","title":"Registering Routes"},{"location":"usage/1-routing/1-registering-routes/#dynamic-route-registration","text":"Occasionally there is a need for dynamic route registration. Starlite supports this via the .register method exposed by the Starlite app instance: from starlite import Starlite , get @get () def root_handler () -> None : ... app = Starlite ( route_handlers = [ root_handler ]) @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... app . register ( sub_path_handler ) Since the app instance is attached to all instances of ASGIConnection , Request and WebSocket objects, you can in effect call the .register method inside route handler functions, middlewares and even injected dependencies. For example: from typing import Any from starlite import Starlite , Request , get @get ( \"/some-path\" ) def route_handler ( request : Request [ Any , Any ]) -> None : @get ( \"/sub-path\" ) def sub_path_handler () -> None : ... request . app . register ( sub_path_handler ) app = Starlite ( route_handlers = [ route_handler ]) In the above we dynamically created the sub-path_handler and registered it inside the route_handler function. Warning Although Starlite exposes the .register method, it should not be abused. Dynamic route registration increases the application complexity and makes it harder to reason about the code. It should therefore be used only when absolutely required.","title":"Dynamic Route Registration"},{"location":"usage/1-routing/2-routers/","text":"Routers Routers are instances of starlite.router.Router , which is the base class for the Starlite app itself. A router can register Controllers, route handler functions and other routers, similarly to the Starlite constructor: from starlite import Starlite , Router , get @get ( \"/{order_id:int}\" ) def order_handler ( order_id : int ) -> None : ... order_router = Router ( path = \"/orders\" , route_handlers = [ order_handler ]) base_router = Router ( path = \"/base\" , route_handlers = [ order_router ]) app = Starlite ( route_handlers = [ base_router ]) Once order_router is registered on base_router , the handler function registered on order_router will become available on /base/orders/{order_id} . See the API Reference for full details on the Router class and the kwargs it accepts.","title":"Routers"},{"location":"usage/1-routing/2-routers/#routers","text":"Routers are instances of starlite.router.Router , which is the base class for the Starlite app itself. A router can register Controllers, route handler functions and other routers, similarly to the Starlite constructor: from starlite import Starlite , Router , get @get ( \"/{order_id:int}\" ) def order_handler ( order_id : int ) -> None : ... order_router = Router ( path = \"/orders\" , route_handlers = [ order_handler ]) base_router = Router ( path = \"/base\" , route_handlers = [ order_router ]) app = Starlite ( route_handlers = [ base_router ]) Once order_router is registered on base_router , the handler function registered on order_router will become available on /base/orders/{order_id} . See the API Reference for full details on the Router class and the kwargs it accepts.","title":"Routers"},{"location":"usage/1-routing/3-controllers/","text":"Controllers Controllers are subclasses of the class starlite.controller.Controller . They are used to organize endpoints under a specific sub-path, which is the controller's path. Their purpose is to allow users to utilize python OOP for better code organization and organize code by logical concerns. from pydantic import BaseModel , UUID4 from starlite.controller import Controller from starlite.handlers import get , post , patch , delete from starlite.types import Partial class UserOrder ( BaseModel ): user_id : int order : str class UserOrderController ( Controller ): path = \"/user-order\" @post () async def create_user_order ( self , data : UserOrder ) -> UserOrder : ... @get ( path = \"/{order_id:uuid}\" ) async def retrieve_user_order ( self , order_id : UUID4 ) -> UserOrder : ... @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ] ) -> UserOrder : ... @delete ( path = \"/{order_id:uuid}\" ) async def delete_user_order ( self , order_id : UUID4 ) -> None : ... The above is a simple example of a \"CRUD\" controller for a model called UserOrder . You can place as many route handler methods on a controller, as long as the combination of path+http method is unique. The path that is defined on the Controller is appended before the path that is defined for the route handlers declared on it. Thus, in the above example, create_user_order has the path of the controller - /user-order/ , while retrieve_user_order has the path /user-order/{order_id:uuid}\" . Note If you do not declare a path class variable on the controller, it will default to the root path of \"/\". See the API Reference for full details on the Controller class and the kwargs it accepts.","title":"Controllers"},{"location":"usage/1-routing/3-controllers/#controllers","text":"Controllers are subclasses of the class starlite.controller.Controller . They are used to organize endpoints under a specific sub-path, which is the controller's path. Their purpose is to allow users to utilize python OOP for better code organization and organize code by logical concerns. from pydantic import BaseModel , UUID4 from starlite.controller import Controller from starlite.handlers import get , post , patch , delete from starlite.types import Partial class UserOrder ( BaseModel ): user_id : int order : str class UserOrderController ( Controller ): path = \"/user-order\" @post () async def create_user_order ( self , data : UserOrder ) -> UserOrder : ... @get ( path = \"/{order_id:uuid}\" ) async def retrieve_user_order ( self , order_id : UUID4 ) -> UserOrder : ... @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ] ) -> UserOrder : ... @delete ( path = \"/{order_id:uuid}\" ) async def delete_user_order ( self , order_id : UUID4 ) -> None : ... The above is a simple example of a \"CRUD\" controller for a model called UserOrder . You can place as many route handler methods on a controller, as long as the combination of path+http method is unique. The path that is defined on the Controller is appended before the path that is defined for the route handlers declared on it. Thus, in the above example, create_user_order has the path of the controller - /user-order/ , while retrieve_user_order has the path /user-order/{order_id:uuid}\" . Note If you do not declare a path class variable on the controller, it will default to the root path of \"/\". See the API Reference for full details on the Controller class and the kwargs it accepts.","title":"Controllers"},{"location":"usage/1-routing/4-registering-components-multiple-times/","text":"Registering Components Multiple Times You can register both standalone route handler functions and controllers multiple times. Registering Controllers Multiple Times from starlite import Router , Controller , get class MyController ( Controller ): path = \"/controller\" @get () def handler ( self ) -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ MyController ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ MyController ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ MyController ]) In the above, the same MyController class has been registered on three different routers. This is possible because what is passed to the router is not a class instance but rather the class itself. The router creates its own instance of the controller, which ensures encapsulation. Therefore, in the above example, three different instances of MyController will be created, each mounted on a different sub-path, e.g. /internal/controller , /partner/controller and /consumer/controller . Registering Standalone Route Handlers Multiple Times You can also register standalone route handlers multiple times: from starlite import Starlite , Router , get @get ( path = \"/handler\" ) def my_route_handler () -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ my_route_handler ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ my_route_handler ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ my_route_handler ]) Starlite ( route_handlers = [ internal_router , partner_router , consumer_router ]) When the handler function is registered, it's actually copied. Thus, each router has its own unique instance of the route handler. Path behaviour is identical to that of controllers above, namely, the route handler function will be accessible in the following paths: /internal/handler , /partner/handler and /consumer/handler . Important You can nest routers as you see fit - but be aware that once a router has been registered it cannot be re-registered or an exception will be raised.","title":"Registering Components Multiple Times"},{"location":"usage/1-routing/4-registering-components-multiple-times/#registering-components-multiple-times","text":"You can register both standalone route handler functions and controllers multiple times.","title":"Registering Components Multiple Times"},{"location":"usage/1-routing/4-registering-components-multiple-times/#registering-controllers-multiple-times","text":"from starlite import Router , Controller , get class MyController ( Controller ): path = \"/controller\" @get () def handler ( self ) -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ MyController ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ MyController ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ MyController ]) In the above, the same MyController class has been registered on three different routers. This is possible because what is passed to the router is not a class instance but rather the class itself. The router creates its own instance of the controller, which ensures encapsulation. Therefore, in the above example, three different instances of MyController will be created, each mounted on a different sub-path, e.g. /internal/controller , /partner/controller and /consumer/controller .","title":"Registering Controllers Multiple Times"},{"location":"usage/1-routing/4-registering-components-multiple-times/#registering-standalone-route-handlers-multiple-times","text":"You can also register standalone route handlers multiple times: from starlite import Starlite , Router , get @get ( path = \"/handler\" ) def my_route_handler () -> None : ... internal_router = Router ( path = \"/internal\" , route_handlers = [ my_route_handler ]) partner_router = Router ( path = \"/partner\" , route_handlers = [ my_route_handler ]) consumer_router = Router ( path = \"/consumer\" , route_handlers = [ my_route_handler ]) Starlite ( route_handlers = [ internal_router , partner_router , consumer_router ]) When the handler function is registered, it's actually copied. Thus, each router has its own unique instance of the route handler. Path behaviour is identical to that of controllers above, namely, the route handler function will be accessible in the following paths: /internal/handler , /partner/handler and /consumer/handler . Important You can nest routers as you see fit - but be aware that once a router has been registered it cannot be re-registered or an exception will be raised.","title":"Registering Standalone Route Handlers Multiple Times"},{"location":"usage/1-routing/5-mounting-asgi-apps/","text":"Mounting ASGI Apps Starlite support \"mounting\" ASGI applications on sub paths, that is - specifying a handler function that will handle all requests addressed to a given path. Mounting an ASGI App from typing import TYPE_CHECKING from starlite import Response , Starlite , asgi if TYPE_CHECKING : from starlite.types import Receive , Scope , Send @asgi ( \"/some/sub-path\" , is_mount = True ) async def my_asgi_app ( scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" ) -> None : \"\"\" Args: scope: The ASGI connection scope. receive: The ASGI receive function. send: The ASGI send function. Returns: None \"\"\" response = Response ( content = { \"forwarded_path\" : scope [ \"path\" ]}) await response ( scope , receive , send ) app = Starlite ( route_handlers = [ my_asgi_app ]) The handler function will receive all requests with an url that begins with /some/sub-path , e.g. /some/sub-path and /some/sub-path/abc and /some/sub-path/123/another/sub-path etc. Info If we are sending a request to the above with the url /some/sub-path , the handler will be invoked and the value of scope[\"path\"] will equal / . If we send a request to /some/sub-path/abc , it will also be invoked, and scope[\"path\"] will equal /abc . Mounting is especially useful when you need to combine components of other ASGI applications - for example, for 3rd part libraries. The following example is identical in principle to the one above, but it uses Starlette : Mounting a Starlette App from typing import TYPE_CHECKING from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from starlite import Starlite , asgi if TYPE_CHECKING : from starlette.requests import Request async def index ( request : \"Request\" ) -> JSONResponse : \"\"\"A generic starlette handler.\"\"\" return JSONResponse ({ \"forwarded_path\" : request . url . path }) starlette_app = asgi ( path = \"/some/sub-path\" , is_mount = True )( Starlette ( debug = True , routes = [ Route ( \"/\" , index ), Route ( \"/abc/\" , index ), Route ( \"/123/another/sub-path/\" , index ), ], ) ) app = Starlite ( route_handlers = [ starlette_app ])","title":"Mounting ASGI Apps"},{"location":"usage/1-routing/5-mounting-asgi-apps/#mounting-asgi-apps","text":"Starlite support \"mounting\" ASGI applications on sub paths, that is - specifying a handler function that will handle all requests addressed to a given path. Mounting an ASGI App from typing import TYPE_CHECKING from starlite import Response , Starlite , asgi if TYPE_CHECKING : from starlite.types import Receive , Scope , Send @asgi ( \"/some/sub-path\" , is_mount = True ) async def my_asgi_app ( scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" ) -> None : \"\"\" Args: scope: The ASGI connection scope. receive: The ASGI receive function. send: The ASGI send function. Returns: None \"\"\" response = Response ( content = { \"forwarded_path\" : scope [ \"path\" ]}) await response ( scope , receive , send ) app = Starlite ( route_handlers = [ my_asgi_app ]) The handler function will receive all requests with an url that begins with /some/sub-path , e.g. /some/sub-path and /some/sub-path/abc and /some/sub-path/123/another/sub-path etc. Info If we are sending a request to the above with the url /some/sub-path , the handler will be invoked and the value of scope[\"path\"] will equal / . If we send a request to /some/sub-path/abc , it will also be invoked, and scope[\"path\"] will equal /abc . Mounting is especially useful when you need to combine components of other ASGI applications - for example, for 3rd part libraries. The following example is identical in principle to the one above, but it uses Starlette : Mounting a Starlette App from typing import TYPE_CHECKING from starlette.applications import Starlette from starlette.responses import JSONResponse from starlette.routing import Route from starlite import Starlite , asgi if TYPE_CHECKING : from starlette.requests import Request async def index ( request : \"Request\" ) -> JSONResponse : \"\"\"A generic starlette handler.\"\"\" return JSONResponse ({ \"forwarded_path\" : request . url . path }) starlette_app = asgi ( path = \"/some/sub-path\" , is_mount = True )( Starlette ( debug = True , routes = [ Route ( \"/\" , index ), Route ( \"/abc/\" , index ), Route ( \"/123/another/sub-path/\" , index ), ], ) ) app = Starlite ( route_handlers = [ starlette_app ])","title":"Mounting ASGI Apps"},{"location":"usage/10-plugins/0-plugins-intro/","text":"Plugins Starlite supports extension through plugins, which allow for the following: Updating the Starlite application instance during the init process. Serialization and deserialization of non-pydantic based 3rd party classes. Automatic OpenAPI schema creation for 3rd party classes. Thus, plugins allow for a wide range of actions - from registering middleware to the parsing and validation of incoming data using non-pydantic classes. Additionally, they allow for seamless serialization and schema generation. Creating Plugins A plugin is a class that implements the PluginProtocol . If you wish to support the serialization and deserialization of none-pydantic classes, you need to implement the following methods specified by the: Python 3.8+ Python 3.9+ from typing import Type , Any , Dict from starlite import PluginProtocol from pydantic import BaseModel class MyClass : ... class MyPlugin ( PluginProtocol [ MyClass ]): \"\"\" The class for which we create a plugin. For example, could be a base ORM class such as \"Model\" or \"Document\" etc. \"\"\" ... def to_pydantic_model_class ( self , model_class : Type [ MyClass ], ** kwargs : Any ) -> Type [ BaseModel ]: \"\"\" Given a model_class, convert it to a subclass of the pydantic BaseModel \"\"\" ... @staticmethod def is_plugin_supported_type ( value : Any ) -> bool : \"\"\" Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool. \"\"\" ... def from_pydantic_model_instance ( self , model_class : Type [ MyClass ], pydantic_model_instance : BaseModel ) -> MyClass : \"\"\" Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. \"\"\" ... def to_dict ( self , model_instance : MyClass ) -> Dict [ str , Any ]: \"\"\" Given an instance of a model supported by the plugin, return a dictionary of serializable values. \"\"\" ... def from_dict ( self , model_class : Type [ MyClass ], ** kwargs : Any ) -> MyClass : \"\"\" Given a class supported by this plugin and a dict of values, create an instance of the class \"\"\" ... from typing import Any from starlite import PluginProtocol from pydantic import BaseModel class MyClass : ... class MyPlugin ( PluginProtocol [ MyClass ]): \"\"\" The class for which we create a plugin. For example, could be a base ORM class such as \"Model\" or \"Document\" etc. \"\"\" ... def to_pydantic_model_class ( self , model_class : type [ MyClass ], ** kwargs : Any ) -> type [ BaseModel ]: \"\"\" Given a model_class, convert it to a subclass of the pydantic BaseModel \"\"\" ... @staticmethod def is_plugin_supported_type ( value : Any ) -> bool : \"\"\" Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool. \"\"\" ... def from_pydantic_model_instance ( self , model_class : type [ MyClass ], pydantic_model_instance : BaseModel ) -> MyClass : \"\"\" Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. \"\"\" ... def to_dict ( self , model_instance : MyClass ) -> dict [ str , Any ]: \"\"\" Given an instance of a model supported by the plugin, return a dictionary of serializable values. \"\"\" ... def from_dict ( self , model_class : type [ MyClass ], ** kwargs : Any ) -> MyClass : \"\"\" Given a class supported by this plugin and a dict of values, create an instance of the class \"\"\" ... If you wish to register middlewares, guards, dependencies and so forth on the application init, you need to implement the on_app_init method: from typing import Any from starlite import PluginProtocol , Starlite , get @get ( \"/some-path\" ) def my_handler () -> None : ... class MyPlugin ( PluginProtocol [ Any ]): def on_app_init ( self , app : Starlite ) -> None : # register a route handler app . register ( my_handler ) # update attributes of the application before init is finished. app . after_request = ... app . after_response = ... app . before_request = ... app . dependencies . update ({ ... }) app . exception_handlers . update ({ ... }) app . guards . extend ( ... ) app . middleware . extend ( ... ) app . on_shutdown . extend ( ... ) app . on_startup . extend ( ... ) app . parameters . update ({ ... }) app . response_class = ... app . response_cookies . extend ( ... ) app . response_headers . update ( ... ) app . tags . extend ( ... )","title":"Plugins"},{"location":"usage/10-plugins/0-plugins-intro/#plugins","text":"Starlite supports extension through plugins, which allow for the following: Updating the Starlite application instance during the init process. Serialization and deserialization of non-pydantic based 3rd party classes. Automatic OpenAPI schema creation for 3rd party classes. Thus, plugins allow for a wide range of actions - from registering middleware to the parsing and validation of incoming data using non-pydantic classes. Additionally, they allow for seamless serialization and schema generation.","title":"Plugins"},{"location":"usage/10-plugins/0-plugins-intro/#creating-plugins","text":"A plugin is a class that implements the PluginProtocol . If you wish to support the serialization and deserialization of none-pydantic classes, you need to implement the following methods specified by the: Python 3.8+ Python 3.9+ from typing import Type , Any , Dict from starlite import PluginProtocol from pydantic import BaseModel class MyClass : ... class MyPlugin ( PluginProtocol [ MyClass ]): \"\"\" The class for which we create a plugin. For example, could be a base ORM class such as \"Model\" or \"Document\" etc. \"\"\" ... def to_pydantic_model_class ( self , model_class : Type [ MyClass ], ** kwargs : Any ) -> Type [ BaseModel ]: \"\"\" Given a model_class, convert it to a subclass of the pydantic BaseModel \"\"\" ... @staticmethod def is_plugin_supported_type ( value : Any ) -> bool : \"\"\" Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool. \"\"\" ... def from_pydantic_model_instance ( self , model_class : Type [ MyClass ], pydantic_model_instance : BaseModel ) -> MyClass : \"\"\" Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. \"\"\" ... def to_dict ( self , model_instance : MyClass ) -> Dict [ str , Any ]: \"\"\" Given an instance of a model supported by the plugin, return a dictionary of serializable values. \"\"\" ... def from_dict ( self , model_class : Type [ MyClass ], ** kwargs : Any ) -> MyClass : \"\"\" Given a class supported by this plugin and a dict of values, create an instance of the class \"\"\" ... from typing import Any from starlite import PluginProtocol from pydantic import BaseModel class MyClass : ... class MyPlugin ( PluginProtocol [ MyClass ]): \"\"\" The class for which we create a plugin. For example, could be a base ORM class such as \"Model\" or \"Document\" etc. \"\"\" ... def to_pydantic_model_class ( self , model_class : type [ MyClass ], ** kwargs : Any ) -> type [ BaseModel ]: \"\"\" Given a model_class, convert it to a subclass of the pydantic BaseModel \"\"\" ... @staticmethod def is_plugin_supported_type ( value : Any ) -> bool : \"\"\" Given a value of indeterminate type, determine if this value is supported by the plugin by returning a bool. \"\"\" ... def from_pydantic_model_instance ( self , model_class : type [ MyClass ], pydantic_model_instance : BaseModel ) -> MyClass : \"\"\" Given an instance of a pydantic model created using a plugin's 'to_pydantic_model_class', return an instance of the class from which that pydantic model has been created. This class is passed in as the 'model_class' kwarg. \"\"\" ... def to_dict ( self , model_instance : MyClass ) -> dict [ str , Any ]: \"\"\" Given an instance of a model supported by the plugin, return a dictionary of serializable values. \"\"\" ... def from_dict ( self , model_class : type [ MyClass ], ** kwargs : Any ) -> MyClass : \"\"\" Given a class supported by this plugin and a dict of values, create an instance of the class \"\"\" ... If you wish to register middlewares, guards, dependencies and so forth on the application init, you need to implement the on_app_init method: from typing import Any from starlite import PluginProtocol , Starlite , get @get ( \"/some-path\" ) def my_handler () -> None : ... class MyPlugin ( PluginProtocol [ Any ]): def on_app_init ( self , app : Starlite ) -> None : # register a route handler app . register ( my_handler ) # update attributes of the application before init is finished. app . after_request = ... app . after_response = ... app . before_request = ... app . dependencies . update ({ ... }) app . exception_handlers . update ({ ... }) app . guards . extend ( ... ) app . middleware . extend ( ... ) app . on_shutdown . extend ( ... ) app . on_startup . extend ( ... ) app . parameters . update ({ ... }) app . response_class = ... app . response_cookies . extend ( ... ) app . response_headers . update ( ... ) app . tags . extend ( ... )","title":"Creating Plugins"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/","text":"SQLAlchemy Plugin Starlite comes with built-in support for SQLAlchemy via the SQLAlchemyPlugin . Features Managed sessions (sync and async) including dependency injection Automatic serialization of SQLAlchemy models powered pydantic Data validation based on SQLAlchemy models powered pydantic Info The following examples use SQLAlchemy's \"2.0 Style\" introduced in SQLAlchemy 1.4. If you are unfamiliar with it, you can find a comprehensive migration guide in SQLAlchemy's documentation here , and a handy table comparing the ORM usage Important The SQLAlchemyPlugin supports only mapped classes . Tables are currently not supported since they are not easy to convert to pydantic models. Basic Use You can simply pass an instance of SQLAlchemyPlugin without passing config to the Starlite constructor. This will extend support for serialization, deserialization and DTO creation for SQLAlchemy declarative models: Async Sync Python 3.8+ Python 3.10+ sqlalchemy_plugin.py from typing import Optional from sqlalchemy import Column , Float , Integer , String , select from sqlalchemy.ext.asyncio import AsyncSession from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get , post from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite:///test.sqlite\" , dependency_key = \"async_session\" ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) CreateCompanyDTO = dto_factory ( \"CreateCompanyDTO\" , Company , exclude = [ \"id\" ]) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" async with sqlalchemy_config . engine . begin () as conn : # type: ignore await conn . run_sync ( Base . metadata . create_all ) # pyright: ignore @post ( path = \"/companies\" ) async def create_company ( data : CreateCompanyDTO , # type: ignore[valid-type] async_session : AsyncSession , ) -> Company : \"\"\"Create a new company and return it.\"\"\" company : Company = data . to_model_instance () # type: ignore[attr-defined] async_session . add ( company ) await async_session . commit () return company @get ( path = \"/companies/{company_id:int}\" ) async def get_company ( company_id : str , async_session : AsyncSession ) -> Company : \"\"\"Get a company by its ID and return it. If a company with that ID does not exist, return a 404 response \"\"\" result = await async_session . scalars ( select ( Company ) . where ( Company . id == company_id )) company : Optional [ Company ] = result . one_or_none () if not company : raise HTTPException ( detail = f \"Company with ID { company_id } not found\" , status_code = HTTP_404_NOT_FOUND ) return company app = Starlite ( route_handlers = [ create_company , get_company ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_plugin.py from sqlalchemy import Column , Float , Integer , String , select from sqlalchemy.ext.asyncio import AsyncSession from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get , post from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite:///test.sqlite\" , dependency_key = \"async_session\" ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) CreateCompanyDTO = dto_factory ( \"CreateCompanyDTO\" , Company , exclude = [ \"id\" ]) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" async with sqlalchemy_config . engine . begin () as conn : # type: ignore await conn . run_sync ( Base . metadata . create_all ) # pyright: ignore @post ( path = \"/companies\" ) async def create_company ( data : CreateCompanyDTO , # type: ignore[valid-type] async_session : AsyncSession , ) -> Company : \"\"\"Create a new company and return it.\"\"\" company : Company = data . to_model_instance () # type: ignore[attr-defined] async_session . add ( company ) await async_session . commit () return company @get ( path = \"/companies/{company_id:int}\" ) async def get_company ( company_id : str , async_session : AsyncSession ) -> Company : \"\"\"Get a company by its ID and return it. If a company with that ID does not exist, return a 404 response \"\"\" result = await async_session . scalars ( select ( Company ) . where ( Company . id == company_id )) company : Company | None = result . one_or_none () if not company : raise HTTPException ( detail = f \"Company with ID { company_id } not found\" , status_code = HTTP_404_NOT_FOUND ) return company app = Starlite ( route_handlers = [ create_company , get_company ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) Python 3.8+ Python 3.10+ sqlalchemy_plugin.py from typing import Optional from sqlalchemy import Column , Float , Integer , String , select from sqlalchemy.orm import Mapped , Session , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get , post from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+pysqlite:///test.sqlite\" , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) CreateCompanyDTO = dto_factory ( \"CreateCompanyDTO\" , Company , exclude = [ \"id\" ]) def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( sqlalchemy_config . engine ) # type: ignore @post ( path = \"/companies\" ) def create_company ( data : CreateCompanyDTO , # type: ignore[valid-type] db_session : Session , ) -> Company : \"\"\"Create a new company and return it.\"\"\" company : Company = data . to_model_instance () # type: ignore[attr-defined] db_session . add ( company ) db_session . commit () return company @get ( path = \"/companies/{company_id:int}\" ) def get_company ( company_id : str , db_session : Session ) -> Company : \"\"\"Get a company by its ID and return it. If a company with that ID does not exist, return a 404 response \"\"\" company : Optional [ Company ] = db_session . scalars ( select ( Company ) . where ( Company . id == company_id )) . one_or_none () if not company : raise HTTPException ( detail = f \"Company with ID { company_id } not found\" , status_code = HTTP_404_NOT_FOUND ) return company app = Starlite ( route_handlers = [ create_company , get_company ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_plugin.py from sqlalchemy import Column , Float , Integer , String , select from sqlalchemy.orm import Mapped , Session , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get , post from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+pysqlite:///test.sqlite\" , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) CreateCompanyDTO = dto_factory ( \"CreateCompanyDTO\" , Company , exclude = [ \"id\" ]) def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( sqlalchemy_config . engine ) # type: ignore @post ( path = \"/companies\" ) def create_company ( data : CreateCompanyDTO , # type: ignore[valid-type] db_session : Session , ) -> Company : \"\"\"Create a new company and return it.\"\"\" company : Company = data . to_model_instance () # type: ignore[attr-defined] db_session . add ( company ) db_session . commit () return company @get ( path = \"/companies/{company_id:int}\" ) def get_company ( company_id : str , db_session : Session ) -> Company : \"\"\"Get a company by its ID and return it. If a company with that ID does not exist, return a 404 response \"\"\" company : Company | None = db_session . scalars ( select ( Company ) . where ( Company . id == company_id )) . one_or_none () if not company : raise HTTPException ( detail = f \"Company with ID { company_id } not found\" , status_code = HTTP_404_NOT_FOUND ) return company app = Starlite ( route_handlers = [ create_company , get_company ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) Using imperative mappings Imperative mappings are supported as well, just make sure to use a mapped class instead of the table itself company_table = Table ( \"company\" , Base . registry . metadata , Column ( \"id\" , Integer , primary_key = True ), Column ( \"name\" , String ), Column ( \"worth\" , Float ), ) class Company : pass Base . registry . map_imperatively ( Company , company_table ) Relationships Important Currently only to-one relationships are supported because of the way the SQLAlchemy plugin handles relationships. Since it recursively traverses relationships, a cyclic reference will result in an endless loop. To prevent this, these relationships will be type as Any in the pydantic model Important Relationships are typed as Optional in the pydantic model by default so sending incomplete models won't cause any issues Simple relationships Simple relationships can be handled by the plugin automatically: Python 3.8+ Python 3.10+ sqlalchemy_relationships.py from typing import Optional from sqlalchemy import Column , Float , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite://\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) company_id : Mapped [ int ] = Column ( Integer , ForeignKey ( \"company.id\" )) company : Mapped [ Company ] = relationship ( \"Company\" , uselist = False ) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , company = Company ( name = \"Peter Co.\" , worth = 0.0 )) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> User : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : Optional [ User ] = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return user app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_relationships.py from sqlalchemy import Column , Float , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite://\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) company_id : Mapped [ int ] = Column ( Integer , ForeignKey ( \"company.id\" )) company : Mapped [ Company ] = relationship ( \"Company\" , uselist = False ) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , company = Company ( name = \"Peter Co.\" , worth = 0.0 )) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> User : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : User | None = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return user app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) In action Run the above with uvicorn sqlalchemy_relationships:app , navigate your browser to http://127.0.0.0:8000/user/1 and you will see: { \"id\" : 1 , \"name\" : \"Peter\" , \"company_id\" : 1 , \"company\" : { \"id\" : 1 , \"name\" : \"Peter Co.\" , \"worth\" : 0 } } To-Many relationships and circular references For to-many relationships or those that contain circular references you need to define the pydantic models yourself: Python 3.8+ Python 3.9+ Python 3.10+ sqlalchemy_relationships_to_many from typing import List , Optional from pydantic import BaseModel from sqlalchemy import Column , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite:///test.sqlite\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Pet ( Base ): __tablename__ = \"pet\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) owner : Mapped [ \"User\" ] = relationship ( \"User\" , back_populates = \"pets\" , uselist = True ) owner_id : Mapped [ int ] = Column ( ForeignKey ( \"user.id\" )) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String , default = \"moishe\" ) pets : Mapped [ List [ Pet ]] = relationship ( \"Pet\" , uselist = True , back_populates = \"owner\" ) class PetModel ( BaseModel ): class Config : orm_mode = True id : int name : str class UserModel ( BaseModel ): class Config : orm_mode = True id : int name : str pets : List [ PetModel ] def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , pets = [ Pet ( id = 1 , name = \"Paul\" )]) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> UserModel : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : Optional [ User ] = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return UserModel . from_orm ( user ) app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_relationships_to_many from typing import Optional from pydantic import BaseModel from sqlalchemy import Column , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite:///test.sqlite\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Pet ( Base ): __tablename__ = \"pet\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) owner : Mapped [ \"User\" ] = relationship ( \"User\" , back_populates = \"pets\" , uselist = True ) owner_id : Mapped [ int ] = Column ( ForeignKey ( \"user.id\" )) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String , default = \"moishe\" ) pets : Mapped [ list [ Pet ]] = relationship ( \"Pet\" , uselist = True , back_populates = \"owner\" ) class PetModel ( BaseModel ): class Config : orm_mode = True id : int name : str class UserModel ( BaseModel ): class Config : orm_mode = True id : int name : str pets : list [ PetModel ] def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , pets = [ Pet ( id = 1 , name = \"Paul\" )]) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> UserModel : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : Optional [ User ] = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return UserModel . from_orm ( user ) app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_relationships_to_many from pydantic import BaseModel from sqlalchemy import Column , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite:///test.sqlite\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Pet ( Base ): __tablename__ = \"pet\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) owner : Mapped [ \"User\" ] = relationship ( \"User\" , back_populates = \"pets\" , uselist = True ) owner_id : Mapped [ int ] = Column ( ForeignKey ( \"user.id\" )) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String , default = \"moishe\" ) pets : Mapped [ list [ Pet ]] = relationship ( \"Pet\" , uselist = True , back_populates = \"owner\" ) class PetModel ( BaseModel ): class Config : orm_mode = True id : int name : str class UserModel ( BaseModel ): class Config : orm_mode = True id : int name : str pets : list [ PetModel ] def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , pets = [ Pet ( id = 1 , name = \"Paul\" )]) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> UserModel : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : User | None = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return UserModel . from_orm ( user ) app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) In action Run the above with uvicorn sqlalchemy_relationships_to_many:app , navigate your browser to http://127.0.0.0:8000/user/1 and you will see: { \"id\" : 1 , \"name\" : \"Peter\" , \"pets\" : [ { \"id\" : 1 , \"name\" : \"Paul\" } ] } Configuration You can configure the Plugin using the SQLAlchemyPluginConfig object. See the API Reference for a full list all the options available on SQLAlchemyConfig .","title":"SQLAlchemy Plugin"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#sqlalchemy-plugin","text":"Starlite comes with built-in support for SQLAlchemy via the SQLAlchemyPlugin .","title":"SQLAlchemy Plugin"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#features","text":"Managed sessions (sync and async) including dependency injection Automatic serialization of SQLAlchemy models powered pydantic Data validation based on SQLAlchemy models powered pydantic Info The following examples use SQLAlchemy's \"2.0 Style\" introduced in SQLAlchemy 1.4. If you are unfamiliar with it, you can find a comprehensive migration guide in SQLAlchemy's documentation here , and a handy table comparing the ORM usage Important The SQLAlchemyPlugin supports only mapped classes . Tables are currently not supported since they are not easy to convert to pydantic models.","title":"Features"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#basic-use","text":"You can simply pass an instance of SQLAlchemyPlugin without passing config to the Starlite constructor. This will extend support for serialization, deserialization and DTO creation for SQLAlchemy declarative models: Async Sync Python 3.8+ Python 3.10+ sqlalchemy_plugin.py from typing import Optional from sqlalchemy import Column , Float , Integer , String , select from sqlalchemy.ext.asyncio import AsyncSession from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get , post from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite:///test.sqlite\" , dependency_key = \"async_session\" ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) CreateCompanyDTO = dto_factory ( \"CreateCompanyDTO\" , Company , exclude = [ \"id\" ]) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" async with sqlalchemy_config . engine . begin () as conn : # type: ignore await conn . run_sync ( Base . metadata . create_all ) # pyright: ignore @post ( path = \"/companies\" ) async def create_company ( data : CreateCompanyDTO , # type: ignore[valid-type] async_session : AsyncSession , ) -> Company : \"\"\"Create a new company and return it.\"\"\" company : Company = data . to_model_instance () # type: ignore[attr-defined] async_session . add ( company ) await async_session . commit () return company @get ( path = \"/companies/{company_id:int}\" ) async def get_company ( company_id : str , async_session : AsyncSession ) -> Company : \"\"\"Get a company by its ID and return it. If a company with that ID does not exist, return a 404 response \"\"\" result = await async_session . scalars ( select ( Company ) . where ( Company . id == company_id )) company : Optional [ Company ] = result . one_or_none () if not company : raise HTTPException ( detail = f \"Company with ID { company_id } not found\" , status_code = HTTP_404_NOT_FOUND ) return company app = Starlite ( route_handlers = [ create_company , get_company ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_plugin.py from sqlalchemy import Column , Float , Integer , String , select from sqlalchemy.ext.asyncio import AsyncSession from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get , post from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite:///test.sqlite\" , dependency_key = \"async_session\" ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) CreateCompanyDTO = dto_factory ( \"CreateCompanyDTO\" , Company , exclude = [ \"id\" ]) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" async with sqlalchemy_config . engine . begin () as conn : # type: ignore await conn . run_sync ( Base . metadata . create_all ) # pyright: ignore @post ( path = \"/companies\" ) async def create_company ( data : CreateCompanyDTO , # type: ignore[valid-type] async_session : AsyncSession , ) -> Company : \"\"\"Create a new company and return it.\"\"\" company : Company = data . to_model_instance () # type: ignore[attr-defined] async_session . add ( company ) await async_session . commit () return company @get ( path = \"/companies/{company_id:int}\" ) async def get_company ( company_id : str , async_session : AsyncSession ) -> Company : \"\"\"Get a company by its ID and return it. If a company with that ID does not exist, return a 404 response \"\"\" result = await async_session . scalars ( select ( Company ) . where ( Company . id == company_id )) company : Company | None = result . one_or_none () if not company : raise HTTPException ( detail = f \"Company with ID { company_id } not found\" , status_code = HTTP_404_NOT_FOUND ) return company app = Starlite ( route_handlers = [ create_company , get_company ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) Python 3.8+ Python 3.10+ sqlalchemy_plugin.py from typing import Optional from sqlalchemy import Column , Float , Integer , String , select from sqlalchemy.orm import Mapped , Session , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get , post from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+pysqlite:///test.sqlite\" , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) CreateCompanyDTO = dto_factory ( \"CreateCompanyDTO\" , Company , exclude = [ \"id\" ]) def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( sqlalchemy_config . engine ) # type: ignore @post ( path = \"/companies\" ) def create_company ( data : CreateCompanyDTO , # type: ignore[valid-type] db_session : Session , ) -> Company : \"\"\"Create a new company and return it.\"\"\" company : Company = data . to_model_instance () # type: ignore[attr-defined] db_session . add ( company ) db_session . commit () return company @get ( path = \"/companies/{company_id:int}\" ) def get_company ( company_id : str , db_session : Session ) -> Company : \"\"\"Get a company by its ID and return it. If a company with that ID does not exist, return a 404 response \"\"\" company : Optional [ Company ] = db_session . scalars ( select ( Company ) . where ( Company . id == company_id )) . one_or_none () if not company : raise HTTPException ( detail = f \"Company with ID { company_id } not found\" , status_code = HTTP_404_NOT_FOUND ) return company app = Starlite ( route_handlers = [ create_company , get_company ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_plugin.py from sqlalchemy import Column , Float , Integer , String , select from sqlalchemy.orm import Mapped , Session , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get , post from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+pysqlite:///test.sqlite\" , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) CreateCompanyDTO = dto_factory ( \"CreateCompanyDTO\" , Company , exclude = [ \"id\" ]) def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( sqlalchemy_config . engine ) # type: ignore @post ( path = \"/companies\" ) def create_company ( data : CreateCompanyDTO , # type: ignore[valid-type] db_session : Session , ) -> Company : \"\"\"Create a new company and return it.\"\"\" company : Company = data . to_model_instance () # type: ignore[attr-defined] db_session . add ( company ) db_session . commit () return company @get ( path = \"/companies/{company_id:int}\" ) def get_company ( company_id : str , db_session : Session ) -> Company : \"\"\"Get a company by its ID and return it. If a company with that ID does not exist, return a 404 response \"\"\" company : Company | None = db_session . scalars ( select ( Company ) . where ( Company . id == company_id )) . one_or_none () if not company : raise HTTPException ( detail = f \"Company with ID { company_id } not found\" , status_code = HTTP_404_NOT_FOUND ) return company app = Starlite ( route_handlers = [ create_company , get_company ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) Using imperative mappings Imperative mappings are supported as well, just make sure to use a mapped class instead of the table itself company_table = Table ( \"company\" , Base . registry . metadata , Column ( \"id\" , Integer , primary_key = True ), Column ( \"name\" , String ), Column ( \"worth\" , Float ), ) class Company : pass Base . registry . map_imperatively ( Company , company_table )","title":"Basic Use"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#relationships","text":"Important Currently only to-one relationships are supported because of the way the SQLAlchemy plugin handles relationships. Since it recursively traverses relationships, a cyclic reference will result in an endless loop. To prevent this, these relationships will be type as Any in the pydantic model Important Relationships are typed as Optional in the pydantic model by default so sending incomplete models won't cause any issues","title":"Relationships"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#simple-relationships","text":"Simple relationships can be handled by the plugin automatically: Python 3.8+ Python 3.10+ sqlalchemy_relationships.py from typing import Optional from sqlalchemy import Column , Float , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite://\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) company_id : Mapped [ int ] = Column ( Integer , ForeignKey ( \"company.id\" )) company : Mapped [ Company ] = relationship ( \"Company\" , uselist = False ) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , company = Company ( name = \"Peter Co.\" , worth = 0.0 )) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> User : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : Optional [ User ] = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return user app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_relationships.py from sqlalchemy import Column , Float , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite://\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) worth : Mapped [ float ] = Column ( Float ) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) company_id : Mapped [ int ] = Column ( Integer , ForeignKey ( \"company.id\" )) company : Mapped [ Company ] = relationship ( \"Company\" , uselist = False ) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , company = Company ( name = \"Peter Co.\" , worth = 0.0 )) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> User : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : User | None = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return user app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) In action Run the above with uvicorn sqlalchemy_relationships:app , navigate your browser to http://127.0.0.0:8000/user/1 and you will see: { \"id\" : 1 , \"name\" : \"Peter\" , \"company_id\" : 1 , \"company\" : { \"id\" : 1 , \"name\" : \"Peter Co.\" , \"worth\" : 0 } }","title":"Simple relationships"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#to-many-relationships-and-circular-references","text":"For to-many relationships or those that contain circular references you need to define the pydantic models yourself: Python 3.8+ Python 3.9+ Python 3.10+ sqlalchemy_relationships_to_many from typing import List , Optional from pydantic import BaseModel from sqlalchemy import Column , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite:///test.sqlite\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Pet ( Base ): __tablename__ = \"pet\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) owner : Mapped [ \"User\" ] = relationship ( \"User\" , back_populates = \"pets\" , uselist = True ) owner_id : Mapped [ int ] = Column ( ForeignKey ( \"user.id\" )) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String , default = \"moishe\" ) pets : Mapped [ List [ Pet ]] = relationship ( \"Pet\" , uselist = True , back_populates = \"owner\" ) class PetModel ( BaseModel ): class Config : orm_mode = True id : int name : str class UserModel ( BaseModel ): class Config : orm_mode = True id : int name : str pets : List [ PetModel ] def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , pets = [ Pet ( id = 1 , name = \"Paul\" )]) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> UserModel : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : Optional [ User ] = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return UserModel . from_orm ( user ) app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_relationships_to_many from typing import Optional from pydantic import BaseModel from sqlalchemy import Column , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite:///test.sqlite\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Pet ( Base ): __tablename__ = \"pet\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) owner : Mapped [ \"User\" ] = relationship ( \"User\" , back_populates = \"pets\" , uselist = True ) owner_id : Mapped [ int ] = Column ( ForeignKey ( \"user.id\" )) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String , default = \"moishe\" ) pets : Mapped [ list [ Pet ]] = relationship ( \"Pet\" , uselist = True , back_populates = \"owner\" ) class PetModel ( BaseModel ): class Config : orm_mode = True id : int name : str class UserModel ( BaseModel ): class Config : orm_mode = True id : int name : str pets : list [ PetModel ] def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , pets = [ Pet ( id = 1 , name = \"Paul\" )]) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> UserModel : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : Optional [ User ] = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return UserModel . from_orm ( user ) app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) sqlalchemy_relationships_to_many from pydantic import BaseModel from sqlalchemy import Column , ForeignKey , Integer , String , create_engine , select from sqlalchemy.orm import Mapped , Session , declarative_base , relationship from starlite import HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND engine = create_engine ( \"sqlite+pysqlite:///test.sqlite\" ) sqlalchemy_config = SQLAlchemyConfig ( engine_instance = engine , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) Base = declarative_base () class Pet ( Base ): __tablename__ = \"pet\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String ) owner : Mapped [ \"User\" ] = relationship ( \"User\" , back_populates = \"pets\" , uselist = True ) owner_id : Mapped [ int ] = Column ( ForeignKey ( \"user.id\" )) class User ( Base ): __tablename__ = \"user\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) name : Mapped [ str ] = Column ( String , default = \"moishe\" ) pets : Mapped [ list [ Pet ]] = relationship ( \"Pet\" , uselist = True , back_populates = \"owner\" ) class PetModel ( BaseModel ): class Config : orm_mode = True id : int name : str class UserModel ( BaseModel ): class Config : orm_mode = True id : int name : str pets : list [ PetModel ] def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( engine ) with Session ( engine ) as session : peter = User ( id = 1 , name = \"Peter\" , pets = [ Pet ( id = 1 , name = \"Paul\" )]) session . add ( peter ) session . commit () @get ( path = \"/user/{user_id:int}\" ) def get_user ( user_id : int , db_session : Session ) -> UserModel : \"\"\"Get a user by its ID and return it. If a user with that ID does not exist, return a 404 response \"\"\" user : User | None = db_session . scalars ( select ( User ) . where ( User . id == user_id )) . one_or_none () if not user : raise HTTPException ( detail = f \"User with ID { user } not found\" , status_code = HTTP_404_NOT_FOUND ) return UserModel . from_orm ( user ) app = Starlite ( route_handlers = [ get_user ], on_startup = [ on_startup ], plugins = [ sqlalchemy_plugin ], ) In action Run the above with uvicorn sqlalchemy_relationships_to_many:app , navigate your browser to http://127.0.0.0:8000/user/1 and you will see: { \"id\" : 1 , \"name\" : \"Peter\" , \"pets\" : [ { \"id\" : 1 , \"name\" : \"Paul\" } ] }","title":"To-Many relationships and circular references"},{"location":"usage/10-plugins/1-sql-alchemy-plugin/#configuration","text":"You can configure the Plugin using the SQLAlchemyPluginConfig object. See the API Reference for a full list all the options available on SQLAlchemyConfig .","title":"Configuration"},{"location":"usage/10-plugins/2-tortoise-orm-plugin/","text":"Tortoise ORM Plugin To use the TortoiseORMPlugin import it and pass it to the Starlite constructor : from typing import cast from tortoise import Model , Tortoise , fields from tortoise.connection import connections from starlite import Starlite , get , post from starlite.plugins.tortoise_orm import TortoiseORMPlugin class Tournament ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) optional = fields . TextField ( null = True ) events : fields . ReverseRelation [ \"Event\" ] class Meta : ordering = [ \"name\" ] class Event ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) tournament : fields . ForeignKeyNullableRelation [ Tournament ] = fields . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" , null = True ) participants : fields . ManyToManyRelation [ \"Team\" ] = fields . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) address : fields . OneToOneNullableRelation [ \"Address\" ] class Meta : ordering = [ \"name\" ] class Address ( Model ): city = fields . CharField ( max_length = 64 ) street = fields . CharField ( max_length = 128 ) created_at = fields . DatetimeField ( auto_now_add = True ) event : fields . OneToOneRelation [ Event ] = fields . OneToOneField ( \"models.Event\" , related_name = \"address\" , pk = True ) class Meta : ordering = [ \"city\" ] class Team ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) events : fields . ManyToManyRelation [ Event ] class Meta : ordering = [ \"name\" ] async def init_tortoise () -> None : await Tortoise . init ( db_url = \"sqlite://:memory:\" , modules = { \"models\" : [ __name__ ]}) await Tortoise . generate_schemas () async def shutdown_tortoise () -> None : await connections . close_all () @get ( \"/tournaments\" ) async def get_tournaments () -> list [ Tournament ]: tournaments = await Tournament . all () return cast ( \"list[Tournament]\" , tournaments ) @get ( \"/tournaments/{tournament_id:int}\" ) async def get_tournament ( tournament_id : int ) -> Tournament : tournament = await Tournament . filter ( id = tournament_id ) . first () return cast ( \"Tournament\" , tournament ) @post ( \"/tournaments\" ) async def create_tournament ( data : Tournament ) -> Tournament : assert isinstance ( data , Tournament ) await data . save () await data . refresh_from_db () return data app = Starlite ( route_handlers = [ get_tournament , get_tournaments , create_tournament ], on_startup = [ init_tortoise ], on_shutdown = [ shutdown_tortoise ], plugins = [ TortoiseORMPlugin ()], ) With the plugin in place, you can use any Tortoise model as a type in route handlers.","title":"Tortoise ORM Plugin"},{"location":"usage/10-plugins/2-tortoise-orm-plugin/#tortoise-orm-plugin","text":"To use the TortoiseORMPlugin import it and pass it to the Starlite constructor : from typing import cast from tortoise import Model , Tortoise , fields from tortoise.connection import connections from starlite import Starlite , get , post from starlite.plugins.tortoise_orm import TortoiseORMPlugin class Tournament ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) optional = fields . TextField ( null = True ) events : fields . ReverseRelation [ \"Event\" ] class Meta : ordering = [ \"name\" ] class Event ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) tournament : fields . ForeignKeyNullableRelation [ Tournament ] = fields . ForeignKeyField ( \"models.Tournament\" , related_name = \"events\" , null = True ) participants : fields . ManyToManyRelation [ \"Team\" ] = fields . ManyToManyField ( \"models.Team\" , related_name = \"events\" , through = \"event_team\" ) address : fields . OneToOneNullableRelation [ \"Address\" ] class Meta : ordering = [ \"name\" ] class Address ( Model ): city = fields . CharField ( max_length = 64 ) street = fields . CharField ( max_length = 128 ) created_at = fields . DatetimeField ( auto_now_add = True ) event : fields . OneToOneRelation [ Event ] = fields . OneToOneField ( \"models.Event\" , related_name = \"address\" , pk = True ) class Meta : ordering = [ \"city\" ] class Team ( Model ): id = fields . IntField ( pk = True ) name = fields . TextField () created_at = fields . DatetimeField ( auto_now_add = True ) events : fields . ManyToManyRelation [ Event ] class Meta : ordering = [ \"name\" ] async def init_tortoise () -> None : await Tortoise . init ( db_url = \"sqlite://:memory:\" , modules = { \"models\" : [ __name__ ]}) await Tortoise . generate_schemas () async def shutdown_tortoise () -> None : await connections . close_all () @get ( \"/tournaments\" ) async def get_tournaments () -> list [ Tournament ]: tournaments = await Tournament . all () return cast ( \"list[Tournament]\" , tournaments ) @get ( \"/tournaments/{tournament_id:int}\" ) async def get_tournament ( tournament_id : int ) -> Tournament : tournament = await Tournament . filter ( id = tournament_id ) . first () return cast ( \"Tournament\" , tournament ) @post ( \"/tournaments\" ) async def create_tournament ( data : Tournament ) -> Tournament : assert isinstance ( data , Tournament ) await data . save () await data . refresh_from_db () return data app = Starlite ( route_handlers = [ get_tournament , get_tournaments , create_tournament ], on_startup = [ init_tortoise ], on_shutdown = [ shutdown_tortoise ], plugins = [ TortoiseORMPlugin ()], ) With the plugin in place, you can use any Tortoise model as a type in route handlers.","title":"Tortoise ORM Plugin"},{"location":"usage/10-plugins/3-piccolo-orm-plugin/","text":"Piccolo ORM Plugin To use the PiccoloORMPlugin import it and pass it to the Starlite constructor : from starlite import Starlite , post , get from starlite.plugins.piccolo_orm import PiccoloORMPlugin from piccolo.columns.column_types import ( JSON , JSONB , ForeignKey , Integer , Varchar , ) from piccolo.table import Table class RecordingStudio ( Table ): facilities = JSON () facilities_b = JSONB () class Manager ( Table ): name = Varchar ( length = 50 ) class Band ( Table ): name = Varchar ( length = 50 ) manager = ForeignKey ( Manager ) popularity = Integer () class Venue ( Table ): name = Varchar ( length = 100 ) capacity = Integer ( secret = True ) class Concert ( Table ): band_1 = ForeignKey ( Band ) band_2 = ForeignKey ( Band ) venue = ForeignKey ( Venue ) @post ( \"/concert\" ) async def create_concert ( data : Concert ) -> Concert : await data . save () await data . refresh () return data @get ( \"/studio/{studio_id:int}\" ) async def retrieve_studio ( studio_id : int ) -> RecordingStudio : return await RecordingStudio . select () . where ( RecordingStudio . id == studio_id ) @get ( \"/venues\" ) async def retrieve_venues () -> list [ Venue ]: return await Venue . select () app = Starlite ( route_handlers = [ create_concert , retrieve_studio , retrieve_venues ], plugins = [ PiccoloORMPlugin ()], ) With the plugin in place, you can use any Piccolo tables as a type in route handlers.","title":"Piccolo ORM Plugin"},{"location":"usage/10-plugins/3-piccolo-orm-plugin/#piccolo-orm-plugin","text":"To use the PiccoloORMPlugin import it and pass it to the Starlite constructor : from starlite import Starlite , post , get from starlite.plugins.piccolo_orm import PiccoloORMPlugin from piccolo.columns.column_types import ( JSON , JSONB , ForeignKey , Integer , Varchar , ) from piccolo.table import Table class RecordingStudio ( Table ): facilities = JSON () facilities_b = JSONB () class Manager ( Table ): name = Varchar ( length = 50 ) class Band ( Table ): name = Varchar ( length = 50 ) manager = ForeignKey ( Manager ) popularity = Integer () class Venue ( Table ): name = Varchar ( length = 100 ) capacity = Integer ( secret = True ) class Concert ( Table ): band_1 = ForeignKey ( Band ) band_2 = ForeignKey ( Band ) venue = ForeignKey ( Venue ) @post ( \"/concert\" ) async def create_concert ( data : Concert ) -> Concert : await data . save () await data . refresh () return data @get ( \"/studio/{studio_id:int}\" ) async def retrieve_studio ( studio_id : int ) -> RecordingStudio : return await RecordingStudio . select () . where ( RecordingStudio . id == studio_id ) @get ( \"/venues\" ) async def retrieve_venues () -> list [ Venue ]: return await Venue . select () app = Starlite ( route_handlers = [ create_concert , retrieve_studio , retrieve_venues ], plugins = [ PiccoloORMPlugin ()], ) With the plugin in place, you can use any Piccolo tables as a type in route handlers.","title":"Piccolo ORM Plugin"},{"location":"usage/11-data-transfer-objects/0-dto/","text":"Data Transfer Objects (DTOs) Starlite includes a DTOFactory class that allows you to create DTOs from pydantic models, dataclasses, TypedDict , and any other class supported via plugins. An instance of the factory must first be created, optionally passing plugins to it as a kwarg. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes, remap field names and field types, and add new fields. The created DTO can be used for data parsing, validation and OpenAPI schema generation like a regularly declared pydantic model. Important Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently impossible to extend editor auto-complete for the DTO properties - it will be typed as DTO[T] , with T being a generic argument representing the original model used to create the DTO. Note MyPy doesn't support using types defined using Type[] as a type, and MyPy will regard these as invalid types. There is currently no way to circumvent this (not even with a plugin) except using a # type: ignore comment. The DTOFactory class supports plugins , for example, this is how it could be used with an SQLAlchemy declarative class using the SQLAlchemyPlugin : Declaring a DTO from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) The created CompanyDTO is equal to this pydantic model declaration: from pydantic import BaseModel class CompanyDTO ( BaseModel ): id : int name : str worth : float You can now use it in route handler functions as you would any other pydantic model. The one caveat though is lack of editor completion and mypy support - this requires the implementation of a mypy plugin, which is planned for the future. Excluding Fields You can exclude any field in the original model class from the DTO : Excluding fields from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , exclude = [ \"first\" ]) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int Remapping Fields You can remap fields in two ways: you can switch change their keys: Remapping fields from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_mapping = { \"first\" : \"third\" }) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int third : int You can remap name and type. To do this use a tuple instead of a string for the object value: Remapping fields with types from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_mapping = { \"first\" : \"third\" , \"second\" : ( \"fourth\" , float )}) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): third : int fourth : float Add New Fields You add fields that do not exist in the original model by passing in a field_definitions dictionary. This dictionary should have field names as keys, and a tuple following the format supported by the pydantic create_model helper : For required fields use a tuple of type + ellipsis, for example (str, ...) . For optional fields use a tuple of type + None , for example (str, None) To set a default value use a tuple of type + default value, for example (str, \"Hello World\") Add new fields from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_definitions = { \"third\" : ( str , ... )}) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): first : int second : int third : str DTO Methods DTO.from_model_instance() Once you create a DTO class you can use its class method from_model_instance() to create an instance from an existing instance of the model from which the DTO was generated: DTO.from_model_instance() from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) company_instance = Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 ) dto_instance = CompanyDTO . from_model_instance ( company_instance ) In the above, dto_instance is a validated pydantic model instance. DTO.to_model_instance() When you have an instance of a DTO model, you can convert it into a model instance using the to_model_instance() method: DTO.to_model_instance() from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , post from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) @post () def create_company ( data : CompanyDTO ) -> Company : # type: ignore return data . to_model_instance () # type: ignore In the above company_instance is an instance of the SQLAlchemy declarative class Company . It is correctly typed as Company because the DTO class uses generic to store this data. Important If you exclude keys or add additional fields, you should make sure this does not cause an error when trying to generate a model class from a dto instance. For example, if you exclude required fields from a pydantic model and try to create an instance from a dto that doesn't have these, a validation error will be raised. Automatic Conversion on Response When you use a DTO as a return type in a route handler, if the returned data is a model or a dict, it will be converted to the DTO automatically: Python 3.8+ Python 3.9+ DTO automatic conversion from typing import List from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND sqlalchemy_plugin = SQLAlchemyPlugin () dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore secret : Mapped [ str ] = Column ( String ) # pyright: ignore ReadCompanyDTO = dto_factory ( \"CompanyDTO\" , Company , exclude = [ \"secret\" ]) companies : List [ Company ] = [ Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 , secret = \"secret\" ), Company ( id = 2 , name = \"My New Firm\" , worth = 1000.0 , secret = \"abc123\" ), ] @get ( \"/{company_id: int}\" ) def get_company ( company_id : int ) -> ReadCompanyDTO : # type: ignore try : return companies [ company_id - 1 ] except IndexError : raise HTTPException ( detail = \"Company not found\" , status_code = HTTP_404_NOT_FOUND , ) @get () def get_companies () -> List [ ReadCompanyDTO ]: # type: ignore return companies app = Starlite ( route_handlers = [ get_company , get_companies ], plugins = [ sqlalchemy_plugin ], ) DTO automatic conversion from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND sqlalchemy_plugin = SQLAlchemyPlugin () dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore secret : Mapped [ str ] = Column ( String ) # pyright: ignore ReadCompanyDTO = dto_factory ( \"CompanyDTO\" , Company , exclude = [ \"secret\" ]) companies : list [ Company ] = [ Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 , secret = \"secret\" ), Company ( id = 2 , name = \"My New Firm\" , worth = 1000.0 , secret = \"abc123\" ), ] @get ( \"/{company_id: int}\" ) def get_company ( company_id : int ) -> ReadCompanyDTO : # type: ignore try : return companies [ company_id - 1 ] except IndexError : raise HTTPException ( detail = \"Company not found\" , status_code = HTTP_404_NOT_FOUND , ) @get () def get_companies () -> list [ ReadCompanyDTO ]: # type: ignore return companies app = Starlite ( route_handlers = [ get_company , get_companies ], plugins = [ sqlalchemy_plugin ], ) In the above, when requesting route of a company, the secret attribute will not be included in the response. And it also works when returning a list of companies.","title":"Data Transfer Objects (DTOs)"},{"location":"usage/11-data-transfer-objects/0-dto/#data-transfer-objects-dtos","text":"Starlite includes a DTOFactory class that allows you to create DTOs from pydantic models, dataclasses, TypedDict , and any other class supported via plugins. An instance of the factory must first be created, optionally passing plugins to it as a kwarg. It can then be used to create a DTO by calling the instance like a function. Additionally, it can exclude (drop) attributes, remap field names and field types, and add new fields. The created DTO can be used for data parsing, validation and OpenAPI schema generation like a regularly declared pydantic model. Important Although the value generated is a pydantic factory, because it is being generated programmatically, it's currently impossible to extend editor auto-complete for the DTO properties - it will be typed as DTO[T] , with T being a generic argument representing the original model used to create the DTO. Note MyPy doesn't support using types defined using Type[] as a type, and MyPy will regard these as invalid types. There is currently no way to circumvent this (not even with a plugin) except using a # type: ignore comment. The DTOFactory class supports plugins , for example, this is how it could be used with an SQLAlchemy declarative class using the SQLAlchemyPlugin : Declaring a DTO from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) The created CompanyDTO is equal to this pydantic model declaration: from pydantic import BaseModel class CompanyDTO ( BaseModel ): id : int name : str worth : float You can now use it in route handler functions as you would any other pydantic model. The one caveat though is lack of editor completion and mypy support - this requires the implementation of a mypy plugin, which is planned for the future.","title":"Data Transfer Objects (DTOs)"},{"location":"usage/11-data-transfer-objects/0-dto/#excluding-fields","text":"You can exclude any field in the original model class from the DTO : Excluding fields from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , exclude = [ \"first\" ]) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int","title":"Excluding Fields"},{"location":"usage/11-data-transfer-objects/0-dto/#remapping-fields","text":"You can remap fields in two ways: you can switch change their keys: Remapping fields from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_mapping = { \"first\" : \"third\" }) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): second : int third : int You can remap name and type. To do this use a tuple instead of a string for the object value: Remapping fields with types from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_mapping = { \"first\" : \"third\" , \"second\" : ( \"fourth\" , float )}) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): third : int fourth : float","title":"Remapping Fields"},{"location":"usage/11-data-transfer-objects/0-dto/#add-new-fields","text":"You add fields that do not exist in the original model by passing in a field_definitions dictionary. This dictionary should have field names as keys, and a tuple following the format supported by the pydantic create_model helper : For required fields use a tuple of type + ellipsis, for example (str, ...) . For optional fields use a tuple of type + None , for example (str, None) To set a default value use a tuple of type + default value, for example (str, \"Hello World\") Add new fields from pydantic import BaseModel from starlite import DTOFactory class MyClass ( BaseModel ): first : int second : int dto_factory = DTOFactory () MyClassDTO = dto_factory ( \"MyClassDTO\" , MyClass , field_definitions = { \"third\" : ( str , ... )}) The generated MyClassDTO is equal to this model declaration: from pydantic import BaseModel class MyClassDTO ( BaseModel ): first : int second : int third : str","title":"Add New Fields"},{"location":"usage/11-data-transfer-objects/0-dto/#dto-methods","text":"","title":"DTO Methods"},{"location":"usage/11-data-transfer-objects/0-dto/#dtofrom_model_instance","text":"Once you create a DTO class you can use its class method from_model_instance() to create an instance from an existing instance of the model from which the DTO was generated: DTO.from_model_instance() from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) company_instance = Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 ) dto_instance = CompanyDTO . from_model_instance ( company_instance ) In the above, dto_instance is a validated pydantic model instance.","title":"DTO.from_model_instance()"},{"location":"usage/11-data-transfer-objects/0-dto/#dtoto_model_instance","text":"When you have an instance of a DTO model, you can convert it into a model instance using the to_model_instance() method: DTO.to_model_instance() from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , post from starlite.plugins.sql_alchemy import SQLAlchemyPlugin dto_factory = DTOFactory ( plugins = [ SQLAlchemyPlugin ()]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore CompanyDTO = dto_factory ( \"CompanyDTO\" , Company ) @post () def create_company ( data : CompanyDTO ) -> Company : # type: ignore return data . to_model_instance () # type: ignore In the above company_instance is an instance of the SQLAlchemy declarative class Company . It is correctly typed as Company because the DTO class uses generic to store this data. Important If you exclude keys or add additional fields, you should make sure this does not cause an error when trying to generate a model class from a dto instance. For example, if you exclude required fields from a pydantic model and try to create an instance from a dto that doesn't have these, a validation error will be raised.","title":"DTO.to_model_instance()"},{"location":"usage/11-data-transfer-objects/0-dto/#automatic-conversion-on-response","text":"When you use a DTO as a return type in a route handler, if the returned data is a model or a dict, it will be converted to the DTO automatically: Python 3.8+ Python 3.9+ DTO automatic conversion from typing import List from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND sqlalchemy_plugin = SQLAlchemyPlugin () dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore secret : Mapped [ str ] = Column ( String ) # pyright: ignore ReadCompanyDTO = dto_factory ( \"CompanyDTO\" , Company , exclude = [ \"secret\" ]) companies : List [ Company ] = [ Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 , secret = \"secret\" ), Company ( id = 2 , name = \"My New Firm\" , worth = 1000.0 , secret = \"abc123\" ), ] @get ( \"/{company_id: int}\" ) def get_company ( company_id : int ) -> ReadCompanyDTO : # type: ignore try : return companies [ company_id - 1 ] except IndexError : raise HTTPException ( detail = \"Company not found\" , status_code = HTTP_404_NOT_FOUND , ) @get () def get_companies () -> List [ ReadCompanyDTO ]: # type: ignore return companies app = Starlite ( route_handlers = [ get_company , get_companies ], plugins = [ sqlalchemy_plugin ], ) DTO automatic conversion from sqlalchemy import Column , Float , Integer , String from sqlalchemy.orm import Mapped , declarative_base from starlite import DTOFactory , HTTPException , Starlite , get from starlite.plugins.sql_alchemy import SQLAlchemyPlugin from starlite.status_codes import HTTP_404_NOT_FOUND sqlalchemy_plugin = SQLAlchemyPlugin () dto_factory = DTOFactory ( plugins = [ sqlalchemy_plugin ]) Base = declarative_base () class Company ( Base ): # pyright: ignore __tablename__ = \"company\" id : Mapped [ int ] = Column ( Integer , primary_key = True ) # pyright: ignore name : Mapped [ str ] = Column ( String ) # pyright: ignore worth : Mapped [ float ] = Column ( Float ) # pyright: ignore secret : Mapped [ str ] = Column ( String ) # pyright: ignore ReadCompanyDTO = dto_factory ( \"CompanyDTO\" , Company , exclude = [ \"secret\" ]) companies : list [ Company ] = [ Company ( id = 1 , name = \"My Firm\" , worth = 1000000.0 , secret = \"secret\" ), Company ( id = 2 , name = \"My New Firm\" , worth = 1000.0 , secret = \"abc123\" ), ] @get ( \"/{company_id: int}\" ) def get_company ( company_id : int ) -> ReadCompanyDTO : # type: ignore try : return companies [ company_id - 1 ] except IndexError : raise HTTPException ( detail = \"Company not found\" , status_code = HTTP_404_NOT_FOUND , ) @get () def get_companies () -> list [ ReadCompanyDTO ]: # type: ignore return companies app = Starlite ( route_handlers = [ get_company , get_companies ], plugins = [ sqlalchemy_plugin ], ) In the above, when requesting route of a company, the secret attribute will not be included in the response. And it also works when returning a list of companies.","title":"Automatic Conversion on Response"},{"location":"usage/11-data-transfer-objects/1-partial/","text":"Partial DTOs For PATCH HTTP methods, you may only need to partially modify a resource. In these cases, DTOs can be wrapped with Partial . from pydantic import BaseModel from starlite.types.partial import Partial class CompanyDTO ( BaseModel ): id : int name : str worth : float PartialCompanyDTO = Partial [ CompanyDTO ] The created PartialCompanyDTO is equivalent to the following declaration: Python 3.8+ Python 3.10+ from typing import Optional from pydantic import BaseModel class PartialCompanyDTO ( BaseModel ): id : Optional [ int ] name : Optional [ str ] worth : Optional [ float ] from pydantic import BaseModel class PartialCompanyDTO ( BaseModel ): id : int | None name : str | None worth : float | None Partial can also be used inline when creating routes. from pydantic import UUID4 , BaseModel from starlite.controller import Controller from starlite.handlers import patch from starlite.types.partial import Partial class UserOrder ( BaseModel ): order_id : UUID4 order_item_id : UUID4 notes : str class UserOrderController ( Controller ): path = \"/user\" @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ] ) -> UserOrder : ...","title":"Partial DTOs"},{"location":"usage/11-data-transfer-objects/1-partial/#partial-dtos","text":"For PATCH HTTP methods, you may only need to partially modify a resource. In these cases, DTOs can be wrapped with Partial . from pydantic import BaseModel from starlite.types.partial import Partial class CompanyDTO ( BaseModel ): id : int name : str worth : float PartialCompanyDTO = Partial [ CompanyDTO ] The created PartialCompanyDTO is equivalent to the following declaration: Python 3.8+ Python 3.10+ from typing import Optional from pydantic import BaseModel class PartialCompanyDTO ( BaseModel ): id : Optional [ int ] name : Optional [ str ] worth : Optional [ float ] from pydantic import BaseModel class PartialCompanyDTO ( BaseModel ): id : int | None name : str | None worth : float | None Partial can also be used inline when creating routes. from pydantic import UUID4 , BaseModel from starlite.controller import Controller from starlite.handlers import patch from starlite.types.partial import Partial class UserOrder ( BaseModel ): order_id : UUID4 order_item_id : UUID4 notes : str class UserOrderController ( Controller ): path = \"/user\" @patch ( path = \"/{order_id:uuid}\" ) async def update_user_order ( self , order_id : UUID4 , data : Partial [ UserOrder ] ) -> UserOrder : ...","title":"Partial DTOs"},{"location":"usage/12-openapi/0-openapi-intro/","text":"OpenAPI Integration Starlite has first class OpenAPI support offering the following features: Automatic OpenAPI 3.1.0 Schema generation, which is available as both YAML and JSON. Builtin support for static documentation site generation using several different libraries. Simple configuration using pydantic based classes. Pydantic-OpenAPI-Schema Starlite generates the latest version of the OpenAPI specification using the pydantic-openapi-schema library, which is bundled as part of Starlite and is also maintained by the starlite-api GitHub organization. This library offers a full implementation of the OpenAPI specification as pydantic models, and is as such a powerful and type correct foundation for schema generation using python. Tip You can refer to the pydantic-openapi-schema doc for a full reference regarding the library's API.","title":"OpenAPI Integration"},{"location":"usage/12-openapi/0-openapi-intro/#openapi-integration","text":"Starlite has first class OpenAPI support offering the following features: Automatic OpenAPI 3.1.0 Schema generation, which is available as both YAML and JSON. Builtin support for static documentation site generation using several different libraries. Simple configuration using pydantic based classes.","title":"OpenAPI Integration"},{"location":"usage/12-openapi/0-openapi-intro/#pydantic-openapi-schema","text":"Starlite generates the latest version of the OpenAPI specification using the pydantic-openapi-schema library, which is bundled as part of Starlite and is also maintained by the starlite-api GitHub organization. This library offers a full implementation of the OpenAPI specification as pydantic models, and is as such a powerful and type correct foundation for schema generation using python. Tip You can refer to the pydantic-openapi-schema doc for a full reference regarding the library's API.","title":"Pydantic-OpenAPI-Schema"},{"location":"usage/12-openapi/1-schema-generation/","text":"OpenAPI Schema Generation Config OpenAPI schema generation is enabled by default. To configure it you can pass an instance of OpenAPIConfig to the Starlite constructor using the openapi_config kwarg: from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" ) ) Aside from title and version , both of which are required , you can pass the following optional kwargs: components : An instance of Components or list of instances. If a list is provided, its members will be merged recursively into a single instance. contact : An instance of the Contact . create_examples : Boolean flag dictating whether examples will be auto-generated using the pydantic-factories library. Defaults to False . description : Description text. external_docs : An instance of the ExternalDocumentation . license : An instance of the License . openapi_controller : The controller class to use for the openapi to generate the openapi related routes. Must be a subclass of the openapi controller class . security : An instance of the SecurityRequirement servers : A list of Server instances. Defaults to [Server(\"/\")] summary : Summary text. tags : A list of Tag instances. terms_of_service : A url to a page containing the terms of service. use_handler_docstrings : Boolean flag dictating whether to use route handler docstring to generate descriptions. webhooks : A string keyed dictionary of PathItem instances. # root_schema_site : Dictates which schema site is served by default. The value should be one of redoc , swagger , elements , with the default be redoc . enabled_endpoints : Dictates which schema site endpoints are enabled. It may have the following values redoc , swagger , elements , openapi.json , openapi.yaml . By default, it enables all endpoints. Disabling Schema Generation If you wish to disable schema generation and not include the schema endpoints in your API, simply pass None as the value for openapi_config : from starlite import Starlite app = Starlite ( route_handlers = [ ... ], openapi_config = None )","title":"OpenAPI Schema Generation Config"},{"location":"usage/12-openapi/1-schema-generation/#openapi-schema-generation-config","text":"OpenAPI schema generation is enabled by default. To configure it you can pass an instance of OpenAPIConfig to the Starlite constructor using the openapi_config kwarg: from starlite import Starlite , OpenAPIConfig app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" ) ) Aside from title and version , both of which are required , you can pass the following optional kwargs: components : An instance of Components or list of instances. If a list is provided, its members will be merged recursively into a single instance. contact : An instance of the Contact . create_examples : Boolean flag dictating whether examples will be auto-generated using the pydantic-factories library. Defaults to False . description : Description text. external_docs : An instance of the ExternalDocumentation . license : An instance of the License . openapi_controller : The controller class to use for the openapi to generate the openapi related routes. Must be a subclass of the openapi controller class . security : An instance of the SecurityRequirement servers : A list of Server instances. Defaults to [Server(\"/\")] summary : Summary text. tags : A list of Tag instances. terms_of_service : A url to a page containing the terms of service. use_handler_docstrings : Boolean flag dictating whether to use route handler docstring to generate descriptions. webhooks : A string keyed dictionary of PathItem instances. # root_schema_site : Dictates which schema site is served by default. The value should be one of redoc , swagger , elements , with the default be redoc . enabled_endpoints : Dictates which schema site endpoints are enabled. It may have the following values redoc , swagger , elements , openapi.json , openapi.yaml . By default, it enables all endpoints.","title":"OpenAPI Schema Generation Config"},{"location":"usage/12-openapi/1-schema-generation/#disabling-schema-generation","text":"If you wish to disable schema generation and not include the schema endpoints in your API, simply pass None as the value for openapi_config : from starlite import Starlite app = Starlite ( route_handlers = [ ... ], openapi_config = None )","title":"Disabling Schema Generation"},{"location":"usage/12-openapi/2-route-handler-configuration/","text":"Route Handler OpenAPI Configuration By default, an operation schema is generated for all route handlers. You can omit a route handler from the schema by setting include_in_schema=False : from starlite import get @get ( path = \"/some-path\" , include_in_schema = False ) def my_route_handler () -> None : ... You can also modify the generated schema for the route handler using the following kwargs: tags : A list of strings that correlate to the tag specification . security : A list of dictionaries that correlate to the security requirements specification . The values for this key are string keyed dictionaries with the values being a list of objects. summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ attribute of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved (e.g. there are parameters specified in the method/function). responses : A dictionary of additional status codes and a description of their expected content. The expected content should be based on a Pydantic model describing its structure. It can also include a description and the expected media type. For example: Python 3.8+ Python 3.10+ from datetime import datetime from typing import Optional from pydantic import BaseModel from starlite import ResponseSpec , get class Item ( BaseModel ): ... class ItemNotFound ( BaseModel ): was_removed : bool removed_at : Optional [ datetime ] @get ( path = \"/items/{pk:int}\" , responses = { 404 : ResponseSpec ( model = ItemNotFound , description = \"Item was removed or not found\" ) }, ) def retrieve_item ( pk : int ) -> Item : ... from datetime import datetime from pydantic import BaseModel from starlite import ResponseSpec , get class Item ( BaseModel ): ... class ItemNotFound ( BaseModel ): was_removed : bool removed_at : datetime | None @get ( path = \"/items/{pk:int}\" , responses = { 404 : ResponseSpec ( model = ItemNotFound , description = \"Item was removed or not found\" ) }, ) def retrieve_item ( pk : int ) -> Item : ... You can also specify security and tags on higher level of the application, e.g. on a controller, router or the app instance itself. For example: from starlite import Starlite , OpenAPIConfig , get from pydantic_openapi_schema.v3_1_0 import Components , SecurityScheme , Tag @get ( \"/public\" , tags = [ \"public\" ], security = [{}], # this endpoint is marked as having optional security ) def public_path_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } @get ( \"/other\" , tags = [ \"internal\" ], security = [{ \"apiKey\" : []}]) def internal_path_handler () -> None : ... app = Starlite ( route_handlers = [ public_path_handler , internal_path_handler ], openapi_config = OpenAPIConfig ( title = \"my api\" , version = \"1.0.0\" , tags = [ Tag ( name = \"public\" , description = \"This endpoint is for external users\" ), Tag ( name = \"internal\" , description = \"This endpoint is for internal users\" ), ], security = [{ \"BearerToken\" : []}], components = Components ( securitySchemes = { \"BearerToken\" : SecurityScheme ( type = \"http\" , scheme = \"bearer\" , ) }, ), ), )","title":"Route Handler OpenAPI Configuration"},{"location":"usage/12-openapi/2-route-handler-configuration/#route-handler-openapi-configuration","text":"By default, an operation schema is generated for all route handlers. You can omit a route handler from the schema by setting include_in_schema=False : from starlite import get @get ( path = \"/some-path\" , include_in_schema = False ) def my_route_handler () -> None : ... You can also modify the generated schema for the route handler using the following kwargs: tags : A list of strings that correlate to the tag specification . security : A list of dictionaries that correlate to the security requirements specification . The values for this key are string keyed dictionaries with the values being a list of objects. summary : Text used for the route's schema summary section. description : Text used for the route's schema description section. response_description : Text used for the route's response schema description section. operation_id : An identifier used for the route's schema operationId . Defaults to the __name__ attribute of the wrapped function. deprecated : A boolean dictating whether this route should be marked as deprecated in the OpenAPI schema. Defaults to False . raises : A list of exception classes extending from starlite.HttpException . This list should describe all exceptions raised within the route handler's function/method. The Starlite ValidationException will be added automatically for the schema if any validation is involved (e.g. there are parameters specified in the method/function). responses : A dictionary of additional status codes and a description of their expected content. The expected content should be based on a Pydantic model describing its structure. It can also include a description and the expected media type. For example: Python 3.8+ Python 3.10+ from datetime import datetime from typing import Optional from pydantic import BaseModel from starlite import ResponseSpec , get class Item ( BaseModel ): ... class ItemNotFound ( BaseModel ): was_removed : bool removed_at : Optional [ datetime ] @get ( path = \"/items/{pk:int}\" , responses = { 404 : ResponseSpec ( model = ItemNotFound , description = \"Item was removed or not found\" ) }, ) def retrieve_item ( pk : int ) -> Item : ... from datetime import datetime from pydantic import BaseModel from starlite import ResponseSpec , get class Item ( BaseModel ): ... class ItemNotFound ( BaseModel ): was_removed : bool removed_at : datetime | None @get ( path = \"/items/{pk:int}\" , responses = { 404 : ResponseSpec ( model = ItemNotFound , description = \"Item was removed or not found\" ) }, ) def retrieve_item ( pk : int ) -> Item : ... You can also specify security and tags on higher level of the application, e.g. on a controller, router or the app instance itself. For example: from starlite import Starlite , OpenAPIConfig , get from pydantic_openapi_schema.v3_1_0 import Components , SecurityScheme , Tag @get ( \"/public\" , tags = [ \"public\" ], security = [{}], # this endpoint is marked as having optional security ) def public_path_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } @get ( \"/other\" , tags = [ \"internal\" ], security = [{ \"apiKey\" : []}]) def internal_path_handler () -> None : ... app = Starlite ( route_handlers = [ public_path_handler , internal_path_handler ], openapi_config = OpenAPIConfig ( title = \"my api\" , version = \"1.0.0\" , tags = [ Tag ( name = \"public\" , description = \"This endpoint is for external users\" ), Tag ( name = \"internal\" , description = \"This endpoint is for internal users\" ), ], security = [{ \"BearerToken\" : []}], components = Components ( securitySchemes = { \"BearerToken\" : SecurityScheme ( type = \"http\" , scheme = \"bearer\" , ) }, ), ), )","title":"Route Handler OpenAPI Configuration"},{"location":"usage/12-openapi/3-openapi-controller/","text":"The OpenAPIController Starlite includes an OpenAPIController class that is used as the default controller in the OpenAPIConfig . This controller exposes the following endpoints: /schema/openapi.yaml : allowing for download of the OpenAPI schema as YAML. /schema/openapi.json : allowing for download of the OpenAPI schema as JSON. /schema/redoc : which serve the docs using Redoc . /schema/swagger : which serves the docs using Swagger-UI . /schema/elements : which serves the docs using Stoplight Elements . Additionally, the root /schema/ path is accessible, serving the site that is configured as the default in the OpenAPIConfig . Subclassing OpenAPIController You can use your own subclass of OpenAPIController by setting it as then controller to use in the OpenAPIConfig openapi_controller kwarg. For example, lets say we wanted to change the base path of the OpenAPI related endpoints from /schema to /api-docs , in this case we'd the following: from starlite import Starlite , OpenAPIController , OpenAPIConfig class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , openapi_controller = MyOpenAPIController ), ) See the API Reference for full details on the OpenAPIController class and the kwargs it accepts. CDN and offline file support You can change the default download paths for JS and CSS bundles as well as google fonts by subclassing OpenAPIController and setting any of the following class variables: from starlite import Starlite , OpenAPIController , OpenAPIConfig class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" redoc_google_fonts = False redoc_js_url = \"https://offline_location/redoc.standalone.js\" swagger_css_url = \"https://offline_location/swagger-ui-css\" swagger_ui_bundle_js_url = \"https://offline_location/swagger-ui-bundle.js\" swagger_ui_standalone_preset_js_url = ( \"https://offline_location/swagger-ui-standalone-preset.js\" ) stoplight_elements_css_url = \"https://offline_location/spotlight-styles.mins.css\" stoplight_elements_js_url = ( \"https://offline_location/spotlight-web-components.min.js\" ) app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , openapi_controller = MyOpenAPIController ), )","title":"The OpenAPIController"},{"location":"usage/12-openapi/3-openapi-controller/#the-openapicontroller","text":"Starlite includes an OpenAPIController class that is used as the default controller in the OpenAPIConfig . This controller exposes the following endpoints: /schema/openapi.yaml : allowing for download of the OpenAPI schema as YAML. /schema/openapi.json : allowing for download of the OpenAPI schema as JSON. /schema/redoc : which serve the docs using Redoc . /schema/swagger : which serves the docs using Swagger-UI . /schema/elements : which serves the docs using Stoplight Elements . Additionally, the root /schema/ path is accessible, serving the site that is configured as the default in the OpenAPIConfig .","title":"The OpenAPIController"},{"location":"usage/12-openapi/3-openapi-controller/#subclassing-openapicontroller","text":"You can use your own subclass of OpenAPIController by setting it as then controller to use in the OpenAPIConfig openapi_controller kwarg. For example, lets say we wanted to change the base path of the OpenAPI related endpoints from /schema to /api-docs , in this case we'd the following: from starlite import Starlite , OpenAPIController , OpenAPIConfig class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , openapi_controller = MyOpenAPIController ), ) See the API Reference for full details on the OpenAPIController class and the kwargs it accepts.","title":"Subclassing OpenAPIController"},{"location":"usage/12-openapi/3-openapi-controller/#cdn-and-offline-file-support","text":"You can change the default download paths for JS and CSS bundles as well as google fonts by subclassing OpenAPIController and setting any of the following class variables: from starlite import Starlite , OpenAPIController , OpenAPIConfig class MyOpenAPIController ( OpenAPIController ): path = \"/api-docs\" redoc_google_fonts = False redoc_js_url = \"https://offline_location/redoc.standalone.js\" swagger_css_url = \"https://offline_location/swagger-ui-css\" swagger_ui_bundle_js_url = \"https://offline_location/swagger-ui-bundle.js\" swagger_ui_standalone_preset_js_url = ( \"https://offline_location/swagger-ui-standalone-preset.js\" ) stoplight_elements_css_url = \"https://offline_location/spotlight-styles.mins.css\" stoplight_elements_js_url = ( \"https://offline_location/spotlight-web-components.min.js\" ) app = Starlite ( route_handlers = [ ... ], openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , openapi_controller = MyOpenAPIController ), )","title":"CDN and offline file support"},{"location":"usage/12-openapi/4-viewing-and-accessing-schema/","text":"Viewing and Accessing Schema Starlite comes with multiple integrations for documentation site generators. You can view and download your schema using the endpoints exposed by the OpenAPIController . For example, if you are running your app locally on 0.0.0.0:8000 , you would be able to: view your documentation in a Redoc site under http://0.0.0.0:8000/schema/redoc . view your documentation in a SwaggerUI site under http://0.0.0.0:8000/schema/swagger . view your documentation in a StopLight Elements site under http://0.0.0.0:8000/schema/elements . download your documentation as YAML using http://0.0.0.0:8000/schema/openapi.yaml . download your documentation as JSON using http://0.0.0.0:8000/schema/openapi.json . Accessing the OpenAPI Schema in Code The OpenAPI schema is generated during the Starlite app's init method. Once init is finished, its accessible as app.openapi_schema . As such you can always access it inside route handlers, dependencies etc. by access the request instance: from starlite import Request , get @get ( path = \"/\" ) def my_route_handler ( request : Request ) -> dict : schema = request . app . openapi_schema return schema . dict ()","title":"Viewing and Accessing Schema"},{"location":"usage/12-openapi/4-viewing-and-accessing-schema/#viewing-and-accessing-schema","text":"Starlite comes with multiple integrations for documentation site generators. You can view and download your schema using the endpoints exposed by the OpenAPIController . For example, if you are running your app locally on 0.0.0.0:8000 , you would be able to: view your documentation in a Redoc site under http://0.0.0.0:8000/schema/redoc . view your documentation in a SwaggerUI site under http://0.0.0.0:8000/schema/swagger . view your documentation in a StopLight Elements site under http://0.0.0.0:8000/schema/elements . download your documentation as YAML using http://0.0.0.0:8000/schema/openapi.yaml . download your documentation as JSON using http://0.0.0.0:8000/schema/openapi.json .","title":"Viewing and Accessing Schema"},{"location":"usage/12-openapi/4-viewing-and-accessing-schema/#accessing-the-openapi-schema-in-code","text":"The OpenAPI schema is generated during the Starlite app's init method. Once init is finished, its accessible as app.openapi_schema . As such you can always access it inside route handlers, dependencies etc. by access the request instance: from starlite import Request , get @get ( path = \"/\" ) def my_route_handler ( request : Request ) -> dict : schema = request . app . openapi_schema return schema . dict ()","title":"Accessing the OpenAPI Schema in Code"},{"location":"usage/12-openapi/5-customizing-pydantic-model-schemas/","text":"Customizing Pydantic Model Schemas You can customize the OpenAPI schemas generated for pydantic models by following the guidelines in the pydantic docs . Additionally, you can affect how pydantic models are translated into OpenAPI components by settings a special dunder attribute on the model called __schema_name__ : Customize Components Example from uuid import UUID , uuid4 from pydantic import BaseModel from starlite import Starlite , get class IdModel ( BaseModel ): __schema_name__ = \"IdContainer\" id : UUID @get ( \"/id\" ) def retrieve_id_handler () -> IdModel : \"\"\" Returns: An IdModel \"\"\" return IdModel ( id = uuid4 ()) app = Starlite ( route_handlers = [ retrieve_id_handler ]) The above will result in an OpenAPI schema object that looks like this: { \"openapi\" : \"3.1.0\" , \"info\" : { \"title\" : \"Starlite API\" , \"version\" : \"1.0.0\" }, \"servers\" : [{ \"url\" : \"/\" }], \"paths\" : { \"/id\" : { \"get\" : { \"operationId\" : \"Retrieve Id Handler\" , \"responses\" : { \"200\" : { \"description\" : \"Request fulfilled, document follows\" , \"headers\" : {}, \"content\" : { \"application/json\" : { \"media_type_schema\" : { \"ref\" : \"#/components/schemas/IdContainer\" } } }, } }, \"deprecated\" : False , } } }, \"components\" : { \"schemas\" : { \"IdContainer\" : { \"properties\" : { \"id\" : { \"type\" : \"string\" , \"schema_format\" : \"uuid\" , \"title\" : \"Id\" } }, \"type\" : \"object\" , \"required\" : [ \"id\" ], \"title\" : \"IdContainer\" , } } }, } Important If you use multiple pydantic models that use the same name in the schema, you will need to use the __schema_name__ dunder to ensure each has a unique name in the schema, otherwise the schema components will be ambivalent.","title":"Customizing Pydantic Model Schemas"},{"location":"usage/12-openapi/5-customizing-pydantic-model-schemas/#customizing-pydantic-model-schemas","text":"You can customize the OpenAPI schemas generated for pydantic models by following the guidelines in the pydantic docs . Additionally, you can affect how pydantic models are translated into OpenAPI components by settings a special dunder attribute on the model called __schema_name__ : Customize Components Example from uuid import UUID , uuid4 from pydantic import BaseModel from starlite import Starlite , get class IdModel ( BaseModel ): __schema_name__ = \"IdContainer\" id : UUID @get ( \"/id\" ) def retrieve_id_handler () -> IdModel : \"\"\" Returns: An IdModel \"\"\" return IdModel ( id = uuid4 ()) app = Starlite ( route_handlers = [ retrieve_id_handler ]) The above will result in an OpenAPI schema object that looks like this: { \"openapi\" : \"3.1.0\" , \"info\" : { \"title\" : \"Starlite API\" , \"version\" : \"1.0.0\" }, \"servers\" : [{ \"url\" : \"/\" }], \"paths\" : { \"/id\" : { \"get\" : { \"operationId\" : \"Retrieve Id Handler\" , \"responses\" : { \"200\" : { \"description\" : \"Request fulfilled, document follows\" , \"headers\" : {}, \"content\" : { \"application/json\" : { \"media_type_schema\" : { \"ref\" : \"#/components/schemas/IdContainer\" } } }, } }, \"deprecated\" : False , } } }, \"components\" : { \"schemas\" : { \"IdContainer\" : { \"properties\" : { \"id\" : { \"type\" : \"string\" , \"schema_format\" : \"uuid\" , \"title\" : \"Id\" } }, \"type\" : \"object\" , \"required\" : [ \"id\" ], \"title\" : \"IdContainer\" , } } }, } Important If you use multiple pydantic models that use the same name in the schema, you will need to use the __schema_name__ dunder to ensure each has a unique name in the schema, otherwise the schema components will be ambivalent.","title":"Customizing Pydantic Model Schemas"},{"location":"usage/15-caching/0-cache-backends/","text":"Cache Backends Starlite includes a builtin Cache that offers a uniform interface to interact with different \"Cache Backends\". A Cache Backend is a class that either implements or fulfills the interface specified by CacheBackendProtocol to provide cache services. Builtin Cache Backends Starlite comes with the following builtin cache backends: By default, Starlite uses the SimpleCacheBackend , which stores values in local memory with the added security of async locks. This is fine for local development, but it's not a good solution for production environments. Starlite also ships with two other ready to use cache backends: RedisCacheBackend , which uses Redis as the caching database. Under the hood it uses redis-py asyncio to make sure requests are not blocked and hiredis to boost performance. Note redis is a required dependency when using this backend. You can install it as an extra with pip install starlite[redis] or independently. MemcachedCacheBackend , which uses memcached as the caching database. Under the hood it uses aiomcache to make sure requests are not blocked. Note memcached is a required dependency when using this backend. You can install it as an extra with pip install starlite[memcached] or independently. Configuring Caching You can configure caching behaviour on the application level by passing an instance of CacheConfig to the Starlite constructor . See the API Reference for full details on the CacheConfig class and the kwargs it accepts. Here is an example of how to configure Redis as the cache backend: from starlite import CacheConfig from starlite.cache.redis_cache_backend import ( RedisCacheBackendConfig , RedisCacheBackend , ) config = RedisCacheBackendConfig ( url = \"redis://localhost/\" , port = 6379 , db = 0 ) redis_backend = RedisCacheBackend ( config = config ) cache_config = CacheConfig ( backend = redis_backend ) Or using Memcached: from starlite import CacheConfig from starlite.cache.memcached_cache_backend import ( MemcachedCacheBackendConfig , MemcachedCacheBackend , ) config = MemcachedCacheBackendConfig ( url = \"127.0.0.1\" , port = 11211 ) memcached_backend = MemcachedCacheBackend ( config = config ) cache_config = CacheConfig ( backend = memcached_backend ) Creating a Custom Cache Backend Since Starlite relies on the CacheBackendProtocol to define cache, creating a custom cache backend is very simple - all that is required is to create a class that inherits from the protocol and implements all its methods, or even a class that simply implements these methods without inheriting from the protocol. Once this is done, you can use the backend in the cache config.","title":"Cache Backends"},{"location":"usage/15-caching/0-cache-backends/#cache-backends","text":"Starlite includes a builtin Cache that offers a uniform interface to interact with different \"Cache Backends\". A Cache Backend is a class that either implements or fulfills the interface specified by CacheBackendProtocol to provide cache services.","title":"Cache Backends"},{"location":"usage/15-caching/0-cache-backends/#builtin-cache-backends","text":"Starlite comes with the following builtin cache backends: By default, Starlite uses the SimpleCacheBackend , which stores values in local memory with the added security of async locks. This is fine for local development, but it's not a good solution for production environments. Starlite also ships with two other ready to use cache backends: RedisCacheBackend , which uses Redis as the caching database. Under the hood it uses redis-py asyncio to make sure requests are not blocked and hiredis to boost performance. Note redis is a required dependency when using this backend. You can install it as an extra with pip install starlite[redis] or independently. MemcachedCacheBackend , which uses memcached as the caching database. Under the hood it uses aiomcache to make sure requests are not blocked. Note memcached is a required dependency when using this backend. You can install it as an extra with pip install starlite[memcached] or independently.","title":"Builtin Cache Backends"},{"location":"usage/15-caching/0-cache-backends/#configuring-caching","text":"You can configure caching behaviour on the application level by passing an instance of CacheConfig to the Starlite constructor . See the API Reference for full details on the CacheConfig class and the kwargs it accepts. Here is an example of how to configure Redis as the cache backend: from starlite import CacheConfig from starlite.cache.redis_cache_backend import ( RedisCacheBackendConfig , RedisCacheBackend , ) config = RedisCacheBackendConfig ( url = \"redis://localhost/\" , port = 6379 , db = 0 ) redis_backend = RedisCacheBackend ( config = config ) cache_config = CacheConfig ( backend = redis_backend ) Or using Memcached: from starlite import CacheConfig from starlite.cache.memcached_cache_backend import ( MemcachedCacheBackendConfig , MemcachedCacheBackend , ) config = MemcachedCacheBackendConfig ( url = \"127.0.0.1\" , port = 11211 ) memcached_backend = MemcachedCacheBackend ( config = config ) cache_config = CacheConfig ( backend = memcached_backend )","title":"Configuring Caching"},{"location":"usage/15-caching/0-cache-backends/#creating-a-custom-cache-backend","text":"Since Starlite relies on the CacheBackendProtocol to define cache, creating a custom cache backend is very simple - all that is required is to create a class that inherits from the protocol and implements all its methods, or even a class that simply implements these methods without inheriting from the protocol. Once this is done, you can use the backend in the cache config.","title":"Creating a Custom Cache Backend"},{"location":"usage/15-caching/1-response-caching/","text":"Response Caching Sometimes it's desirable to cache some responses, especially if these involve expensive calculations, or when polling is expected. Starlite comes with a simple mechanism for caching: from starlite import get @get ( \"/cached-path\" , cache = True ) def my_cached_handler () -> str : ... By setting cache=True in the route handler, caching for the route handler will be enabled for the default duration, which is 60 seconds unless modified. Alternatively you can specify the number of seconds to cache the responses from the given handler like so: from starlite import get @get ( \"/cached-path\" , cache = 120 ) # seconds def my_cached_handler () -> str : ... Specifying a Cache Key Builder Starlite uses the request's path + sorted query parameters as the cache key. You can provide a \"Key Builder\" function to the route handler if you want to generate different cache keys: from starlite import Request , get def my_custom_key_builder ( request : Request ) -> str : return request . url . path + request . headers . get ( \"my-header\" , \"\" ) @get ( \"/cached-path\" , cache = True , cache_key_builder = my_custom_key_builder ) def my_cached_handler () -> str : ... You can also specify the default cache key builder to use for the entire application (see below).","title":"Response Caching"},{"location":"usage/15-caching/1-response-caching/#response-caching","text":"Sometimes it's desirable to cache some responses, especially if these involve expensive calculations, or when polling is expected. Starlite comes with a simple mechanism for caching: from starlite import get @get ( \"/cached-path\" , cache = True ) def my_cached_handler () -> str : ... By setting cache=True in the route handler, caching for the route handler will be enabled for the default duration, which is 60 seconds unless modified. Alternatively you can specify the number of seconds to cache the responses from the given handler like so: from starlite import get @get ( \"/cached-path\" , cache = 120 ) # seconds def my_cached_handler () -> str : ...","title":"Response Caching"},{"location":"usage/15-caching/1-response-caching/#specifying-a-cache-key-builder","text":"Starlite uses the request's path + sorted query parameters as the cache key. You can provide a \"Key Builder\" function to the route handler if you want to generate different cache keys: from starlite import Request , get def my_custom_key_builder ( request : Request ) -> str : return request . url . path + request . headers . get ( \"my-header\" , \"\" ) @get ( \"/cached-path\" , cache = True , cache_key_builder = my_custom_key_builder ) def my_cached_handler () -> str : ... You can also specify the default cache key builder to use for the entire application (see below).","title":"Specifying a Cache Key Builder"},{"location":"usage/15-caching/2-interacting-with-cache/","text":"Interacting with the Cache The Starlite app's cache is exposed as app.cache , which makes it accessible via the scope object. For example, you can access the cache in a custom middleware thus: from starlite import MiddlewareProtocol from starlite.types import Scope , Receive , Send , ASGIApp class MyMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ): self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : cached_value = await scope [ \"app\" ] . cache . get ( \"my-key\" ) if cached_value : ... The cache is also exposed as a property on the ASGIConnection and the Request and WebSocket classes that inherit from it. You can thus interact with the cache inside a route handler easily, for example by doing this: from starlite import Request , get @get ( \"/\" ) async def my_handler ( request : Request ) -> None : cached_value = await request . cache . get ( \"my-key\" ) if cached_value : ... Important Cache based operations are async because async locking is used to protect against race conditions. If you need to use caching - use an async route handler.","title":"Interacting with the Cache"},{"location":"usage/15-caching/2-interacting-with-cache/#interacting-with-the-cache","text":"The Starlite app's cache is exposed as app.cache , which makes it accessible via the scope object. For example, you can access the cache in a custom middleware thus: from starlite import MiddlewareProtocol from starlite.types import Scope , Receive , Send , ASGIApp class MyMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ): self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : cached_value = await scope [ \"app\" ] . cache . get ( \"my-key\" ) if cached_value : ... The cache is also exposed as a property on the ASGIConnection and the Request and WebSocket classes that inherit from it. You can thus interact with the cache inside a route handler easily, for example by doing this: from starlite import Request , get @get ( \"/\" ) async def my_handler ( request : Request ) -> None : cached_value = await request . cache . get ( \"my-key\" ) if cached_value : ... Important Cache based operations are async because async locking is used to protect against race conditions. If you need to use caching - use an async route handler.","title":"Interacting with the Cache"},{"location":"usage/16-templating/0-template-engines/","text":"Template Engines Starlite has built-in support for both Jinja2 and Mako as template engines, and it also offers a simple way to add additional template engines. Registering a Template Engine To register one of the built-in template engines you simply need to pass it to the Starlite constructor: from starlite import TemplateConfig , Starlite from starlite.contrib.jinja import JinjaTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine ), ) Or from starlite import TemplateConfig , Starlite from starlite.contrib.mako import MakoTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = MakoTemplateEngine ), ) The kwarg directory passed to TemplateConfig is either a directory or list of directories to use for loading templates. Template Responses Once you have a template engine registered you can use it in route handlers: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) The name kwarg passed to the Template class is the filename for the given template. Starlite will search all the directories specifies for this file until it finds it or a TemplateNotFoundException exception will be raised. The context kwarg is a dictionary specifying context data that is passed to the engine. Defining a Custom Template Engine If you wish to use another templating engine, you can easily do so by implementing TemplateEngineProtocol . This class accepts a generic argument T which should be the template class, and it specifies two methods: Python 3.8+ Python 3.9+ Python 3.10+ from typing import Protocol , Union , List from pydantic import DirectoryPath # the template class of the respective library from some_lib import SomeTemplate class TemplateEngineProtocol ( Protocol [ SomeTemplate ]): def __init__ ( self , directory : Union [ DirectoryPath , List [ DirectoryPath ]]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , template_name : str ) -> SomeTemplate : \"\"\"Loads the template with template_name and returns it.\"\"\" ... from typing import Protocol , Union from pydantic import DirectoryPath # the template class of the respective library from some_lib import SomeTemplate class TemplateEngineProtocol ( Protocol [ SomeTemplate ]): def __init__ ( self , directory : Union [ DirectoryPath , list [ DirectoryPath ]]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , template_name : str ) -> SomeTemplate : \"\"\"Loads the template with template_name and returns it.\"\"\" ... from typing import Protocol from pydantic import DirectoryPath # the template class of the respective library from some_lib import SomeTemplate class TemplateEngineProtocol ( Protocol [ SomeTemplate ]): def __init__ ( self , directory : DirectoryPath | list [ DirectoryPath ]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , template_name : str ) -> SomeTemplate : \"\"\"Loads the template with template_name and returns it.\"\"\" ... Once you have your custom engine you can register it as you would the built-in engines. Modifying the Template Engine Instance TemplateConfig accepts the engine_callback keyword arg which provides a way to modify the instantiated template engine instance. For example: from starlite import TemplateConfig from starlite.contrib.jinja import JinjaTemplateEngine def engine_callback ( jinja_engine : JinjaTemplateEngine ) -> JinjaTemplateEngine : jinja_engine . engine . globals [ \"key\" ] = \"value\" return jinja_engine template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine , engine_callback = engine_callback ) The callback should receive a single argument which will be the instantiated engine, and must return the instantiated engine.","title":"Template Engines"},{"location":"usage/16-templating/0-template-engines/#template-engines","text":"Starlite has built-in support for both Jinja2 and Mako as template engines, and it also offers a simple way to add additional template engines.","title":"Template Engines"},{"location":"usage/16-templating/0-template-engines/#registering-a-template-engine","text":"To register one of the built-in template engines you simply need to pass it to the Starlite constructor: from starlite import TemplateConfig , Starlite from starlite.contrib.jinja import JinjaTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine ), ) Or from starlite import TemplateConfig , Starlite from starlite.contrib.mako import MakoTemplateEngine app = Starlite ( route_handlers = [ ... ], template_config = TemplateConfig ( directory = \"templates\" , engine = MakoTemplateEngine ), ) The kwarg directory passed to TemplateConfig is either a directory or list of directories to use for loading templates.","title":"Registering a Template Engine"},{"location":"usage/16-templating/0-template-engines/#template-responses","text":"Once you have a template engine registered you can use it in route handlers: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) The name kwarg passed to the Template class is the filename for the given template. Starlite will search all the directories specifies for this file until it finds it or a TemplateNotFoundException exception will be raised. The context kwarg is a dictionary specifying context data that is passed to the engine.","title":"Template Responses"},{"location":"usage/16-templating/0-template-engines/#defining-a-custom-template-engine","text":"If you wish to use another templating engine, you can easily do so by implementing TemplateEngineProtocol . This class accepts a generic argument T which should be the template class, and it specifies two methods: Python 3.8+ Python 3.9+ Python 3.10+ from typing import Protocol , Union , List from pydantic import DirectoryPath # the template class of the respective library from some_lib import SomeTemplate class TemplateEngineProtocol ( Protocol [ SomeTemplate ]): def __init__ ( self , directory : Union [ DirectoryPath , List [ DirectoryPath ]]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , template_name : str ) -> SomeTemplate : \"\"\"Loads the template with template_name and returns it.\"\"\" ... from typing import Protocol , Union from pydantic import DirectoryPath # the template class of the respective library from some_lib import SomeTemplate class TemplateEngineProtocol ( Protocol [ SomeTemplate ]): def __init__ ( self , directory : Union [ DirectoryPath , list [ DirectoryPath ]]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , template_name : str ) -> SomeTemplate : \"\"\"Loads the template with template_name and returns it.\"\"\" ... from typing import Protocol from pydantic import DirectoryPath # the template class of the respective library from some_lib import SomeTemplate class TemplateEngineProtocol ( Protocol [ SomeTemplate ]): def __init__ ( self , directory : DirectoryPath | list [ DirectoryPath ]) -> None : \"\"\"Builds a template engine.\"\"\" ... def get_template ( self , template_name : str ) -> SomeTemplate : \"\"\"Loads the template with template_name and returns it.\"\"\" ... Once you have your custom engine you can register it as you would the built-in engines.","title":"Defining a Custom Template Engine"},{"location":"usage/16-templating/0-template-engines/#modifying-the-template-engine-instance","text":"TemplateConfig accepts the engine_callback keyword arg which provides a way to modify the instantiated template engine instance. For example: from starlite import TemplateConfig from starlite.contrib.jinja import JinjaTemplateEngine def engine_callback ( jinja_engine : JinjaTemplateEngine ) -> JinjaTemplateEngine : jinja_engine . engine . globals [ \"key\" ] = \"value\" return jinja_engine template_config = TemplateConfig ( directory = \"templates\" , engine = JinjaTemplateEngine , engine_callback = engine_callback ) The callback should receive a single argument which will be the instantiated engine, and must return the instantiated engine.","title":"Modifying the Template Engine Instance"},{"location":"usage/16-templating/1-template-context/","text":"Template Context Both Jinja2 and Mako support passing a context object to the template as well as defining callables that will be available inside the template. Access the request instance through context Starlite injects the current request instance into the template context under request key, which enables accessing the request and through it the app etc. For example, lets assume there is some value stored on the app.state.some_key , we could thus inject it into a Jinja template by doing something like this: < html > < body > < div > < span > My state value: {{request.app.state.some_key}} </ span > </ div > </ body > </ html > Or using a Mako: < html > < body > < div > < span > My state value: ${request.app.state.some_key} </ span > </ div > </ body > </ html > Adding CSRF Inputs Similar to other frameworks such as Django or Laravel, Starlite offers an easy way to add a hidden <input> element to a html form that contains a CSRF token. To use this functionality, you should first configure CSRF protection for the application. With that in place, you can now insert the CSRF input field inside an HTML form: < html > < body > < div > < form action = \"https://myserverurl.com/some-endpoint\" method = \"post\" > {{csrf_input}} < label for = \"fname\" > First name: </ label >< br > < input type = \"text\" id = \"fname\" name = \"fname\" > < label for = \"lname\" > Last name: </ label >< br > < input type = \"text\" id = \"lname\" name = \"lname\" > </ form > </ div > </ body > </ html > Or using the Mako syntax: < html > < body > < div > < form action = \"https://myserverurl.com/some-endpoint\" method = \"post\" > ${csrf_input} < label for = \"fname\" > First name: </ label >< br > < input type = \"text\" id = \"fname\" name = \"fname\" > < label for = \"lname\" > Last name: </ label >< br > < input type = \"text\" id = \"lname\" name = \"lname\" > </ form > </ div > </ body > </ html > The input is hidden so users cannot see and interact with it. It will though be sent back to the server when submitted, and the CSRF middleware will check that the token is valid. Passing Template Context Passing context to the template is very simple - its one of the kwargs expected by the Template container, so simply pass a string keyed dictionary of values: from starlite import Template , get @get ( path = \"/info\" ) def info () -> Template : return Template ( name = \"info.html\" , context = { \"numbers\" : \"1234567890\" })","title":"Template Context"},{"location":"usage/16-templating/1-template-context/#template-context","text":"Both Jinja2 and Mako support passing a context object to the template as well as defining callables that will be available inside the template.","title":"Template Context"},{"location":"usage/16-templating/1-template-context/#access-the-request-instance-through-context","text":"Starlite injects the current request instance into the template context under request key, which enables accessing the request and through it the app etc. For example, lets assume there is some value stored on the app.state.some_key , we could thus inject it into a Jinja template by doing something like this: < html > < body > < div > < span > My state value: {{request.app.state.some_key}} </ span > </ div > </ body > </ html > Or using a Mako: < html > < body > < div > < span > My state value: ${request.app.state.some_key} </ span > </ div > </ body > </ html >","title":"Access the request instance through context"},{"location":"usage/16-templating/1-template-context/#adding-csrf-inputs","text":"Similar to other frameworks such as Django or Laravel, Starlite offers an easy way to add a hidden <input> element to a html form that contains a CSRF token. To use this functionality, you should first configure CSRF protection for the application. With that in place, you can now insert the CSRF input field inside an HTML form: < html > < body > < div > < form action = \"https://myserverurl.com/some-endpoint\" method = \"post\" > {{csrf_input}} < label for = \"fname\" > First name: </ label >< br > < input type = \"text\" id = \"fname\" name = \"fname\" > < label for = \"lname\" > Last name: </ label >< br > < input type = \"text\" id = \"lname\" name = \"lname\" > </ form > </ div > </ body > </ html > Or using the Mako syntax: < html > < body > < div > < form action = \"https://myserverurl.com/some-endpoint\" method = \"post\" > ${csrf_input} < label for = \"fname\" > First name: </ label >< br > < input type = \"text\" id = \"fname\" name = \"fname\" > < label for = \"lname\" > Last name: </ label >< br > < input type = \"text\" id = \"lname\" name = \"lname\" > </ form > </ div > </ body > </ html > The input is hidden so users cannot see and interact with it. It will though be sent back to the server when submitted, and the CSRF middleware will check that the token is valid.","title":"Adding CSRF Inputs"},{"location":"usage/16-templating/1-template-context/#passing-template-context","text":"Passing context to the template is very simple - its one of the kwargs expected by the Template container, so simply pass a string keyed dictionary of values: from starlite import Template , get @get ( path = \"/info\" ) def info () -> Template : return Template ( name = \"info.html\" , context = { \"numbers\" : \"1234567890\" })","title":"Passing Template Context"},{"location":"usage/16-templating/2-template-functions/","text":"Template Callables Both Jinja2 and Mako allow users to define custom callables that are ran inside the template. Starlite builds on this and offers some functions out of the box. url_for To access urls for route handlers you can use the url_for function. Its signature and behaviour matches route_reverse behaviour. More details about route handler indexing can be found here csrf_token This function returns the request's unique csrf_token . You can use this if you wish to insert the csrf_token into non-HTML based templates, or insert it into HTML templates not using a hidden input field but by some other means, for example inside a special <meta> tag. url_for_static_asset URLs for static files can be created using the url_for_static_asset function. It's signature and behaviour are identical to app.url_for_static_asset . Registering Template Callables The Starlite TemplateEngineProtocol specifies the method register_template_callable that allows defining a custom callable on a template engine. This method is implemented for the two built in engines, and it can be used to register callables that will be injected into the template. The callable should expect one argument - the context dictionary. It can be any callable - a function, method or class that defines the call method. For example: Python 3.8+ Python 3.9+ template_functions.py from pathlib import Path from typing import Dict from starlite import Starlite , Template , TemplateConfig , get from starlite.contrib.jinja import JinjaTemplateEngine def my_template_function ( ctx : Dict ) -> str : return ctx . get ( \"my_context_key\" , \"nope\" ) def register_template_callables ( engine : JinjaTemplateEngine ) -> None : engine . register_template_callable ( key = \"check_context_key\" , template_callable = my_template_function , ) template_path = Path ( __file__ ) . parent / \"templates\" template_config = TemplateConfig ( directory = template_path , engine = JinjaTemplateEngine , engine_callback = register_template_callables , ) @get ( \"/\" ) def index () -> Template : return Template ( name = \"index.html.jinja2\" ) app = Starlite ( route_handlers = [ index ], template_config = template_config , ) template_functions.py from pathlib import Path from starlite import Starlite , Template , TemplateConfig , get from starlite.contrib.jinja import JinjaTemplateEngine def my_template_function ( ctx : dict ) -> str : return ctx . get ( \"my_context_key\" , \"nope\" ) def register_template_callables ( engine : JinjaTemplateEngine ) -> None : engine . register_template_callable ( key = \"check_context_key\" , template_callable = my_template_function , ) template_path = Path ( __file__ ) . parent / \"templates\" template_config = TemplateConfig ( directory = template_path , engine = JinjaTemplateEngine , engine_callback = register_template_callables , ) @get ( \"/\" ) def index () -> Template : return Template ( name = \"index.html.jinja2\" ) app = Starlite ( route_handlers = [ index ], template_config = template_config , ) templates/index.html.jinja2 < strong > check_context_key: </ strong > {{ check_context_key() }} Run the example with uvicorn template_functions:app , visit http://127.0.0.1:8000 , and you'll see","title":"Template Callables"},{"location":"usage/16-templating/2-template-functions/#template-callables","text":"Both Jinja2 and Mako allow users to define custom callables that are ran inside the template. Starlite builds on this and offers some functions out of the box. url_for To access urls for route handlers you can use the url_for function. Its signature and behaviour matches route_reverse behaviour. More details about route handler indexing can be found here csrf_token This function returns the request's unique csrf_token . You can use this if you wish to insert the csrf_token into non-HTML based templates, or insert it into HTML templates not using a hidden input field but by some other means, for example inside a special <meta> tag. url_for_static_asset URLs for static files can be created using the url_for_static_asset function. It's signature and behaviour are identical to app.url_for_static_asset .","title":"Template Callables"},{"location":"usage/16-templating/2-template-functions/#registering-template-callables","text":"The Starlite TemplateEngineProtocol specifies the method register_template_callable that allows defining a custom callable on a template engine. This method is implemented for the two built in engines, and it can be used to register callables that will be injected into the template. The callable should expect one argument - the context dictionary. It can be any callable - a function, method or class that defines the call method. For example: Python 3.8+ Python 3.9+ template_functions.py from pathlib import Path from typing import Dict from starlite import Starlite , Template , TemplateConfig , get from starlite.contrib.jinja import JinjaTemplateEngine def my_template_function ( ctx : Dict ) -> str : return ctx . get ( \"my_context_key\" , \"nope\" ) def register_template_callables ( engine : JinjaTemplateEngine ) -> None : engine . register_template_callable ( key = \"check_context_key\" , template_callable = my_template_function , ) template_path = Path ( __file__ ) . parent / \"templates\" template_config = TemplateConfig ( directory = template_path , engine = JinjaTemplateEngine , engine_callback = register_template_callables , ) @get ( \"/\" ) def index () -> Template : return Template ( name = \"index.html.jinja2\" ) app = Starlite ( route_handlers = [ index ], template_config = template_config , ) template_functions.py from pathlib import Path from starlite import Starlite , Template , TemplateConfig , get from starlite.contrib.jinja import JinjaTemplateEngine def my_template_function ( ctx : dict ) -> str : return ctx . get ( \"my_context_key\" , \"nope\" ) def register_template_callables ( engine : JinjaTemplateEngine ) -> None : engine . register_template_callable ( key = \"check_context_key\" , template_callable = my_template_function , ) template_path = Path ( __file__ ) . parent / \"templates\" template_config = TemplateConfig ( directory = template_path , engine = JinjaTemplateEngine , engine_callback = register_template_callables , ) @get ( \"/\" ) def index () -> Template : return Template ( name = \"index.html.jinja2\" ) app = Starlite ( route_handlers = [ index ], template_config = template_config , ) templates/index.html.jinja2 < strong > check_context_key: </ strong > {{ check_context_key() }} Run the example with uvicorn template_functions:app , visit http://127.0.0.1:8000 , and you'll see","title":"Registering Template Callables"},{"location":"usage/18-contrib/0-open-telemetry/","text":"Open Telemetry Instrumentation Starlite includes optional OpenTelemetry instrumentation that is exported from starlite.contrib.opentelemtry . To use this package, you should first install the required dependencies: as separate packages pip install opentelemetry-instrumentation-asgi Or by installing Starlite with the opentelemetry extra: as 'extra' dependencies pip install starlite [ opentelemetry ] Once these requirements are satisfied, you can instrument your Starlite application by creating an instance of OpenTelemetryConfig and passing the middleware it creates to the Starlite constructor: from starlite import Starlite from starlite.contrib.opentelemetry import OpenTelemetryConfig open_telemetry_config = OpenTelemetryConfig () app = Starlite ( route_handlers = [], middleware = [ open_telemetry_config . middleware ]) The above example will work out of the box if you configure a global tracer_provider and/or metric_provider and an exporter to use these (see the OpenTelemetry Exporter docs for further details). You can also pass con figuration to the OpenTelemetryConfig telling it which providers to use. Consult reference docs regarding the configuration options you can use.","title":"Open Telemetry Instrumentation"},{"location":"usage/18-contrib/0-open-telemetry/#open-telemetry-instrumentation","text":"Starlite includes optional OpenTelemetry instrumentation that is exported from starlite.contrib.opentelemtry . To use this package, you should first install the required dependencies: as separate packages pip install opentelemetry-instrumentation-asgi Or by installing Starlite with the opentelemetry extra: as 'extra' dependencies pip install starlite [ opentelemetry ] Once these requirements are satisfied, you can instrument your Starlite application by creating an instance of OpenTelemetryConfig and passing the middleware it creates to the Starlite constructor: from starlite import Starlite from starlite.contrib.opentelemetry import OpenTelemetryConfig open_telemetry_config = OpenTelemetryConfig () app = Starlite ( route_handlers = [], middleware = [ open_telemetry_config . middleware ]) The above example will work out of the box if you configure a global tracer_provider and/or metric_provider and an exporter to use these (see the OpenTelemetry Exporter docs for further details). You can also pass con figuration to the OpenTelemetryConfig telling it which providers to use. Consult reference docs regarding the configuration options you can use.","title":"Open Telemetry Instrumentation"},{"location":"usage/18-contrib/1-jwt/","text":"JWT Security Backends Starlite offers optional JWT based security backends. To use these make sure to install the python-jose and cryptography packages, or simply install Starlite with the jwt extra: pip install starlite[jwt] . JWT Auth Backend This is the base JWT Auth backend. You can read about its particular API in the API Reference . It sends the JWT token using a header - and it expects requests to send the JWT token using the same header key. Python 3.8+ Python 3.10+ Using JWT Auth from os import environ from typing import Any , Optional from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import JWTAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # JWTAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> Optional [ User ]: # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None jwt_auth = JWTAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], ) # Given an instance of 'JWTAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = jwt_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the jwt_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ jwt_auth . on_app_init ], openapi_config = openapi_config , ) Using JWT Auth from os import environ from typing import Any from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import JWTAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # JWTAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> User | None : # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None jwt_auth = JWTAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], ) # Given an instance of 'JWTAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = jwt_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the jwt_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ jwt_auth . on_app_init ], openapi_config = openapi_config , ) JWT Cookie Auth Backend This backend inherits from the JWTAuth backend, with the difference being that instead of using a header for the JWT Token, it uses a cookie. You can read more about this backend in the API Reference . Python 3.8+ Python 3.10+ Using JWT Cookie Auth from os import environ from typing import Any , Optional from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import JWTCookieAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # JWTCookieAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> Optional [ User ]: # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None jwt_cookie_auth = JWTCookieAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], # Tip: We can optionally supply cookie options to the configuration. Here is an example of enabling the secure cookie option # auth_cookie_options=CookieOptions(secure=True), ) # Given an instance of 'JWTCookieAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = jwt_cookie_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ jwt_cookie_auth . on_app_init ], openapi_config = openapi_config , ) Using JWT Cookie Auth from os import environ from typing import Any from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import JWTCookieAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # JWTCookieAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> User | None : # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None jwt_cookie_auth = JWTCookieAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], # Tip: We can optionally supply cookie options to the configuration. Here is an example of enabling the secure cookie option # auth_cookie_options=CookieOptions(secure=True), ) # Given an instance of 'JWTCookieAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = jwt_cookie_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ jwt_cookie_auth . on_app_init ], openapi_config = openapi_config , ) OAuth2 Bearer Password Flow This backend inherits from the JWTCookieAuth backend. It works similarly to the JWTCookieAuth backend, but is meant to be used for OAUTH2 Bearer password flows. Python 3.8+ Python 3.10+ Using OAUTH2 Bearer Password from os import environ from typing import Any , Optional from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import OAuth2PasswordBearerAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # OAuth2PasswordBearerAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> Optional [ User ]: # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None oauth2_auth = OAuth2PasswordBearerAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying the URL for retrieving a JWT access token token_url = \"/login\" , # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], ) # Given an instance of 'OAuth2PasswordBearerAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = oauth2_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the oauth2_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ oauth2_auth . on_app_init ], openapi_config = openapi_config , ) Using OAUTH2 Bearer Password from os import environ from typing import Any from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import OAuth2PasswordBearerAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # OAuth2PasswordBearerAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> User | None : # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None oauth2_auth = OAuth2PasswordBearerAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying the URL for retrieving a JWT access token token_url = \"/login\" , # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], ) # Given an instance of 'OAuth2PasswordBearerAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = oauth2_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the oauth2_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ oauth2_auth . on_app_init ], openapi_config = openapi_config , )","title":"JWT Security Backends"},{"location":"usage/18-contrib/1-jwt/#jwt-security-backends","text":"Starlite offers optional JWT based security backends. To use these make sure to install the python-jose and cryptography packages, or simply install Starlite with the jwt extra: pip install starlite[jwt] .","title":"JWT Security Backends"},{"location":"usage/18-contrib/1-jwt/#jwt-auth-backend","text":"This is the base JWT Auth backend. You can read about its particular API in the API Reference . It sends the JWT token using a header - and it expects requests to send the JWT token using the same header key. Python 3.8+ Python 3.10+ Using JWT Auth from os import environ from typing import Any , Optional from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import JWTAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # JWTAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> Optional [ User ]: # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None jwt_auth = JWTAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], ) # Given an instance of 'JWTAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = jwt_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the jwt_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ jwt_auth . on_app_init ], openapi_config = openapi_config , ) Using JWT Auth from os import environ from typing import Any from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import JWTAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # JWTAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> User | None : # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None jwt_auth = JWTAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], ) # Given an instance of 'JWTAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = jwt_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the jwt_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ jwt_auth . on_app_init ], openapi_config = openapi_config , )","title":"JWT Auth Backend"},{"location":"usage/18-contrib/1-jwt/#jwt-cookie-auth-backend","text":"This backend inherits from the JWTAuth backend, with the difference being that instead of using a header for the JWT Token, it uses a cookie. You can read more about this backend in the API Reference . Python 3.8+ Python 3.10+ Using JWT Cookie Auth from os import environ from typing import Any , Optional from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import JWTCookieAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # JWTCookieAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> Optional [ User ]: # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None jwt_cookie_auth = JWTCookieAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], # Tip: We can optionally supply cookie options to the configuration. Here is an example of enabling the secure cookie option # auth_cookie_options=CookieOptions(secure=True), ) # Given an instance of 'JWTCookieAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = jwt_cookie_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ jwt_cookie_auth . on_app_init ], openapi_config = openapi_config , ) Using JWT Cookie Auth from os import environ from typing import Any from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import JWTCookieAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # JWTCookieAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> User | None : # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None jwt_cookie_auth = JWTCookieAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], # Tip: We can optionally supply cookie options to the configuration. Here is an example of enabling the secure cookie option # auth_cookie_options=CookieOptions(secure=True), ) # Given an instance of 'JWTCookieAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = jwt_cookie_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the jwt_cookie_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ jwt_cookie_auth . on_app_init ], openapi_config = openapi_config , )","title":"JWT Cookie Auth Backend"},{"location":"usage/18-contrib/1-jwt/#oauth2-bearer-password-flow","text":"This backend inherits from the JWTCookieAuth backend. It works similarly to the JWTCookieAuth backend, but is meant to be used for OAUTH2 Bearer password flows. Python 3.8+ Python 3.10+ Using OAUTH2 Bearer Password from os import environ from typing import Any , Optional from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import OAuth2PasswordBearerAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # OAuth2PasswordBearerAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> Optional [ User ]: # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None oauth2_auth = OAuth2PasswordBearerAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying the URL for retrieving a JWT access token token_url = \"/login\" , # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], ) # Given an instance of 'OAuth2PasswordBearerAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = oauth2_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the oauth2_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ oauth2_auth . on_app_init ], openapi_config = openapi_config , ) Using OAUTH2 Bearer Password from os import environ from typing import Any from uuid import UUID from pydantic import BaseModel , EmailStr from starlite import ( ASGIConnection , OpenAPIConfig , Request , Response , Starlite , get , post , ) from starlite.contrib.jwt import OAuth2PasswordBearerAuth , Token # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # OAuth2PasswordBearerAuth requires a retrieve handler callable that receives the JWT token model and the ASGI connection # and returns the 'User' instance correlating to it. # # Notes: # - 'User' can be any arbitrary value you decide upon. # - The callable can be either sync or async - both will work. async def retrieve_user_handler ( token : Token , connection : ASGIConnection [ Any , Any , Any ]) -> User | None : # logic here to retrieve the user instance cached_value = await connection . cache . get ( token . sub ) if cached_value : return User ( ** cached_value ) return None oauth2_auth = OAuth2PasswordBearerAuth [ User ]( retrieve_user_handler = retrieve_user_handler , token_secret = environ . get ( \"JWT_SECRET\" , \"abcd123\" ), # we are specifying the URL for retrieving a JWT access token token_url = \"/login\" , # we are specifying which endpoints should be excluded from authentication. In this case the login endpoint # and our openAPI docs. exclude = [ \"/login\" , \"/schema\" ], ) # Given an instance of 'OAuth2PasswordBearerAuth' we can create a login handler function: @post ( \"/login\" ) async def login_handler ( request : \"Request[Any, Any]\" , data : User ) -> Response [ User ]: await request . cache . set ( str ( data . id ), data . dict ()) response = oauth2_auth . login ( identifier = str ( data . id ), response_body = data ) # you can do whatever you want to update the response instance here # e.g. response.set_cookie(...) return response # We also have some other routes, for example: @get ( \"/some-path\" ) def some_route_handler ( request : Request [ User , Token ]) -> Any : # request.user is set to the instance of user returned by the middleware assert isinstance ( request . user , User ) # request.auth is the instance of 'starlite_jwt.Token' created from the data encoded in the auth header assert isinstance ( request . auth , Token ) # do stuff ... # We create our OpenAPIConfig as usual - the JWT security scheme will be injected into it. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) # We initialize the app instance and pass the oauth2_auth 'on_app_init' handler to the constructor. # The hook handler will inject the JWT middleware and openapi configuration into the app. app = Starlite ( route_handlers = [ login_handler , some_route_handler ], on_app_init = [ oauth2_auth . on_app_init ], openapi_config = openapi_config , )","title":"OAuth2 Bearer Password Flow"},{"location":"usage/2-route-handlers/0-route-handlers-concept/","text":"Route Handlers Route handlers are the core of Starlite. They are constructed by decorating a function or class method with one of the handler decorators exported from Starlite. For example: from starlite import MediaType , get @get ( \"/\" , media_type = MediaType . TEXT ) def greet () -> str : return \"hello world\" In the above example, the decorator includes all the information required to define the endpoint operation for the combination of the path \"/\" and the http verb GET . In this case it will be a http response with a \"Content-Type\" header of text/plain . What the decorator does, is wrap the function or method within a class instance that inherits from BaseRouteHandler . These classes are optimized descriptor classes that record all the data necessary for the given function or method - this includes a modelling of the function signature, which allows for injection of kwargs and dependencies, as well as data pertinent to OpenAPI spec generation. Declaring Path(s) All route handler decorator accept an optional path argument. This argument can be declared as a kwarg using the path key word: from starlite import get @get ( path = \"/some-path\" ) def my_route_handler () -> None : ... It can also be passed as an argument without the key-word: from starlite import get @get ( \"/some-path\" ) def my_route_handler () -> None : ... And the value for this argument can be either a string path, as in the above examples, or a list of string paths: from starlite import get @get ([ \"/some-path\" , \"/some-other-path\" ]) def my_route_handler () -> None : ... This is particularly useful when you want to have optional path parameters : from starlite import get @get ( [ \"/some-path\" , \"/some-path/{some_id:int}\" ], ) def my_route_handler ( some_id : int = 1 ) -> None : ... Handler Function Kwargs Route handler functions or methods access various data by declaring these as annotated function kwargs. The annotated kwargs are inspected by Starlite and then injected into the request handler. The following sources can be accessed using annotated function kwargs: path, query, header and cookie parameters request data dependencies Additionally, you can specify the following special kwargs, what's called \"reserved keywords\" internally: cookies : injects the request cookies as a parsed dictionary. headers : injects the request headers as an instance of Headers , which is a case-insensitive mapping. query : injects the request query_params as a parsed dictionary. request : injects the Request instance. Available only for http route handlers scope : injects the ASGI scope dictionary. socket : injects the WebSocket instance. Available only for websocket handlers state : injects a copy of the application state . For example: Python 3.8+ Python 3.9+ from typing import Any , Dict from starlite import State , Request , get from starlite.datastructures import Headers @get ( path = \"/\" ) def my_request_handler ( state : State , request : Request , headers : Headers , query : Dict [ str , Any ], cookies : Dict [ str , Any ], ) -> None : ... from typing import Any from starlite import State , Request , get from starlite.datastructures import Headers @get ( path = \"/\" ) def my_request_handler ( state : State , request : Request , headers : Headers , query : dict [ str , Any ], cookies : dict [ str , Any ], ) -> None : ... Tip You can define a custom typing for your application state and then use it as a type instead of just using the State class from Starlite Handler Function Type Annotations Starlite enforces strict type annotations. Functions decorated by a route handler must have all their kwargs and return value type annotated. If a type annotation is missing, an ImproperlyConfiguredException will be raised during the application boot-up process. There are several reasons for why this limitation is enforced: to ensure best practices to ensure consistent OpenAPI schema generation to allow Starlite to compute during the application bootstrap all the kwargs required by a function","title":"Route Handlers"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#route-handlers","text":"Route handlers are the core of Starlite. They are constructed by decorating a function or class method with one of the handler decorators exported from Starlite. For example: from starlite import MediaType , get @get ( \"/\" , media_type = MediaType . TEXT ) def greet () -> str : return \"hello world\" In the above example, the decorator includes all the information required to define the endpoint operation for the combination of the path \"/\" and the http verb GET . In this case it will be a http response with a \"Content-Type\" header of text/plain . What the decorator does, is wrap the function or method within a class instance that inherits from BaseRouteHandler . These classes are optimized descriptor classes that record all the data necessary for the given function or method - this includes a modelling of the function signature, which allows for injection of kwargs and dependencies, as well as data pertinent to OpenAPI spec generation.","title":"Route Handlers"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#declaring-paths","text":"All route handler decorator accept an optional path argument. This argument can be declared as a kwarg using the path key word: from starlite import get @get ( path = \"/some-path\" ) def my_route_handler () -> None : ... It can also be passed as an argument without the key-word: from starlite import get @get ( \"/some-path\" ) def my_route_handler () -> None : ... And the value for this argument can be either a string path, as in the above examples, or a list of string paths: from starlite import get @get ([ \"/some-path\" , \"/some-other-path\" ]) def my_route_handler () -> None : ... This is particularly useful when you want to have optional path parameters : from starlite import get @get ( [ \"/some-path\" , \"/some-path/{some_id:int}\" ], ) def my_route_handler ( some_id : int = 1 ) -> None : ...","title":"Declaring Path(s)"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#handler-function-kwargs","text":"Route handler functions or methods access various data by declaring these as annotated function kwargs. The annotated kwargs are inspected by Starlite and then injected into the request handler. The following sources can be accessed using annotated function kwargs: path, query, header and cookie parameters request data dependencies Additionally, you can specify the following special kwargs, what's called \"reserved keywords\" internally: cookies : injects the request cookies as a parsed dictionary. headers : injects the request headers as an instance of Headers , which is a case-insensitive mapping. query : injects the request query_params as a parsed dictionary. request : injects the Request instance. Available only for http route handlers scope : injects the ASGI scope dictionary. socket : injects the WebSocket instance. Available only for websocket handlers state : injects a copy of the application state . For example: Python 3.8+ Python 3.9+ from typing import Any , Dict from starlite import State , Request , get from starlite.datastructures import Headers @get ( path = \"/\" ) def my_request_handler ( state : State , request : Request , headers : Headers , query : Dict [ str , Any ], cookies : Dict [ str , Any ], ) -> None : ... from typing import Any from starlite import State , Request , get from starlite.datastructures import Headers @get ( path = \"/\" ) def my_request_handler ( state : State , request : Request , headers : Headers , query : dict [ str , Any ], cookies : dict [ str , Any ], ) -> None : ... Tip You can define a custom typing for your application state and then use it as a type instead of just using the State class from Starlite","title":"Handler Function Kwargs"},{"location":"usage/2-route-handlers/0-route-handlers-concept/#handler-function-type-annotations","text":"Starlite enforces strict type annotations. Functions decorated by a route handler must have all their kwargs and return value type annotated. If a type annotation is missing, an ImproperlyConfiguredException will be raised during the application boot-up process. There are several reasons for why this limitation is enforced: to ensure best practices to ensure consistent OpenAPI schema generation to allow Starlite to compute during the application bootstrap all the kwargs required by a function","title":"Handler Function Type Annotations"},{"location":"usage/2-route-handlers/1-http-route-handlers/","text":"HTTP Route Handlers The most commonly used route handlers are those that handle http requests and responses. These route handlers all inherit from the class starlite.handlers.http.HTTPRouteHandler , which is aliased as the decorator called route : from starlite import HttpMethod , route @route ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... As mentioned above, route does is merely an alias for HTTPRouteHandler , thus the below code is equivalent to the one above: from starlite import HttpMethod , HTTPRouteHandler @HTTPRouteHandler ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... HTTP Route Handlers Kwargs The route decorator requires an http_method kwarg, which is a member of the HttpMethod enum or a list of members, e.g. HttpMethod.GET or [HttpMethod.PATCH, HttpMethod.PUT] . See the API Reference for full details on the route decorator and the kwargs it accepts. Semantic Handler Decorators Starlite also includes \"semantic\" decorators, that is, decorators the pre-set the http_method kwarg to a specific HTTP verb, which correlates with their name: delete get head patch post put These are used exactly like route with the sole exception that you cannot configure the http_method kwarg: from starlite import Partial , delete , get , patch , post , put , head from pydantic import BaseModel class Resource ( BaseModel ): ... @get ( path = \"/resources\" ) def list_resources () -> list [ Resource ]: ... @post ( path = \"/resources\" ) def create_resource ( data : Resource ) -> Resource : ... @get ( path = \"/resources/{pk:int}\" ) def retrieve_resource ( pk : int ) -> Resource : ... @head ( path = \"/resources/{pk:int}\" ) def retrieve_resource_head ( pk : int ) -> None : ... @put ( path = \"/resources/{pk:int}\" ) def update_resource ( data : Resource , pk : int ) -> Resource : ... @patch ( path = \"/resources/{pk:int}\" ) def partially_update_resource ( data : Partial [ Resource ], pk : int ) -> Resource : ... @delete ( path = \"/resources/{pk:int}\" ) def delete_resource ( pk : int ) -> None : ... Although these decorators are merely subclasses of starlite.handlers.http.HTTPRouteHandler that pre-set the http_method , using get , patch , put , delete or post instead of route makes the code clearer and simpler. Furthermore, in the OpenAPI specification each unique combination of http verb (e.g. \"GET\", \"POST\" etc.) and path is regarded as a distinct operation , and each operation should be distinguished by a unique operationId and optimally also have a summary and description sections. As such, using the route decorator is discouraged. Instead, the preferred pattern is to share code using secondary class methods or by abstracting code to reusable functions. Using Sync Handler Functions You can use both sync and async functions as the base for route handler functions, but which should you use? and when? If your route handler needs to perform an I/O operation (read or write data from or to a service / db etc.), the most performant solution within the scope of an ASGI application, including Starlite, is going to be by using an async solution for this purpose. The reason for this is that async code, if written correctly, is non-blocking . That is, async code can be paused and resumed, and it therefore does not interrupt the main event loop from executing (if written correctly). On the other hand, sync I/O handling is often blocking , and if you use such code in your function it can create performance issues. In this case you should use the sync_to_thread option. What this does, is tell Starlite to run the sync function in a separate async thread, where it can block but will not interrupt the main event loop's execution. The problem with this though is that this will slow down the execution of your sync code quite dramatically - by between %40-60%. So this is really quite far from performant. Thus, you should use this option only when your sync code performs blocking I/O operations. If your sync code simply performs simple tasks, non-expensive calculations, etc. you should not use the sync_to_thread option.","title":"HTTP Route Handlers"},{"location":"usage/2-route-handlers/1-http-route-handlers/#http-route-handlers","text":"The most commonly used route handlers are those that handle http requests and responses. These route handlers all inherit from the class starlite.handlers.http.HTTPRouteHandler , which is aliased as the decorator called route : from starlite import HttpMethod , route @route ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ... As mentioned above, route does is merely an alias for HTTPRouteHandler , thus the below code is equivalent to the one above: from starlite import HttpMethod , HTTPRouteHandler @HTTPRouteHandler ( path = \"/some-path\" , http_method = [ HttpMethod . GET , HttpMethod . POST ]) def my_endpoint () -> None : ...","title":"HTTP Route Handlers"},{"location":"usage/2-route-handlers/1-http-route-handlers/#http-route-handlers-kwargs","text":"The route decorator requires an http_method kwarg, which is a member of the HttpMethod enum or a list of members, e.g. HttpMethod.GET or [HttpMethod.PATCH, HttpMethod.PUT] . See the API Reference for full details on the route decorator and the kwargs it accepts.","title":"HTTP Route Handlers Kwargs"},{"location":"usage/2-route-handlers/1-http-route-handlers/#semantic-handler-decorators","text":"Starlite also includes \"semantic\" decorators, that is, decorators the pre-set the http_method kwarg to a specific HTTP verb, which correlates with their name: delete get head patch post put These are used exactly like route with the sole exception that you cannot configure the http_method kwarg: from starlite import Partial , delete , get , patch , post , put , head from pydantic import BaseModel class Resource ( BaseModel ): ... @get ( path = \"/resources\" ) def list_resources () -> list [ Resource ]: ... @post ( path = \"/resources\" ) def create_resource ( data : Resource ) -> Resource : ... @get ( path = \"/resources/{pk:int}\" ) def retrieve_resource ( pk : int ) -> Resource : ... @head ( path = \"/resources/{pk:int}\" ) def retrieve_resource_head ( pk : int ) -> None : ... @put ( path = \"/resources/{pk:int}\" ) def update_resource ( data : Resource , pk : int ) -> Resource : ... @patch ( path = \"/resources/{pk:int}\" ) def partially_update_resource ( data : Partial [ Resource ], pk : int ) -> Resource : ... @delete ( path = \"/resources/{pk:int}\" ) def delete_resource ( pk : int ) -> None : ... Although these decorators are merely subclasses of starlite.handlers.http.HTTPRouteHandler that pre-set the http_method , using get , patch , put , delete or post instead of route makes the code clearer and simpler. Furthermore, in the OpenAPI specification each unique combination of http verb (e.g. \"GET\", \"POST\" etc.) and path is regarded as a distinct operation , and each operation should be distinguished by a unique operationId and optimally also have a summary and description sections. As such, using the route decorator is discouraged. Instead, the preferred pattern is to share code using secondary class methods or by abstracting code to reusable functions.","title":"Semantic Handler Decorators"},{"location":"usage/2-route-handlers/1-http-route-handlers/#using-sync-handler-functions","text":"You can use both sync and async functions as the base for route handler functions, but which should you use? and when? If your route handler needs to perform an I/O operation (read or write data from or to a service / db etc.), the most performant solution within the scope of an ASGI application, including Starlite, is going to be by using an async solution for this purpose. The reason for this is that async code, if written correctly, is non-blocking . That is, async code can be paused and resumed, and it therefore does not interrupt the main event loop from executing (if written correctly). On the other hand, sync I/O handling is often blocking , and if you use such code in your function it can create performance issues. In this case you should use the sync_to_thread option. What this does, is tell Starlite to run the sync function in a separate async thread, where it can block but will not interrupt the main event loop's execution. The problem with this though is that this will slow down the execution of your sync code quite dramatically - by between %40-60%. So this is really quite far from performant. Thus, you should use this option only when your sync code performs blocking I/O operations. If your sync code simply performs simple tasks, non-expensive calculations, etc. you should not use the sync_to_thread option.","title":"Using Sync Handler Functions"},{"location":"usage/2-route-handlers/2-websocket-route-handlers/","text":"Websocket Route Handlers Starlite supports Websockets via the websocket decorator: from starlite import WebSocket , websocket @websocket ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () The websocket decorator is an alias of the class WebsocketRouteHandler . Thus, the below code is equivalent to the one above: from starlite import WebSocket , WebsocketRouteHandler @WebsocketRouteHandler ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () In difference to HTTP routes handlers, websocket handlers have the following requirements: they must declare a socket kwarg. they must have a return annotation of None . they must be async functions. These requirements are enforced using inspection, and if any of them is unfulfilled an informative exception will be raised. Note OpenAPI currently does not support websockets. As such no schema will be generated for these route handlers. See the API Reference for full details on the websocket decorator and the kwargs it accepts.","title":"Websocket Route Handlers"},{"location":"usage/2-route-handlers/2-websocket-route-handlers/#websocket-route-handlers","text":"Starlite supports Websockets via the websocket decorator: from starlite import WebSocket , websocket @websocket ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () The websocket decorator is an alias of the class WebsocketRouteHandler . Thus, the below code is equivalent to the one above: from starlite import WebSocket , WebsocketRouteHandler @WebsocketRouteHandler ( path = \"/socket\" ) async def my_websocket_handler ( socket : WebSocket ) -> None : await socket . accept () await socket . send_json ({ ... }) await socket . close () In difference to HTTP routes handlers, websocket handlers have the following requirements: they must declare a socket kwarg. they must have a return annotation of None . they must be async functions. These requirements are enforced using inspection, and if any of them is unfulfilled an informative exception will be raised. Note OpenAPI currently does not support websockets. As such no schema will be generated for these route handlers. See the API Reference for full details on the websocket decorator and the kwargs it accepts.","title":"Websocket Route Handlers"},{"location":"usage/2-route-handlers/3-asgi-route-handlers/","text":"ASGI Route Handlers If you need to write your own ASGI application, you can do so using the asgi decorator: from starlite.types import Scope , Receive , Send from starlite.status_codes import HTTP_400_BAD_REQUEST from starlite import Response , asgi @asgi ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ({ \"hello\" : \"world\" }) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST ) await response ( scope = scope , receive = receive , send = send ) Like other route handlers, the asgi decorator is an alias of the class ASGIRouteHandler . Thus, the code below is equivalent to the one above: from starlite.types import Scope , Receive , Send from starlite.status_codes import HTTP_400_BAD_REQUEST from starlite import ASGIRouteHandler , Response @ASGIRouteHandler ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ({ \"hello\" : \"world\" }) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST ) await response ( scope = scope , receive = receive , send = send ) Limitations of ASGI route handlers In difference to the other route handlers, the asgi route handler accepts only 3 kwargs that must be defined: scope , a mapping of values describing the ASGI connection. It always includes a type key, with the values being either http or websocket , and a path key. If the type is http , the scope dictionary will also include a method key with the value being one of DELETE, GET, POST, PATCH, PUT, HEAD . receive , an injected function by which the ASGI application receives messages. send , an injected function by which the ASGI application sends messages. You can read more about these in the ASGI specification . Additionally, ASGI route handler functions must be async functions. This is enforced using inspection, and if the function is not an async function, an informative exception will be raised. See the API Reference for full details on the asgi decorator and the kwargs it accepts.","title":"ASGI Route Handlers"},{"location":"usage/2-route-handlers/3-asgi-route-handlers/#asgi-route-handlers","text":"If you need to write your own ASGI application, you can do so using the asgi decorator: from starlite.types import Scope , Receive , Send from starlite.status_codes import HTTP_400_BAD_REQUEST from starlite import Response , asgi @asgi ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ({ \"hello\" : \"world\" }) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST ) await response ( scope = scope , receive = receive , send = send ) Like other route handlers, the asgi decorator is an alias of the class ASGIRouteHandler . Thus, the code below is equivalent to the one above: from starlite.types import Scope , Receive , Send from starlite.status_codes import HTTP_400_BAD_REQUEST from starlite import ASGIRouteHandler , Response @ASGIRouteHandler ( path = \"/my-asgi-app\" ) async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : if scope [ \"method\" ] == \"GET\" : response = Response ({ \"hello\" : \"world\" }) await response ( scope = scope , receive = receive , send = send ) return response = Response ( { \"detail\" : \"unsupported request\" }, status_code = HTTP_400_BAD_REQUEST ) await response ( scope = scope , receive = receive , send = send )","title":"ASGI Route Handlers"},{"location":"usage/2-route-handlers/3-asgi-route-handlers/#limitations-of-asgi-route-handlers","text":"In difference to the other route handlers, the asgi route handler accepts only 3 kwargs that must be defined: scope , a mapping of values describing the ASGI connection. It always includes a type key, with the values being either http or websocket , and a path key. If the type is http , the scope dictionary will also include a method key with the value being one of DELETE, GET, POST, PATCH, PUT, HEAD . receive , an injected function by which the ASGI application receives messages. send , an injected function by which the ASGI application sends messages. You can read more about these in the ASGI specification . Additionally, ASGI route handler functions must be async functions. This is enforced using inspection, and if the function is not an async function, an informative exception will be raised. See the API Reference for full details on the asgi decorator and the kwargs it accepts.","title":"Limitations of ASGI route handlers"},{"location":"usage/2-route-handlers/4-route-handler-indexing/","text":"Route Handler Indexing You can provide in all route handler decorators a name kwarg. The value for this kwarg must be unique , otherwise ImproperlyConfiguredException exception will be raised. Default value for name is value returned by handler.__str__ which should be the full dotted path to the handler (e.g. app.controllers.projects.list for list function residing in app/controllers/projects.py file). name can be used to dynamically retrieve (i.e. during runtime) a mapping containing the route handler instance and paths, also it can be used to build a URL path for that handler: from starlite import Starlite , Request , Redirect , NotFoundException , get @get ( \"/abc\" , name = \"one\" ) def handler_one () -> None : pass @get ( \"/xyz\" , name = \"two\" ) def handler_two () -> None : pass @get ( \"/def/{param:int}\" , name = \"three\" ) def handler_three ( param : int ) -> None : pass @get ( \"/{handler_name:str}\" , name = \"four\" ) def handler_four ( request : Request , name : str ) -> Redirect : handler_index = request . app . get_handler_index_by_name ( name ) if not handler_index : raise NotFoundException ( f \"no handler matching the name { name } was found\" ) # handler_index == { \"paths\": [\"/\"], \"handler\": ..., \"qualname\": ... } # do something with the handler index below, e.g. send a redirect response to the handler, or access # handler.opt and some values stored there etc. return Redirect ( path = handler_index [ \"paths\" ][ 0 ]) @get ( \"/redirect/{param_value:int}\" , name = \"five\" ) def handler_five ( request : Request , param_value : int ) -> Redirect : path = request . app . route_reverse ( \"three\" , param = param_value ) return Redirect ( path = path ) app = Starlite ( route_handlers = [ handler_one , handler_two , handler_three ]) route_reverse will raise NoMatchRouteFoundException if route with given name was not found or if any of path parameters is missing or if any of passed path parameters types do not match types in the respective route declaration. However, str is accepted in place of datetime , date , time , timedelta , float , and Path parameters, so you can apply custom formatting and pass the result to route_reverse . If handler has multiple paths attached to it route_reverse will return the path that consumes the most number of keywords arguments passed to the function. from starlite import get , Request @get ( [ \"/some-path\" , \"/some-path/{id:int}\" , \"/some-path/{id:int}/{val:str}\" ], name = \"handler_name\" , ) def handler ( id : int = 1 , val : str = \"default\" ) -> None : ... @get ( \"/path-info\" ) def path_info ( request : Request ) -> str : path_optional = request . app . route_reverse ( \"handler_name\" ) # /some-path` path_partial = request . app . route_reverse ( \"handler_name\" , id = 100 ) # /some-path/100 path_full = request . app . route_reverse ( \"handler_name\" , id = 100 , val = \"value\" ) # /some-path/100/value` return f \" { path_optional } { path_partial } { path_full } \" If there are multiple paths attached to a handler that have the same path parameters (for example indexed handler has been registered on multiple routers) the result of route_reverse is not defined. The function will return a formatted path, but it might be picked randomly so reversing urls in such cases is highly discouraged. If you have access to request instance you can make reverse lookups using url_for function which is similar to route_reverse but returns absolute URL.","title":"Route Handler Indexing"},{"location":"usage/2-route-handlers/4-route-handler-indexing/#route-handler-indexing","text":"You can provide in all route handler decorators a name kwarg. The value for this kwarg must be unique , otherwise ImproperlyConfiguredException exception will be raised. Default value for name is value returned by handler.__str__ which should be the full dotted path to the handler (e.g. app.controllers.projects.list for list function residing in app/controllers/projects.py file). name can be used to dynamically retrieve (i.e. during runtime) a mapping containing the route handler instance and paths, also it can be used to build a URL path for that handler: from starlite import Starlite , Request , Redirect , NotFoundException , get @get ( \"/abc\" , name = \"one\" ) def handler_one () -> None : pass @get ( \"/xyz\" , name = \"two\" ) def handler_two () -> None : pass @get ( \"/def/{param:int}\" , name = \"three\" ) def handler_three ( param : int ) -> None : pass @get ( \"/{handler_name:str}\" , name = \"four\" ) def handler_four ( request : Request , name : str ) -> Redirect : handler_index = request . app . get_handler_index_by_name ( name ) if not handler_index : raise NotFoundException ( f \"no handler matching the name { name } was found\" ) # handler_index == { \"paths\": [\"/\"], \"handler\": ..., \"qualname\": ... } # do something with the handler index below, e.g. send a redirect response to the handler, or access # handler.opt and some values stored there etc. return Redirect ( path = handler_index [ \"paths\" ][ 0 ]) @get ( \"/redirect/{param_value:int}\" , name = \"five\" ) def handler_five ( request : Request , param_value : int ) -> Redirect : path = request . app . route_reverse ( \"three\" , param = param_value ) return Redirect ( path = path ) app = Starlite ( route_handlers = [ handler_one , handler_two , handler_three ]) route_reverse will raise NoMatchRouteFoundException if route with given name was not found or if any of path parameters is missing or if any of passed path parameters types do not match types in the respective route declaration. However, str is accepted in place of datetime , date , time , timedelta , float , and Path parameters, so you can apply custom formatting and pass the result to route_reverse . If handler has multiple paths attached to it route_reverse will return the path that consumes the most number of keywords arguments passed to the function. from starlite import get , Request @get ( [ \"/some-path\" , \"/some-path/{id:int}\" , \"/some-path/{id:int}/{val:str}\" ], name = \"handler_name\" , ) def handler ( id : int = 1 , val : str = \"default\" ) -> None : ... @get ( \"/path-info\" ) def path_info ( request : Request ) -> str : path_optional = request . app . route_reverse ( \"handler_name\" ) # /some-path` path_partial = request . app . route_reverse ( \"handler_name\" , id = 100 ) # /some-path/100 path_full = request . app . route_reverse ( \"handler_name\" , id = 100 , val = \"value\" ) # /some-path/100/value` return f \" { path_optional } { path_partial } { path_full } \" If there are multiple paths attached to a handler that have the same path parameters (for example indexed handler has been registered on multiple routers) the result of route_reverse is not defined. The function will return a formatted path, but it might be picked randomly so reversing urls in such cases is highly discouraged. If you have access to request instance you can make reverse lookups using url_for function which is similar to route_reverse but returns absolute URL.","title":"Route Handler Indexing"},{"location":"usage/2-route-handlers/5-handler-opts/","text":"Handler 'opts' All route handler decorators accept a key called opt which accepts a dictionary of arbitrary values, e.g. from starlite import get @get ( \"/\" , opt = { \"my_key\" : \"some-value\" }) def handler () -> None : ... This dictionary can be accessed by route guard , or by accessing the route_handler property on a request ( request.route_handler.opt ), or using the ASGI scope object directly ( scope[\"route_handler\"].opt ). Passing **kwargs to handlers Building on opts , you can pass any arbitrary kwarg to the route handler decorator, and it will be automatically set as a key in the opt dictionary: from starlite import get @get ( \"/\" , my_key = \"some-value\" ) def handler () -> None : ... assert handler . opt [ \"my_key\" ] == \"some-value\" You can specify the opt dictionary at all levels of your application. On specific route handlers, on a controller, a router, and even on the app instance itself. The resulting dictionary is constructed by merging opt dictionaries of all levels. If multiple layers define the same key, the value from the closest layer to the response handler will take precedence","title":"Handler 'opts'"},{"location":"usage/2-route-handlers/5-handler-opts/#handler-opts","text":"All route handler decorators accept a key called opt which accepts a dictionary of arbitrary values, e.g. from starlite import get @get ( \"/\" , opt = { \"my_key\" : \"some-value\" }) def handler () -> None : ... This dictionary can be accessed by route guard , or by accessing the route_handler property on a request ( request.route_handler.opt ), or using the ASGI scope object directly ( scope[\"route_handler\"].opt ).","title":"Handler 'opts'"},{"location":"usage/2-route-handlers/5-handler-opts/#passing-kwargs-to-handlers","text":"Building on opts , you can pass any arbitrary kwarg to the route handler decorator, and it will be automatically set as a key in the opt dictionary: from starlite import get @get ( \"/\" , my_key = \"some-value\" ) def handler () -> None : ... assert handler . opt [ \"my_key\" ] == \"some-value\" You can specify the opt dictionary at all levels of your application. On specific route handlers, on a controller, a router, and even on the app instance itself. The resulting dictionary is constructed by merging opt dictionaries of all levels. If multiple layers define the same key, the value from the closest layer to the response handler will take precedence","title":"Passing **kwargs to handlers"},{"location":"usage/3-parameters/0-path-parameters/","text":"Path Parameters Path parameters are parameters declared as part of the path component of the URL. They are declared using a simple syntax {param_name:param_type} : from pydantic import BaseModel from starlite import Starlite , get USER_DB = { 1 : { \"id\" : 1 , \"name\" : \"John Doe\" }} class User ( BaseModel ): id : int name : str @get ( \"/user/{user_id:int}\" ) def get_user ( user_id : int ) -> User : return User . parse_obj ( USER_DB [ user_id ]) app = Starlite ( route_handlers = [ get_user ]) In the above there are two components: The path parameter is defined in the @get decorator, which declares both the parameter's name ( user_id ) and type ( int ). The decorated function get_user defines a parameter with the same name as the parameter defined in the path kwarg. The correlation of parameter name ensures that the value of the path parameter will be injected into the function when it's called. Supported Path Parameter Types Currently, the following types are supported: date : Accepts date strings and time stamps. datetime : Accepts date-time strings and time stamps. decimal : Accepts decimal values and floats. float : Accepts ints and floats. int : Accepts ints and floats. path : Accepts valid POSIX paths. str : Accepts all string values. time : Accepts time strings with optional timezone compatible with pydantic formats. timedelta : Accepts duration strings compatible with the pydantic formats. uuid : Accepts all uuid values. The types declared in the path parameter and the function do not need to match 1:1 - as long as parameter inside the function declaration is typed with a \"higher\" type to which the lower type can be coerced, this is fine. For example, consider this: Python 3.8+ Python 3.9+ from datetime import datetime , timezone from typing import List from pydantic import BaseModel from starlite import Starlite , get class Order ( BaseModel ): id : int customer_id : int ORDERS_BY_DATETIME = { datetime . fromtimestamp ( 1667924386 , tz = timezone . utc ): [ Order ( id = 1 , customer_id = 2 ), Order ( id = 2 , customer_id = 2 ), ] } @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> List [ Order ]: return ORDERS_BY_DATETIME [ from_date ] app = Starlite ( route_handlers = [ get_orders ]) from datetime import datetime , timezone from pydantic import BaseModel from starlite import Starlite , get class Order ( BaseModel ): id : int customer_id : int ORDERS_BY_DATETIME = { datetime . fromtimestamp ( 1667924386 , tz = timezone . utc ): [ Order ( id = 1 , customer_id = 2 ), Order ( id = 2 , customer_id = 2 ), ] } @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> list [ Order ]: return ORDERS_BY_DATETIME [ from_date ] app = Starlite ( route_handlers = [ get_orders ]) The parameter defined inside the path kwarg is typed as int , because the value passed as part of the request will be a timestamp in milliseconds without any decimals. The parameter in the function declaration though is typed as datetime.datetime . This works because the int value will be passed to a pydantic model representing the function signature, which will coerce the int into a datetime. Thus, when the function is called it will be called with a datetime typed parameter. Note You only need to define the parameter in the function declaration if it's actually used inside the function. If the path parameter is part of the path, but the function doesn't use it, it's fine to omit it. It will still be validated and added to the openapi schema correctly. Extra Validation and Documentation for Path Params If you want to add validation or enhance the OpenAPI documentation generated for a given path parameter, you can do so using the Parameter function : from pydantic import BaseModel , Json , conint from pydantic_openapi_schema.v3_1_0.example import Example from pydantic_openapi_schema.v3_1_0.external_documentation import ExternalDocumentation from starlite import Parameter , Starlite , get class Version ( BaseModel ): id : conint ( ge = 1 , le = 10 ) # type: ignore[valid-type] specs : Json VERSIONS = { 1 : Version ( id = 1 , specs = '{\"some\": \"value\"}' )} @get ( path = \"/versions/{version:int}\" ) def get_product_version ( version : int = Parameter ( ge = 1 , le = 10 , title = \"Available Product Versions\" , description = \"Get a specific version spec from the available specs\" , examples = [ Example ( value = 1 )], external_docs = ExternalDocumentation ( url = \"https://mywebsite.com/documentation/product#versions\" , # type: ignore[arg-type] ), ) ) -> Version : return VERSIONS [ version ] app = Starlite ( route_handlers = [ get_product_version ]) In the above example, Parameter is used to restrict the value of version to a range between 1 and 10, and then set the title , description , examples and externalDocs sections of the OpenAPI schema.","title":"Path Parameters"},{"location":"usage/3-parameters/0-path-parameters/#path-parameters","text":"Path parameters are parameters declared as part of the path component of the URL. They are declared using a simple syntax {param_name:param_type} : from pydantic import BaseModel from starlite import Starlite , get USER_DB = { 1 : { \"id\" : 1 , \"name\" : \"John Doe\" }} class User ( BaseModel ): id : int name : str @get ( \"/user/{user_id:int}\" ) def get_user ( user_id : int ) -> User : return User . parse_obj ( USER_DB [ user_id ]) app = Starlite ( route_handlers = [ get_user ]) In the above there are two components: The path parameter is defined in the @get decorator, which declares both the parameter's name ( user_id ) and type ( int ). The decorated function get_user defines a parameter with the same name as the parameter defined in the path kwarg. The correlation of parameter name ensures that the value of the path parameter will be injected into the function when it's called.","title":"Path Parameters"},{"location":"usage/3-parameters/0-path-parameters/#supported-path-parameter-types","text":"Currently, the following types are supported: date : Accepts date strings and time stamps. datetime : Accepts date-time strings and time stamps. decimal : Accepts decimal values and floats. float : Accepts ints and floats. int : Accepts ints and floats. path : Accepts valid POSIX paths. str : Accepts all string values. time : Accepts time strings with optional timezone compatible with pydantic formats. timedelta : Accepts duration strings compatible with the pydantic formats. uuid : Accepts all uuid values. The types declared in the path parameter and the function do not need to match 1:1 - as long as parameter inside the function declaration is typed with a \"higher\" type to which the lower type can be coerced, this is fine. For example, consider this: Python 3.8+ Python 3.9+ from datetime import datetime , timezone from typing import List from pydantic import BaseModel from starlite import Starlite , get class Order ( BaseModel ): id : int customer_id : int ORDERS_BY_DATETIME = { datetime . fromtimestamp ( 1667924386 , tz = timezone . utc ): [ Order ( id = 1 , customer_id = 2 ), Order ( id = 2 , customer_id = 2 ), ] } @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> List [ Order ]: return ORDERS_BY_DATETIME [ from_date ] app = Starlite ( route_handlers = [ get_orders ]) from datetime import datetime , timezone from pydantic import BaseModel from starlite import Starlite , get class Order ( BaseModel ): id : int customer_id : int ORDERS_BY_DATETIME = { datetime . fromtimestamp ( 1667924386 , tz = timezone . utc ): [ Order ( id = 1 , customer_id = 2 ), Order ( id = 2 , customer_id = 2 ), ] } @get ( path = \"/orders/{from_date:int}\" ) def get_orders ( from_date : datetime ) -> list [ Order ]: return ORDERS_BY_DATETIME [ from_date ] app = Starlite ( route_handlers = [ get_orders ]) The parameter defined inside the path kwarg is typed as int , because the value passed as part of the request will be a timestamp in milliseconds without any decimals. The parameter in the function declaration though is typed as datetime.datetime . This works because the int value will be passed to a pydantic model representing the function signature, which will coerce the int into a datetime. Thus, when the function is called it will be called with a datetime typed parameter. Note You only need to define the parameter in the function declaration if it's actually used inside the function. If the path parameter is part of the path, but the function doesn't use it, it's fine to omit it. It will still be validated and added to the openapi schema correctly.","title":"Supported Path Parameter Types"},{"location":"usage/3-parameters/0-path-parameters/#extra-validation-and-documentation-for-path-params","text":"If you want to add validation or enhance the OpenAPI documentation generated for a given path parameter, you can do so using the Parameter function : from pydantic import BaseModel , Json , conint from pydantic_openapi_schema.v3_1_0.example import Example from pydantic_openapi_schema.v3_1_0.external_documentation import ExternalDocumentation from starlite import Parameter , Starlite , get class Version ( BaseModel ): id : conint ( ge = 1 , le = 10 ) # type: ignore[valid-type] specs : Json VERSIONS = { 1 : Version ( id = 1 , specs = '{\"some\": \"value\"}' )} @get ( path = \"/versions/{version:int}\" ) def get_product_version ( version : int = Parameter ( ge = 1 , le = 10 , title = \"Available Product Versions\" , description = \"Get a specific version spec from the available specs\" , examples = [ Example ( value = 1 )], external_docs = ExternalDocumentation ( url = \"https://mywebsite.com/documentation/product#versions\" , # type: ignore[arg-type] ), ) ) -> Version : return VERSIONS [ version ] app = Starlite ( route_handlers = [ get_product_version ]) In the above example, Parameter is used to restrict the value of version to a range between 1 and 10, and then set the title , description , examples and externalDocs sections of the OpenAPI schema.","title":"Extra Validation and Documentation for Path Params"},{"location":"usage/3-parameters/1-query-parameters/","text":"Query Parameters Query parameters are defined as keyword arguments to handler functions. Every keyword argument that is not otherwise specified (for example as a path parameter ) will be interpreted as a query parameter. Python 3.8+ Python 3.9+ from typing import Dict from starlite import Starlite , get @get ( \"/\" ) def index ( param : str ) -> Dict [ str , str ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from starlite import Starlite , get @get ( \"/\" ) def index ( param : str ) -> dict [ str , str ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/?param = foo { \"param\" : \"foo\" } > curl http://127.0.0.1:8000/?param = bar { \"param\" : \"bar\" } Technical details These parameters will be parsed from the function signature and used to generate a pydantic model. This model in turn will be used to validate the parameters and generate the OpenAPI schema. This means that you can also use any pydantic type in the signature, and it will follow the same kind of validation and parsing as you would get from pydantic. Query parameters come in three basic types: Required Required with a default value Optional with a default value Query parameters are required by default. If one such a parameter has no value, a ValidationException will be raised. Settings defaults In this example, param will have the value \"hello\" if it's not specified in the request. If it's passed as a query parameter however, it will be overwritten: Python 3.8+ Python 3.9+ from typing import Dict from starlite import Starlite , get @get ( \"/\" ) def index ( param : str = \"hello\" ) -> Dict [ str , str ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from starlite import Starlite , get @get ( \"/\" ) def index ( param : str = \"hello\" ) -> dict [ str , str ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/ { \"param\" : \"hello\" } > curl http://127.0.0.1:8000/?param = john { \"param\" : \"john\" } Optional parameters Instead of only setting a default value, it's also possible to make a query parameter entirely optional. Here, we give a default value of None , but still declare the type of the query parameter to be a string. This means that this parameter is not required. If it is given, it has to be a string. If it is not given, it will have a default value of None Python 3.8+ Python 3.9+ Python 3.10+ from typing import Dict , Optional from starlite import Starlite , get @get ( \"/\" ) def index ( param : Optional [ str ] = None ) -> Dict [ str , Optional [ str ]]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from typing import Optional from starlite import Starlite , get @get ( \"/\" ) def index ( param : Optional [ str ] = None ) -> dict [ str , Optional [ str ]]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from starlite import Starlite , get @get ( \"/\" ) def index ( param : str | None = None ) -> dict [ str , str | None ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/ { \"param\" :null } > curl http://127.0.0.1:8000/?param = goodbye { \"param\" : \"goodbye\" } Type coercion It is possible to coerce query parameters into different types. A query starts out as a string, but its values can be parsed into all kinds of types. Since this is done by pydantic, everything that works there will work for query parameters as well. Python 3.8+ Python 3.9+ from datetime import datetime , timedelta from typing import Any , Dict from starlite import Starlite , get @get ( \"/\" ) def index ( date : datetime , number : int , floating_number : float , strings : list [ str ], ) -> Dict [ str , Any ]: return { \"datetime\" : date + timedelta ( days = 1 ), \"int\" : number , \"float\" : floating_number , \"list\" : strings , } app = Starlite ( route_handlers = [ index ]) from datetime import datetime , timedelta from typing import Any from starlite import Starlite , get @get ( \"/\" ) def index ( date : datetime , number : int , floating_number : float , strings : list [ str ], ) -> dict [ str , Any ]: return { \"datetime\" : date + timedelta ( days = 1 ), \"int\" : number , \"float\" : floating_number , \"list\" : strings , } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/?date = 2022 -11-28T13:22:06.916540 & floating_number = 0 .1 & number = 42 & strings = 1 & strings = 2 { \"datetime\" : \"2022-11-29T13:22:06.916540\" , \"int\" :42, \"float\" :0.1, \"list\" : [ \"1\" , \"2\" ]} Specifying alternative names and constraints Sometimes you might want to \"remap\" query parameters to allow a different name in the URL than what's being used in the handler function. This can be done by making use of Parameter . Python 3.8+ Python 3.9+ from typing import Dict from starlite import Parameter , Starlite , get @get ( \"/\" ) def index ( snake_case : str = Parameter ( query = \"camelCase\" )) -> Dict [ str , str ]: return { \"param\" : snake_case } app = Starlite ( route_handlers = [ index ]) from starlite import Parameter , Starlite , get @get ( \"/\" ) def index ( snake_case : str = Parameter ( query = \"camelCase\" )) -> dict [ str , str ]: return { \"param\" : snake_case } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/?camelCase = foo { \"param\" : \"foo\" } Here, we remap from snake_case in the handler function to camelCase in the URL. This means that for the URL http://127.0.0.1:8000?camelCase=foo , the value of camelCase will be used for the value of the snake_case parameter. Parameter also allows us to define additional constraints: Python 3.8+ Python 3.9+ from typing import Dict from starlite import Parameter , Starlite , get @get ( \"/\" ) def index ( param : int = Parameter ( gt = 5 )) -> Dict [ str , int ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from starlite import Parameter , Starlite , get @get ( \"/\" ) def index ( param : int = Parameter ( gt = 5 )) -> dict [ str , int ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) In this case, param is validated to be an integer larger than 5 .","title":"Query Parameters"},{"location":"usage/3-parameters/1-query-parameters/#query-parameters","text":"Query parameters are defined as keyword arguments to handler functions. Every keyword argument that is not otherwise specified (for example as a path parameter ) will be interpreted as a query parameter. Python 3.8+ Python 3.9+ from typing import Dict from starlite import Starlite , get @get ( \"/\" ) def index ( param : str ) -> Dict [ str , str ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from starlite import Starlite , get @get ( \"/\" ) def index ( param : str ) -> dict [ str , str ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/?param = foo { \"param\" : \"foo\" } > curl http://127.0.0.1:8000/?param = bar { \"param\" : \"bar\" } Technical details These parameters will be parsed from the function signature and used to generate a pydantic model. This model in turn will be used to validate the parameters and generate the OpenAPI schema. This means that you can also use any pydantic type in the signature, and it will follow the same kind of validation and parsing as you would get from pydantic. Query parameters come in three basic types: Required Required with a default value Optional with a default value Query parameters are required by default. If one such a parameter has no value, a ValidationException will be raised.","title":"Query Parameters"},{"location":"usage/3-parameters/1-query-parameters/#settings-defaults","text":"In this example, param will have the value \"hello\" if it's not specified in the request. If it's passed as a query parameter however, it will be overwritten: Python 3.8+ Python 3.9+ from typing import Dict from starlite import Starlite , get @get ( \"/\" ) def index ( param : str = \"hello\" ) -> Dict [ str , str ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from starlite import Starlite , get @get ( \"/\" ) def index ( param : str = \"hello\" ) -> dict [ str , str ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/ { \"param\" : \"hello\" } > curl http://127.0.0.1:8000/?param = john { \"param\" : \"john\" }","title":"Settings defaults"},{"location":"usage/3-parameters/1-query-parameters/#optional-parameters","text":"Instead of only setting a default value, it's also possible to make a query parameter entirely optional. Here, we give a default value of None , but still declare the type of the query parameter to be a string. This means that this parameter is not required. If it is given, it has to be a string. If it is not given, it will have a default value of None Python 3.8+ Python 3.9+ Python 3.10+ from typing import Dict , Optional from starlite import Starlite , get @get ( \"/\" ) def index ( param : Optional [ str ] = None ) -> Dict [ str , Optional [ str ]]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from typing import Optional from starlite import Starlite , get @get ( \"/\" ) def index ( param : Optional [ str ] = None ) -> dict [ str , Optional [ str ]]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from starlite import Starlite , get @get ( \"/\" ) def index ( param : str | None = None ) -> dict [ str , str | None ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/ { \"param\" :null } > curl http://127.0.0.1:8000/?param = goodbye { \"param\" : \"goodbye\" }","title":"Optional parameters"},{"location":"usage/3-parameters/1-query-parameters/#type-coercion","text":"It is possible to coerce query parameters into different types. A query starts out as a string, but its values can be parsed into all kinds of types. Since this is done by pydantic, everything that works there will work for query parameters as well. Python 3.8+ Python 3.9+ from datetime import datetime , timedelta from typing import Any , Dict from starlite import Starlite , get @get ( \"/\" ) def index ( date : datetime , number : int , floating_number : float , strings : list [ str ], ) -> Dict [ str , Any ]: return { \"datetime\" : date + timedelta ( days = 1 ), \"int\" : number , \"float\" : floating_number , \"list\" : strings , } app = Starlite ( route_handlers = [ index ]) from datetime import datetime , timedelta from typing import Any from starlite import Starlite , get @get ( \"/\" ) def index ( date : datetime , number : int , floating_number : float , strings : list [ str ], ) -> dict [ str , Any ]: return { \"datetime\" : date + timedelta ( days = 1 ), \"int\" : number , \"float\" : floating_number , \"list\" : strings , } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/?date = 2022 -11-28T13:22:06.916540 & floating_number = 0 .1 & number = 42 & strings = 1 & strings = 2 { \"datetime\" : \"2022-11-29T13:22:06.916540\" , \"int\" :42, \"float\" :0.1, \"list\" : [ \"1\" , \"2\" ]}","title":"Type coercion"},{"location":"usage/3-parameters/1-query-parameters/#specifying-alternative-names-and-constraints","text":"Sometimes you might want to \"remap\" query parameters to allow a different name in the URL than what's being used in the handler function. This can be done by making use of Parameter . Python 3.8+ Python 3.9+ from typing import Dict from starlite import Parameter , Starlite , get @get ( \"/\" ) def index ( snake_case : str = Parameter ( query = \"camelCase\" )) -> Dict [ str , str ]: return { \"param\" : snake_case } app = Starlite ( route_handlers = [ index ]) from starlite import Parameter , Starlite , get @get ( \"/\" ) def index ( snake_case : str = Parameter ( query = \"camelCase\" )) -> dict [ str , str ]: return { \"param\" : snake_case } app = Starlite ( route_handlers = [ index ]) Run it > curl http://127.0.0.1:8000/?camelCase = foo { \"param\" : \"foo\" } Here, we remap from snake_case in the handler function to camelCase in the URL. This means that for the URL http://127.0.0.1:8000?camelCase=foo , the value of camelCase will be used for the value of the snake_case parameter. Parameter also allows us to define additional constraints: Python 3.8+ Python 3.9+ from typing import Dict from starlite import Parameter , Starlite , get @get ( \"/\" ) def index ( param : int = Parameter ( gt = 5 )) -> Dict [ str , int ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) from starlite import Parameter , Starlite , get @get ( \"/\" ) def index ( param : int = Parameter ( gt = 5 )) -> dict [ str , int ]: return { \"param\" : param } app = Starlite ( route_handlers = [ index ]) In this case, param is validated to be an integer larger than 5 .","title":"Specifying alternative names and constraints"},{"location":"usage/3-parameters/2-header-and-cookie-parameters/","text":"Header and Cookie Parameters Unlike Query parameters, Header and Cookie parameters have to be declared using the Parameter function , for example: from pydantic import BaseModel from starlite import NotAuthorizedException , Parameter , Starlite , get USER_DB = { 1 : { \"id\" : 1 , \"name\" : \"John Doe\" , }, } VALID_TOKEN = \"super-secret-secret\" VALID_COOKIE_VALUE = \"cookie-secret\" class User ( BaseModel ): id : int name : str @get ( path = \"/users/{user_id:int}/\" ) async def get_user ( user_id : int , token : str = Parameter ( header = \"X-API-KEY\" ), cookie : str = Parameter ( cookie = \"my-cookie-param\" ), ) -> User : if not ( token == VALID_TOKEN and cookie == VALID_COOKIE_VALUE ): raise NotAuthorizedException return User . parse_obj ( USER_DB [ user_id ]) app = Starlite ( route_handlers = [ get_user ]) As you can see in the above, header parameters are declared using the header kwargs and cookie parameters using the cookie kwarg. Aside form this difference they work the same as query parameters.","title":"Header and Cookie Parameters"},{"location":"usage/3-parameters/2-header-and-cookie-parameters/#header-and-cookie-parameters","text":"Unlike Query parameters, Header and Cookie parameters have to be declared using the Parameter function , for example: from pydantic import BaseModel from starlite import NotAuthorizedException , Parameter , Starlite , get USER_DB = { 1 : { \"id\" : 1 , \"name\" : \"John Doe\" , }, } VALID_TOKEN = \"super-secret-secret\" VALID_COOKIE_VALUE = \"cookie-secret\" class User ( BaseModel ): id : int name : str @get ( path = \"/users/{user_id:int}/\" ) async def get_user ( user_id : int , token : str = Parameter ( header = \"X-API-KEY\" ), cookie : str = Parameter ( cookie = \"my-cookie-param\" ), ) -> User : if not ( token == VALID_TOKEN and cookie == VALID_COOKIE_VALUE ): raise NotAuthorizedException return User . parse_obj ( USER_DB [ user_id ]) app = Starlite ( route_handlers = [ get_user ]) As you can see in the above, header parameters are declared using the header kwargs and cookie parameters using the cookie kwarg. Aside form this difference they work the same as query parameters.","title":"Header and Cookie Parameters"},{"location":"usage/3-parameters/3-the-parameter-function/","text":"The Parameter Function Parameter is a wrapper on top of the pydantic Field function that extends it with a set of Starlite specific kwargs. As such, you can use most of the kwargs of Field with Parameter and have the same parsing and validation. The additional kwargs accepted by Parameter are passed to the resulting pydantic FieldInfo as an extra dictionary and have no effect on the working of pydantic itself. See the API Reference for full details on the Parameter function and the kwargs it accepts.","title":"The Parameter Function"},{"location":"usage/3-parameters/3-the-parameter-function/#the-parameter-function","text":"Parameter is a wrapper on top of the pydantic Field function that extends it with a set of Starlite specific kwargs. As such, you can use most of the kwargs of Field with Parameter and have the same parsing and validation. The additional kwargs accepted by Parameter are passed to the resulting pydantic FieldInfo as an extra dictionary and have no effect on the working of pydantic itself. See the API Reference for full details on the Parameter function and the kwargs it accepts.","title":"The Parameter Function"},{"location":"usage/3-parameters/4-layered-parameters/","text":"Layered Parameters As part of Starlite's \"layered\" architecture, you can declare parameters not only as part of individual route handler functions, but also on other layers of the application: Python 3.8+ Python 3.9+ Python 3.10+ from typing import Dict , Union from starlite import Controller , Parameter , Router , Starlite , get class MyController ( Controller ): path = \"/controller\" parameters = { \"controller_param\" : Parameter ( int , lt = 100 ), } @get ( \"/{path_param:int}\" ) def my_handler ( self , path_param : int , local_param : str , router_param : str , controller_param : int = Parameter ( int , lt = 50 ), ) -> Dict [ str , Union [ str , int ]]: return { \"path_param\" : path_param , \"local_param\" : local_param , \"router_param\" : router_param , \"controller_param\" : controller_param , } router = Router ( path = \"/router\" , route_handlers = [ MyController ], parameters = { \"router_param\" : Parameter ( str , regex = \"^[a-zA-Z]$\" , header = \"MyHeader\" , required = False ), }, ) app = Starlite ( route_handlers = [ router ], parameters = { \"app_param\" : Parameter ( str , cookie = \"special-cookie\" ), }, ) from typing import Union from starlite import Controller , Parameter , Router , Starlite , get class MyController ( Controller ): path = \"/controller\" parameters = { \"controller_param\" : Parameter ( int , lt = 100 ), } @get ( \"/{path_param:int}\" ) def my_handler ( self , path_param : int , local_param : str , router_param : str , controller_param : int = Parameter ( int , lt = 50 ), ) -> dict [ str , Union [ str , int ]]: return { \"path_param\" : path_param , \"local_param\" : local_param , \"router_param\" : router_param , \"controller_param\" : controller_param , } router = Router ( path = \"/router\" , route_handlers = [ MyController ], parameters = { \"router_param\" : Parameter ( str , regex = \"^[a-zA-Z]$\" , header = \"MyHeader\" , required = False ), }, ) app = Starlite ( route_handlers = [ router ], parameters = { \"app_param\" : Parameter ( str , cookie = \"special-cookie\" ), }, ) from starlite import Controller , Parameter , Router , Starlite , get class MyController ( Controller ): path = \"/controller\" parameters = { \"controller_param\" : Parameter ( int , lt = 100 ), } @get ( \"/{path_param:int}\" ) def my_handler ( self , path_param : int , local_param : str , router_param : str , controller_param : int = Parameter ( int , lt = 50 ), ) -> dict [ str , str | int ]: return { \"path_param\" : path_param , \"local_param\" : local_param , \"router_param\" : router_param , \"controller_param\" : controller_param , } router = Router ( path = \"/router\" , route_handlers = [ MyController ], parameters = { \"router_param\" : Parameter ( str , regex = \"^[a-zA-Z]$\" , header = \"MyHeader\" , required = False ), }, ) app = Starlite ( route_handlers = [ router ], parameters = { \"app_param\" : Parameter ( str , cookie = \"special-cookie\" ), }, ) In the above we declare parameters on the app, router and controller levels in addition to those declared in the route handler. Let's look at these closer. app_param is a cookie param with the key special-cookie . We type it as str by passing this as an arg to the Parameter function. This is required for us to get typing in the OpenAPI docs. Additionally, this parameter is assumed to be required because it is not explicitly declared as required=False . This is important because the route handler function does not declare a parameter called app_param at all, but it will still require this param to be sent as part of the request of validation will fail. router_param is a header param with the key MyHeader . Because its declared as required=False , it will not fail validation if not present unless explicitly declared by a route handler - and in this case it is. Thus, it is actually required for the router handler function that declares it as an str and not an Optional[str] . If a string value is provided, it will be tested against the provided regex. controller_param is a query param with the key controller_param . It has an lt=100 defined on the controller, which means the provided value must be less than 100. Yet the route handler re-declares it with an lt=50 , which means for the route handler this value must be less than 50. Finally local_param is a route handler local query parameter, and path_param is a path parameter. Note You cannot declare path parameters in different application layers. The reason for this is to ensure simplicity - otherwise parameter resolution becomes very difficult to do correctly.","title":"Layered Parameters"},{"location":"usage/3-parameters/4-layered-parameters/#layered-parameters","text":"As part of Starlite's \"layered\" architecture, you can declare parameters not only as part of individual route handler functions, but also on other layers of the application: Python 3.8+ Python 3.9+ Python 3.10+ from typing import Dict , Union from starlite import Controller , Parameter , Router , Starlite , get class MyController ( Controller ): path = \"/controller\" parameters = { \"controller_param\" : Parameter ( int , lt = 100 ), } @get ( \"/{path_param:int}\" ) def my_handler ( self , path_param : int , local_param : str , router_param : str , controller_param : int = Parameter ( int , lt = 50 ), ) -> Dict [ str , Union [ str , int ]]: return { \"path_param\" : path_param , \"local_param\" : local_param , \"router_param\" : router_param , \"controller_param\" : controller_param , } router = Router ( path = \"/router\" , route_handlers = [ MyController ], parameters = { \"router_param\" : Parameter ( str , regex = \"^[a-zA-Z]$\" , header = \"MyHeader\" , required = False ), }, ) app = Starlite ( route_handlers = [ router ], parameters = { \"app_param\" : Parameter ( str , cookie = \"special-cookie\" ), }, ) from typing import Union from starlite import Controller , Parameter , Router , Starlite , get class MyController ( Controller ): path = \"/controller\" parameters = { \"controller_param\" : Parameter ( int , lt = 100 ), } @get ( \"/{path_param:int}\" ) def my_handler ( self , path_param : int , local_param : str , router_param : str , controller_param : int = Parameter ( int , lt = 50 ), ) -> dict [ str , Union [ str , int ]]: return { \"path_param\" : path_param , \"local_param\" : local_param , \"router_param\" : router_param , \"controller_param\" : controller_param , } router = Router ( path = \"/router\" , route_handlers = [ MyController ], parameters = { \"router_param\" : Parameter ( str , regex = \"^[a-zA-Z]$\" , header = \"MyHeader\" , required = False ), }, ) app = Starlite ( route_handlers = [ router ], parameters = { \"app_param\" : Parameter ( str , cookie = \"special-cookie\" ), }, ) from starlite import Controller , Parameter , Router , Starlite , get class MyController ( Controller ): path = \"/controller\" parameters = { \"controller_param\" : Parameter ( int , lt = 100 ), } @get ( \"/{path_param:int}\" ) def my_handler ( self , path_param : int , local_param : str , router_param : str , controller_param : int = Parameter ( int , lt = 50 ), ) -> dict [ str , str | int ]: return { \"path_param\" : path_param , \"local_param\" : local_param , \"router_param\" : router_param , \"controller_param\" : controller_param , } router = Router ( path = \"/router\" , route_handlers = [ MyController ], parameters = { \"router_param\" : Parameter ( str , regex = \"^[a-zA-Z]$\" , header = \"MyHeader\" , required = False ), }, ) app = Starlite ( route_handlers = [ router ], parameters = { \"app_param\" : Parameter ( str , cookie = \"special-cookie\" ), }, ) In the above we declare parameters on the app, router and controller levels in addition to those declared in the route handler. Let's look at these closer. app_param is a cookie param with the key special-cookie . We type it as str by passing this as an arg to the Parameter function. This is required for us to get typing in the OpenAPI docs. Additionally, this parameter is assumed to be required because it is not explicitly declared as required=False . This is important because the route handler function does not declare a parameter called app_param at all, but it will still require this param to be sent as part of the request of validation will fail. router_param is a header param with the key MyHeader . Because its declared as required=False , it will not fail validation if not present unless explicitly declared by a route handler - and in this case it is. Thus, it is actually required for the router handler function that declares it as an str and not an Optional[str] . If a string value is provided, it will be tested against the provided regex. controller_param is a query param with the key controller_param . It has an lt=100 defined on the controller, which means the provided value must be less than 100. Yet the route handler re-declares it with an lt=50 , which means for the route handler this value must be less than 50. Finally local_param is a route handler local query parameter, and path_param is a path parameter. Note You cannot declare path parameters in different application layers. The reason for this is to ensure simplicity - otherwise parameter resolution becomes very difficult to do correctly.","title":"Layered Parameters"},{"location":"usage/5-responses/0-responses-intro/","text":"HTTP Responses Starlite allows for several ways in which HTTP responses can be specified and handled, each fitting a different use case. The base pattern though is straightforward - simply return a value from a route handler function and let Starlite take care of the rest: from pydantic import BaseModel from starlite import get class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" ) In the example above, the route handler function returns an instance of the Resource pydantic class. This value will then be used by Starlite to construct an instance of the Response class using defaults values: the response status code will be set to 200 and it's Content-Type header will be set to application/json . The Resource instance will be serialized into JSON and set as the response body.","title":"HTTP Responses"},{"location":"usage/5-responses/0-responses-intro/#http-responses","text":"Starlite allows for several ways in which HTTP responses can be specified and handled, each fitting a different use case. The base pattern though is straightforward - simply return a value from a route handler function and let Starlite take care of the rest: from pydantic import BaseModel from starlite import get class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" ) In the example above, the route handler function returns an instance of the Resource pydantic class. This value will then be used by Starlite to construct an instance of the Response class using defaults values: the response status code will be set to 200 and it's Content-Type header will be set to application/json . The Resource instance will be serialized into JSON and set as the response body.","title":"HTTP Responses"},{"location":"usage/5-responses/1-media-type/","text":"Media Type You do not have to specify the media_type kwarg in the route handler function if the response should be JSON. But if you wish to return a response other than JSON, you should specify this value. You can use the MediaType enum for this purpose: from starlite import MediaType , get @get ( \"/resources\" , media_type = MediaType . TEXT ) def retrieve_resource () -> str : return \"The rumbling rabbit ran around the rock\" The value of the media_type kwarg affects both the serialization of response data and the generation of OpenAPI docs. The above example will cause Starlite to serialize the response as a simple bytes string with a Content-Type header value of text/plain . It will also set the corresponding values in the OpenAPI documentation. MediaType has the following members: MediaType.JSON: application/json MediaType.MessagePack: application/x-msgpack MediaType.TEXT: text/plain MediaType.HTML: text/html You can also set any IANA referenced media type string as the media_type . While this will still affect the OpenAPI generation as expected, you might need to handle serialization using either a custom response with serializer or by serializing the value in the route handler function. JSON Responses As previously mentioned, the default media_type is MediaType.JSON . which supports the following values: dictionaries dataclasses from the standard library pydantic dataclasses pydantic models models from libraries that extend pydantic models lists containing any of the above elements UUIDs datetime objects msgspec.Struct If you need to return other values and would like to extend serialization you can do this using Custom Responses . MessagePack Responses In addition to JSON, Starlite offers support for the MessagePack format which can be a time and space efficient alternative to JSON. It supports all the same types as JSON serialization. To send a MessagePack response, simply specify the media type as MediaType.MESSAGEPACK : Python 3.8+ Python 3.9+ from typing import Dict from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . MESSAGEPACK ) def health_check () -> Dict [ str , str ]: return { \"hello\" : \"world\" } from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . MESSAGEPACK ) def health_check () -> dict [ str , str ]: return { \"hello\" : \"world\" } Text Responses For MediaType.TEXT , route handlers should return a string or bytes value: from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" HTML Responses For MediaType.HTML , route handlers should return a string or bytes value that contains HTML: from starlite import get , MediaType @get ( path = \"/page\" , media_type = MediaType . HTML ) def health_check () -> str : return \"\"\" <html> <body> <div> <span>Hello World!</span> </div> </body> </html> \"\"\" Tip It's a good idea to use a templating engine for more complex HTML responses and to write the template itself in a separate file rather than a string.","title":"Media Type"},{"location":"usage/5-responses/1-media-type/#media-type","text":"You do not have to specify the media_type kwarg in the route handler function if the response should be JSON. But if you wish to return a response other than JSON, you should specify this value. You can use the MediaType enum for this purpose: from starlite import MediaType , get @get ( \"/resources\" , media_type = MediaType . TEXT ) def retrieve_resource () -> str : return \"The rumbling rabbit ran around the rock\" The value of the media_type kwarg affects both the serialization of response data and the generation of OpenAPI docs. The above example will cause Starlite to serialize the response as a simple bytes string with a Content-Type header value of text/plain . It will also set the corresponding values in the OpenAPI documentation. MediaType has the following members: MediaType.JSON: application/json MediaType.MessagePack: application/x-msgpack MediaType.TEXT: text/plain MediaType.HTML: text/html You can also set any IANA referenced media type string as the media_type . While this will still affect the OpenAPI generation as expected, you might need to handle serialization using either a custom response with serializer or by serializing the value in the route handler function.","title":"Media Type"},{"location":"usage/5-responses/1-media-type/#json-responses","text":"As previously mentioned, the default media_type is MediaType.JSON . which supports the following values: dictionaries dataclasses from the standard library pydantic dataclasses pydantic models models from libraries that extend pydantic models lists containing any of the above elements UUIDs datetime objects msgspec.Struct If you need to return other values and would like to extend serialization you can do this using Custom Responses .","title":"JSON Responses"},{"location":"usage/5-responses/1-media-type/#messagepack-responses","text":"In addition to JSON, Starlite offers support for the MessagePack format which can be a time and space efficient alternative to JSON. It supports all the same types as JSON serialization. To send a MessagePack response, simply specify the media type as MediaType.MESSAGEPACK : Python 3.8+ Python 3.9+ from typing import Dict from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . MESSAGEPACK ) def health_check () -> Dict [ str , str ]: return { \"hello\" : \"world\" } from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . MESSAGEPACK ) def health_check () -> dict [ str , str ]: return { \"hello\" : \"world\" }","title":"MessagePack Responses"},{"location":"usage/5-responses/1-media-type/#text-responses","text":"For MediaType.TEXT , route handlers should return a string or bytes value: from starlite import get , MediaType @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\"","title":"Text Responses"},{"location":"usage/5-responses/1-media-type/#html-responses","text":"For MediaType.HTML , route handlers should return a string or bytes value that contains HTML: from starlite import get , MediaType @get ( path = \"/page\" , media_type = MediaType . HTML ) def health_check () -> str : return \"\"\" <html> <body> <div> <span>Hello World!</span> </div> </body> </html> \"\"\" Tip It's a good idea to use a templating engine for more complex HTML responses and to write the template itself in a separate file rather than a string.","title":"HTML Responses"},{"location":"usage/5-responses/10-custom-responses/","text":"Custom Responses While Starlite supports the serialization of many types by default, sometimes you want to return something that's not supported. In those cases it's convenient to make use of a custom response class. The example below illustrates how to deal with MultiDict instances. -- 8 <-- \"examples/responses/custom_responses.py\" Layered architecture Response classes are part of Starlite's layered architecture, which means you can set a response class on every layer of the application. If you have set a response class on multiple layers, the layer closes to the route handler will take precedence. You can read more about this here: Layered architecture","title":"Custom Responses"},{"location":"usage/5-responses/10-custom-responses/#custom-responses","text":"While Starlite supports the serialization of many types by default, sometimes you want to return something that's not supported. In those cases it's convenient to make use of a custom response class. The example below illustrates how to deal with MultiDict instances. -- 8 <-- \"examples/responses/custom_responses.py\" Layered architecture Response classes are part of Starlite's layered architecture, which means you can set a response class on every layer of the application. If you have set a response class on multiple layers, the layer closes to the route handler will take precedence. You can read more about this here: Layered architecture","title":"Custom Responses"},{"location":"usage/5-responses/11-background-tasks/","text":"Background Tasks All Starlite responses and response containers (e.g. File , Template etc.) allow passing in a background_task kwarg. This kwarg accepts either an instance of BackgroundTask or an instance of BackgroundTasks , which wraps an iterable of BackgroundTask instances. A background task is a sync or async callable (function, method or class that implements the __call__ dunder method) that will be called after the response finishes sending the data. Thus, in the following example the passed in background task will be executed after the response sends: import logging from starlite import BackgroundTask , get logger = logging . getLogger ( __name__ ) async def logging_task ( identifier : str , message : str ) -> None : logger . info ( f \" { identifier } : { message } \" ) @get ( \"/\" , background = BackgroundTask ( logging_task , \"greeter\" , message = \"was called\" )) def greeter () -> dict [ str , str ]: return { \"hello\" : \"world\" } When the greeter handler is called, the logging task will be called with any *args and **kwargs passed into the BackgroundTask . Note In the above example \"greeter\" is an arg and message=\"was called\" is a kwarg. The function signature of logging_task allows for this, so this should pose no problem. Starlite uses ParamSpec to ensure that a BackgroundTask is properly typed, so will get type checking for any passed in args and kwargs. Executing Multiple BackgroundTasks You can also use the BackgroundTasks class instead, and pass to it an iterable (list, tuple etc.) of BackgroundTask instances. This class accepts one optional kwargs aside from the tasks - run_in_task_group , which is a boolean flag that defaults to False . If you set this value to True than the tasks will run concurrently, using an anyio.task_group . Note Setting run_in_task_group to True will not preserve execution order.","title":"Background Tasks"},{"location":"usage/5-responses/11-background-tasks/#background-tasks","text":"All Starlite responses and response containers (e.g. File , Template etc.) allow passing in a background_task kwarg. This kwarg accepts either an instance of BackgroundTask or an instance of BackgroundTasks , which wraps an iterable of BackgroundTask instances. A background task is a sync or async callable (function, method or class that implements the __call__ dunder method) that will be called after the response finishes sending the data. Thus, in the following example the passed in background task will be executed after the response sends: import logging from starlite import BackgroundTask , get logger = logging . getLogger ( __name__ ) async def logging_task ( identifier : str , message : str ) -> None : logger . info ( f \" { identifier } : { message } \" ) @get ( \"/\" , background = BackgroundTask ( logging_task , \"greeter\" , message = \"was called\" )) def greeter () -> dict [ str , str ]: return { \"hello\" : \"world\" } When the greeter handler is called, the logging task will be called with any *args and **kwargs passed into the BackgroundTask . Note In the above example \"greeter\" is an arg and message=\"was called\" is a kwarg. The function signature of logging_task allows for this, so this should pose no problem. Starlite uses ParamSpec to ensure that a BackgroundTask is properly typed, so will get type checking for any passed in args and kwargs.","title":"Background Tasks"},{"location":"usage/5-responses/11-background-tasks/#executing-multiple-backgroundtasks","text":"You can also use the BackgroundTasks class instead, and pass to it an iterable (list, tuple etc.) of BackgroundTask instances. This class accepts one optional kwargs aside from the tasks - run_in_task_group , which is a boolean flag that defaults to False . If you set this value to True than the tasks will run concurrently, using an anyio.task_group . Note Setting run_in_task_group to True will not preserve execution order.","title":"Executing Multiple BackgroundTasks"},{"location":"usage/5-responses/12-pagination/","text":"Pagination When you need to return a large number of items from an endpoint it is common practice to use pagination to ensure clients can request a specific subset or \"page\" from the total dataset. Starlite supports three types of pagination out of the box: classic pagination limit / offset pagination cursor pagination Classic Pagination In classic pagination the dataset is divided into pages of a specific size and the consumer then requests a specific page. Python 3.8+ Python 3.9+ Classic Pagination from typing import List from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncClassicPaginator , ClassicPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items' # we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory. class PersonClassicPaginator ( AbstractSyncClassicPaginator [ Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_total ( self , page_size : int ) -> int : return round ( len ( self . data ) / page_size ) def get_items ( self , page_size : int , current_page : int ) -> List [ Person ]: return [ self . data [ i : i + page_size ] for i in range ( 0 , len ( self . data ), page_size )][ current_page - 1 ] paginator = PersonClassicPaginator () # we now create a regular handler. The handler will receive two query parameters - 'page_size' and 'current_page', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( page_size : int , current_page : int ) -> ClassicPagination [ Person ]: return paginator ( page_size = page_size , current_page = current_page ) app = Starlite ( route_handlers = [ people_handler ]) Classic Pagination from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncClassicPaginator , ClassicPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items' # we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory. class PersonClassicPaginator ( AbstractSyncClassicPaginator [ Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_total ( self , page_size : int ) -> int : return round ( len ( self . data ) / page_size ) def get_items ( self , page_size : int , current_page : int ) -> list [ Person ]: return [ self . data [ i : i + page_size ] for i in range ( 0 , len ( self . data ), page_size )][ current_page - 1 ] paginator = PersonClassicPaginator () # we now create a regular handler. The handler will receive two query parameters - 'page_size' and 'current_page', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( page_size : int , current_page : int ) -> ClassicPagination [ Person ]: return paginator ( page_size = page_size , current_page = current_page ) app = Starlite ( route_handlers = [ people_handler ]) The data container for this pagination is called ClassicPagination , which is what will be returned by the paginator in the above example This will also generate the corresponding OpenAPI documentation. If you require async logic, you can implement the AbstractAsyncClassicPaginator instead of the AbstractSyncClassicPaginator . Offset Pagination In offset pagination the consumer requests a number of items specified by limit and the offset from the beginning of the dataset. For example, given a list of 50 items, you could request limit=10 , offset=39 to request items 40-50. Python 3.8+ Python 3.9+ Offset Pagination from itertools import islice from typing import List from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncOffsetPaginator , OffsetPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items' # we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory. class PersonOffsetPaginator ( AbstractSyncOffsetPaginator [ Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_total ( self ) -> int : return len ( self . data ) def get_items ( self , limit : int , offset : int ) -> List [ Person ]: return list ( islice ( islice ( self . data , offset , None ), limit )) paginator = PersonOffsetPaginator () # we now create a regular handler. The handler will receive two query parameters - 'limit' and 'offset', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( limit : int , offset : int ) -> OffsetPagination [ Person ]: return paginator ( limit = limit , offset = offset ) app = Starlite ( route_handlers = [ people_handler ]) Offset Pagination from itertools import islice from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncOffsetPaginator , OffsetPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items' # we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory. class PersonOffsetPaginator ( AbstractSyncOffsetPaginator [ Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_total ( self ) -> int : return len ( self . data ) def get_items ( self , limit : int , offset : int ) -> list [ Person ]: return list ( islice ( islice ( self . data , offset , None ), limit )) paginator = PersonOffsetPaginator () # we now create a regular handler. The handler will receive two query parameters - 'limit' and 'offset', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( limit : int , offset : int ) -> OffsetPagination [ Person ]: return paginator ( limit = limit , offset = offset ) app = Starlite ( route_handlers = [ people_handler ]) The data container for this pagination is called OffsetPagination , which is what will be returned by the paginator in the above example This will also generate the corresponding OpenAPI documentation. If you require async logic, you can implement the AbstractAsyncOffsetPaginator instead of the AbstractSyncOffsetPaginator . Cursor Pagination In cursor pagination the consumer requests a number of items specified by results_per_page and a cursor after which results are given. Cursor is unique identifier within the dataset that serves as a way to point the starting position. Python 3.8+ Python 3.9+ Python 3.10+ Cursor Pagination from typing import List , Optional , Tuple from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncCursorPaginator , CursorPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement the method 'get_items'. class PersonCursorPaginator ( AbstractSyncCursorPaginator [ str , Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_items ( self , cursor : Optional [ str ], results_per_page : int ) -> Tuple [ List [ Person ], Optional [ str ]]: results = self . data [: results_per_page ] return results , results [ - 1 ] . id paginator = PersonCursorPaginator () # we now create a regular handler. The handler will receive a single query parameter - 'cursor', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( cursor : Optional [ str ], results_per_page : int ) -> CursorPagination [ str , Person ]: return paginator ( cursor = cursor , results_per_page = results_per_page ) app = Starlite ( route_handlers = [ people_handler ]) Cursor Pagination from typing import Optional from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncCursorPaginator , CursorPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement the method 'get_items'. class PersonCursorPaginator ( AbstractSyncCursorPaginator [ str , Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_items ( self , cursor : Optional [ str ], results_per_page : int ) -> tuple [ list [ Person ], Optional [ str ]]: results = self . data [: results_per_page ] return results , results [ - 1 ] . id paginator = PersonCursorPaginator () # we now create a regular handler. The handler will receive a single query parameter - 'cursor', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( cursor : Optional [ str ], results_per_page : int ) -> CursorPagination [ str , Person ]: return paginator ( cursor = cursor , results_per_page = results_per_page ) app = Starlite ( route_handlers = [ people_handler ]) Cursor Pagination from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncCursorPaginator , CursorPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement the method 'get_items'. class PersonCursorPaginator ( AbstractSyncCursorPaginator [ str , Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_items ( self , cursor : str | None , results_per_page : int ) -> tuple [ list [ Person ], str | None ]: results = self . data [: results_per_page ] return results , results [ - 1 ] . id paginator = PersonCursorPaginator () # we now create a regular handler. The handler will receive a single query parameter - 'cursor', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( cursor : str | None , results_per_page : int ) -> CursorPagination [ str , Person ]: return paginator ( cursor = cursor , results_per_page = results_per_page ) app = Starlite ( route_handlers = [ people_handler ]) The data container for this pagination is called CursorPagination , which is what will be returned by the paginator in the above example This will also generate the corresponding OpenAPI documentation. If you require async logic, you can implement the AbstractAsyncCursorPaginator instead of the AbstractSyncCursorPaginator .","title":"Pagination"},{"location":"usage/5-responses/12-pagination/#pagination","text":"When you need to return a large number of items from an endpoint it is common practice to use pagination to ensure clients can request a specific subset or \"page\" from the total dataset. Starlite supports three types of pagination out of the box: classic pagination limit / offset pagination cursor pagination","title":"Pagination"},{"location":"usage/5-responses/12-pagination/#classic-pagination","text":"In classic pagination the dataset is divided into pages of a specific size and the consumer then requests a specific page. Python 3.8+ Python 3.9+ Classic Pagination from typing import List from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncClassicPaginator , ClassicPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items' # we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory. class PersonClassicPaginator ( AbstractSyncClassicPaginator [ Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_total ( self , page_size : int ) -> int : return round ( len ( self . data ) / page_size ) def get_items ( self , page_size : int , current_page : int ) -> List [ Person ]: return [ self . data [ i : i + page_size ] for i in range ( 0 , len ( self . data ), page_size )][ current_page - 1 ] paginator = PersonClassicPaginator () # we now create a regular handler. The handler will receive two query parameters - 'page_size' and 'current_page', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( page_size : int , current_page : int ) -> ClassicPagination [ Person ]: return paginator ( page_size = page_size , current_page = current_page ) app = Starlite ( route_handlers = [ people_handler ]) Classic Pagination from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncClassicPaginator , ClassicPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items' # we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory. class PersonClassicPaginator ( AbstractSyncClassicPaginator [ Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_total ( self , page_size : int ) -> int : return round ( len ( self . data ) / page_size ) def get_items ( self , page_size : int , current_page : int ) -> list [ Person ]: return [ self . data [ i : i + page_size ] for i in range ( 0 , len ( self . data ), page_size )][ current_page - 1 ] paginator = PersonClassicPaginator () # we now create a regular handler. The handler will receive two query parameters - 'page_size' and 'current_page', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( page_size : int , current_page : int ) -> ClassicPagination [ Person ]: return paginator ( page_size = page_size , current_page = current_page ) app = Starlite ( route_handlers = [ people_handler ]) The data container for this pagination is called ClassicPagination , which is what will be returned by the paginator in the above example This will also generate the corresponding OpenAPI documentation. If you require async logic, you can implement the AbstractAsyncClassicPaginator instead of the AbstractSyncClassicPaginator .","title":"Classic Pagination"},{"location":"usage/5-responses/12-pagination/#offset-pagination","text":"In offset pagination the consumer requests a number of items specified by limit and the offset from the beginning of the dataset. For example, given a list of 50 items, you could request limit=10 , offset=39 to request items 40-50. Python 3.8+ Python 3.9+ Offset Pagination from itertools import islice from typing import List from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncOffsetPaginator , OffsetPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items' # we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory. class PersonOffsetPaginator ( AbstractSyncOffsetPaginator [ Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_total ( self ) -> int : return len ( self . data ) def get_items ( self , limit : int , offset : int ) -> List [ Person ]: return list ( islice ( islice ( self . data , offset , None ), limit )) paginator = PersonOffsetPaginator () # we now create a regular handler. The handler will receive two query parameters - 'limit' and 'offset', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( limit : int , offset : int ) -> OffsetPagination [ Person ]: return paginator ( limit = limit , offset = offset ) app = Starlite ( route_handlers = [ people_handler ]) Offset Pagination from itertools import islice from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncOffsetPaginator , OffsetPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement two methods 'get_total' and 'get_items' # we would usually use a database for this, but for our case we will \"fake\" the dataset using a factory. class PersonOffsetPaginator ( AbstractSyncOffsetPaginator [ Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_total ( self ) -> int : return len ( self . data ) def get_items ( self , limit : int , offset : int ) -> list [ Person ]: return list ( islice ( islice ( self . data , offset , None ), limit )) paginator = PersonOffsetPaginator () # we now create a regular handler. The handler will receive two query parameters - 'limit' and 'offset', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( limit : int , offset : int ) -> OffsetPagination [ Person ]: return paginator ( limit = limit , offset = offset ) app = Starlite ( route_handlers = [ people_handler ]) The data container for this pagination is called OffsetPagination , which is what will be returned by the paginator in the above example This will also generate the corresponding OpenAPI documentation. If you require async logic, you can implement the AbstractAsyncOffsetPaginator instead of the AbstractSyncOffsetPaginator .","title":"Offset Pagination"},{"location":"usage/5-responses/12-pagination/#cursor-pagination","text":"In cursor pagination the consumer requests a number of items specified by results_per_page and a cursor after which results are given. Cursor is unique identifier within the dataset that serves as a way to point the starting position. Python 3.8+ Python 3.9+ Python 3.10+ Cursor Pagination from typing import List , Optional , Tuple from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncCursorPaginator , CursorPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement the method 'get_items'. class PersonCursorPaginator ( AbstractSyncCursorPaginator [ str , Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_items ( self , cursor : Optional [ str ], results_per_page : int ) -> Tuple [ List [ Person ], Optional [ str ]]: results = self . data [: results_per_page ] return results , results [ - 1 ] . id paginator = PersonCursorPaginator () # we now create a regular handler. The handler will receive a single query parameter - 'cursor', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( cursor : Optional [ str ], results_per_page : int ) -> CursorPagination [ str , Person ]: return paginator ( cursor = cursor , results_per_page = results_per_page ) app = Starlite ( route_handlers = [ people_handler ]) Cursor Pagination from typing import Optional from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncCursorPaginator , CursorPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement the method 'get_items'. class PersonCursorPaginator ( AbstractSyncCursorPaginator [ str , Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_items ( self , cursor : Optional [ str ], results_per_page : int ) -> tuple [ list [ Person ], Optional [ str ]]: results = self . data [: results_per_page ] return results , results [ - 1 ] . id paginator = PersonCursorPaginator () # we now create a regular handler. The handler will receive a single query parameter - 'cursor', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( cursor : Optional [ str ], results_per_page : int ) -> CursorPagination [ str , Person ]: return paginator ( cursor = cursor , results_per_page = results_per_page ) app = Starlite ( route_handlers = [ people_handler ]) Cursor Pagination from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite import AbstractSyncCursorPaginator , CursorPagination , Starlite , get class Person ( BaseModel ): id : str name : str class PersonFactory ( ModelFactory [ Person ]): __model__ = Person # we will implement a paginator - the paginator must implement the method 'get_items'. class PersonCursorPaginator ( AbstractSyncCursorPaginator [ str , Person ]): def __init__ ( self ) -> None : self . data = PersonFactory . batch ( 50 ) def get_items ( self , cursor : str | None , results_per_page : int ) -> tuple [ list [ Person ], str | None ]: results = self . data [: results_per_page ] return results , results [ - 1 ] . id paginator = PersonCursorPaginator () # we now create a regular handler. The handler will receive a single query parameter - 'cursor', which # we will pass to the paginator. @get ( \"/people\" ) def people_handler ( cursor : str | None , results_per_page : int ) -> CursorPagination [ str , Person ]: return paginator ( cursor = cursor , results_per_page = results_per_page ) app = Starlite ( route_handlers = [ people_handler ]) The data container for this pagination is called CursorPagination , which is what will be returned by the paginator in the above example This will also generate the corresponding OpenAPI documentation. If you require async logic, you can implement the AbstractAsyncCursorPaginator instead of the AbstractSyncCursorPaginator .","title":"Cursor Pagination"},{"location":"usage/5-responses/2-status-codes/","text":"Status Codes You can control the response status_code by setting the corresponding kwarg to the desired value: from pydantic import BaseModel from starlite import get from starlite.status_codes import HTTP_202_ACCEPTED class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , status_code = HTTP_202_ACCEPTED ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" ) If status_code is not set by the user, the following defaults are used: POST: 201 (Created) DELETE: 204 (No Content) GET, PATCH, PUT: 200 (Ok) Important For status codes < 100 or 204, 304 statuses, no response body is allowed. If you specify a return annotation other than None , an ImproperlyConfiguredException will be raised. Note When using the route decorator with multiple http methods, the default status code is 200 . Note The default for delete is 204 because by default it is assumed that delete operations return no data. This though might not be the case in your implementation - so take care of setting it as you see fit. Tip While you can write integers as the value for status_code , e.g. 200 , it's best practice to use constants (also in tests). Starlite includes easy to use statuses that are exported from starlite.status_codes , e.g. HTTP_200_OK and HTTP_201_CREATED . Another option is the http.HTTPStatus enum from the standard library, which also offers extra functionality. For this see the standard library documentation .","title":"Status Codes"},{"location":"usage/5-responses/2-status-codes/#status-codes","text":"You can control the response status_code by setting the corresponding kwarg to the desired value: from pydantic import BaseModel from starlite import get from starlite.status_codes import HTTP_202_ACCEPTED class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , status_code = HTTP_202_ACCEPTED ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" ) If status_code is not set by the user, the following defaults are used: POST: 201 (Created) DELETE: 204 (No Content) GET, PATCH, PUT: 200 (Ok) Important For status codes < 100 or 204, 304 statuses, no response body is allowed. If you specify a return annotation other than None , an ImproperlyConfiguredException will be raised. Note When using the route decorator with multiple http methods, the default status code is 200 . Note The default for delete is 204 because by default it is assumed that delete operations return no data. This though might not be the case in your implementation - so take care of setting it as you see fit. Tip While you can write integers as the value for status_code , e.g. 200 , it's best practice to use constants (also in tests). Starlite includes easy to use statuses that are exported from starlite.status_codes , e.g. HTTP_200_OK and HTTP_201_CREATED . Another option is the http.HTTPStatus enum from the standard library, which also offers extra functionality. For this see the standard library documentation .","title":"Status Codes"},{"location":"usage/5-responses/3-returning-responses/","text":"Returning Responses While the default response handling fits most use cases, in some cases you need to be able to return a response instance directly. Starlite allows you to return any class inheriting from the Response class. Thus, the below example will work perfectly fine: from pydantic import BaseModel from starlite import Response , Starlite , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"MY-HEADER\" : \"xyz\" }, cookies = [ Cookie ( key = \"my-cookie\" , value = \"abc\" )], ) app = Starlite ( route_handlers = [ retrieve_resource ]) Important In the case of the builtin TemplateResponse , FileResponse , StreamingResponse and RedirectResponse you should use the response \"response containers\", otherwise OpenAPI documentation will not be generated correctly. For more details see the respective documentation sections for the Template , File , Stream and Redirect . Annotating Responses As you can see above, the Response class accepts a generic argument. This allows Starlite to infer the response body when generating the OpenAPI docs. Note If the generic argument is not provided, and thus defaults to Any , the OpenAPI docs will be imprecise. So make sure to type this argument even when returning an empty or null body, i.e. use None . Returning ASGI Applications Starlite also supports returning ASGI applications directly, as you would responses. For example: from starlite import get from starlite.types import ASGIApp , Receive , Scope , Send @get ( \"/\" ) def handler () -> ASGIApp : async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : ... return my_asgi_app What is an ASGI Application? An ASGI application in this context is any async callable (function, class method or simply a class that implements that special __call__ dunder method) that accepts the three ASGI arguments: scope , receive and send . For example, all the following examples are ASGI applications: Function ASGI Application from starlite.types import Receive , Scope , Send async def my_asgi_app_function ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... Method ASGI Application from starlite.types import Receive , Scope , Send class MyClass : async def my_asgi_app_method ( self , scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... Class ASGI Application from starlite.types import Receive , Scope , Send class ASGIApp : async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... Returning Other Library Responses Because you can return any ASGI Application from a route handler, you can also use any ASGI application from other libraries. For example, you can return the response classes from Starlette or FastAPI directly from route handlers: from starlette.responses import JSONResponse from starlite import get from starlite.types import ASGIApp @get ( \"/\" ) def handler () -> ASGIApp : return JSONResponse ( content = { \"hello\" : \"world\" }) # type: ignore Important Starlite offers strong typing for the ASGI arguments. Other libraries often offer less strict typing, which might cause type checkers to complain when using ASGI apps from them inside Starlite. For the time being, the only solution is to add # type: ignore comments in the pertinent places. Nonetheless, the above example will work perfectly fine.","title":"Returning Responses"},{"location":"usage/5-responses/3-returning-responses/#returning-responses","text":"While the default response handling fits most use cases, in some cases you need to be able to return a response instance directly. Starlite allows you to return any class inheriting from the Response class. Thus, the below example will work perfectly fine: from pydantic import BaseModel from starlite import Response , Starlite , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"MY-HEADER\" : \"xyz\" }, cookies = [ Cookie ( key = \"my-cookie\" , value = \"abc\" )], ) app = Starlite ( route_handlers = [ retrieve_resource ]) Important In the case of the builtin TemplateResponse , FileResponse , StreamingResponse and RedirectResponse you should use the response \"response containers\", otherwise OpenAPI documentation will not be generated correctly. For more details see the respective documentation sections for the Template , File , Stream and Redirect .","title":"Returning Responses"},{"location":"usage/5-responses/3-returning-responses/#annotating-responses","text":"As you can see above, the Response class accepts a generic argument. This allows Starlite to infer the response body when generating the OpenAPI docs. Note If the generic argument is not provided, and thus defaults to Any , the OpenAPI docs will be imprecise. So make sure to type this argument even when returning an empty or null body, i.e. use None .","title":"Annotating Responses"},{"location":"usage/5-responses/3-returning-responses/#returning-asgi-applications","text":"Starlite also supports returning ASGI applications directly, as you would responses. For example: from starlite import get from starlite.types import ASGIApp , Receive , Scope , Send @get ( \"/\" ) def handler () -> ASGIApp : async def my_asgi_app ( scope : Scope , receive : Receive , send : Send ) -> None : ... return my_asgi_app","title":"Returning ASGI Applications"},{"location":"usage/5-responses/3-returning-responses/#what-is-an-asgi-application","text":"An ASGI application in this context is any async callable (function, class method or simply a class that implements that special __call__ dunder method) that accepts the three ASGI arguments: scope , receive and send . For example, all the following examples are ASGI applications:","title":"What is an ASGI Application?"},{"location":"usage/5-responses/3-returning-responses/#function-asgi-application","text":"from starlite.types import Receive , Scope , Send async def my_asgi_app_function ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ...","title":"Function ASGI Application"},{"location":"usage/5-responses/3-returning-responses/#method-asgi-application","text":"from starlite.types import Receive , Scope , Send class MyClass : async def my_asgi_app_method ( self , scope : Scope , receive : Receive , send : Send ) -> None : # do something here ...","title":"Method ASGI Application"},{"location":"usage/5-responses/3-returning-responses/#class-asgi-application","text":"from starlite.types import Receive , Scope , Send class ASGIApp : async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : # do something here ...","title":"Class ASGI Application"},{"location":"usage/5-responses/3-returning-responses/#returning-other-library-responses","text":"Because you can return any ASGI Application from a route handler, you can also use any ASGI application from other libraries. For example, you can return the response classes from Starlette or FastAPI directly from route handlers: from starlette.responses import JSONResponse from starlite import get from starlite.types import ASGIApp @get ( \"/\" ) def handler () -> ASGIApp : return JSONResponse ( content = { \"hello\" : \"world\" }) # type: ignore Important Starlite offers strong typing for the ASGI arguments. Other libraries often offer less strict typing, which might cause type checkers to complain when using ASGI apps from them inside Starlite. For the time being, the only solution is to add # type: ignore comments in the pertinent places. Nonetheless, the above example will work perfectly fine.","title":"Returning Other Library Responses"},{"location":"usage/5-responses/4-response-headers/","text":"Response Headers Starlite allows you to define response headers by using the response_headers kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself: from starlite import Controller , MediaType , Router , Starlite , get from starlite.datastructures import ResponseHeader class MyController ( Controller ): path = \"/controller-path\" response_headers = { \"controller-level-header\" : ResponseHeader ( value = \"controller header\" , description = \"controller level header\" ) } @get ( path = \"/handler-path\" , response_headers = { \"my-local-header\" : ResponseHeader ( value = \"local header\" , description = \"local level header\" )}, media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" router = Router ( path = \"/router-path\" , route_handlers = [ MyController ], response_headers = { \"router-level-header\" : ResponseHeader ( value = \"router header\" , description = \"router level header\" )}, ) app = Starlite ( route_handlers = [ router ], response_headers = { \"app-level-header\" : ResponseHeader ( value = \"app header\" , description = \"app level header\" )}, ) In the above example the response returned from my_route_handler will have headers set from each layer of the application using the given key+value combinations. I.e. it will be a dictionary equal to this: { \"my-local-header\" : \"local header\" , \"controller-level-header\" : \"controller header\" , \"router-level-header\" : \"router header\" , \"app-level-header\" : \"app header\" } The respective descriptions will be used for the OpenAPI documentation. Dynamic Headers The above detailed scheme works great for statically configured headers, but how would you go about handling dynamically setting headers? Starlite allows you to set headers dynamically in several ways and below we will detail the two primary patterns. Setting Response Headers Using Annotated Responses We can simply return a response instance directly from the route handler and set the headers dictionary manually as you see fit, e.g.: from random import randint from pydantic import BaseModel from starlite import Response , Starlite , get from starlite.datastructures import ResponseHeader class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 1 , 100 ))}, ) app = Starlite ( route_handlers = [ retrieve_resource ]) In the above we use the response_headers kwarg to pass the name and description parameters for the Random-Header to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a value for it and we designate it as documentation_only=True . Setting Response Headers Using the After Request Hook An alternative pattern would be to use an after request handler . We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the headers on the corresponding layer: In the above we set the response header using an after_request_handler function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router. We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding header specification as required. For example, lets say we have a router level header being set and a local header with the same key but a different value range: from random import randint from pydantic import BaseModel from starlite import Response , Router , Starlite , get from starlite.datastructures import ResponseHeader class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 100 , 1000 ))}, ) def after_request_handler ( response : Response ) -> Response : response . headers . update ({ \"Random-Header\" : str ( randint ( 1 , 100 ))}) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) app = Starlite ( route_handlers = [ router ]) Specific Headers Implementation Starlite has a dedicated implementation for a few headers that are commonly used. These headers can be set separately with dedicated keyword arguments or as class attributes on all layers of the app (individual route handlers, controllers, routers and the app itself). Each layer overrides the layer above it - thus, the headers defined for a specific route handler will override those defined on its router, which will in turn override those defined on the app level. These header implementations allow easy creating, serialization and parsing according to the associated header specifications. Cache Control CacheControlHeader represents a Cache-Control Header . Here is a simple example that shows how to use it: Cache Control Header import time from starlite import Controller , Starlite , get from starlite.datastructures import CacheControlHeader class MyController ( Controller ): cache_control = CacheControlHeader ( max_age = 86_400 , public = True ) @get ( \"/chance_of_rain\" ) def get_chance_of_rain ( self ) -> float : \"\"\"This endpoint uses the cache control value defined in the controller which overrides the app value.\"\"\" return 0.5 @get ( \"/timestamp\" , cache_control = CacheControlHeader ( no_store = True )) def get_server_time ( self ) -> float : \"\"\"This endpoint overrides the cache control value defined in the controller.\"\"\" return time . time () @get ( \"/population\" ) def get_population_count () -> int : \"\"\"This endpoint will use the cache control defined in the app.\"\"\" return 100000 app = Starlite ( route_handlers = [ MyController , get_population_count ], cache_control = CacheControlHeader ( max_age = 2_628_288 , public = True ), ) In this example we have a cache-control with max-age of 1 month for the whole app, a max-age of 1 day for all routes within MyController and no-store for one specific route get_server_time . Here are the cache control values that will be returned from each endpoint: When calling /population the response will have cache-control with max-age=2628288 (1 month). When calling /chance_of_rain the response will have cache-control with max-age=86400 (1 day). When calling /timestamp the response will have cache-control with no-store which means don't store the result in any cache. ETag ETag represents an ETag header . Here are some usage examples: Returning ETag headers import random import time from starlite import Controller , Starlite , get from starlite.datastructures import ETag from starlite.enums import MediaType from starlite.response import Response class MyController ( Controller ): etag = ETag ( value = \"foo\" ) @get ( \"/chance_of_rain\" ) def get_chance_of_rain ( self ) -> float : \"\"\"This endpoint uses the etag value in the controller which overrides the app value. The returned header will be `etag: \"foo\"` \"\"\" return 0.5 @get ( \"/timestamp\" , etag = ETag ( value = \"bar\" )) def get_server_time ( self ) -> float : \"\"\"This endpoint overrides the etag defined in the controller. The returned header will be `etag: W/\"bar\"` \"\"\" return time . time () @get ( \"/population\" ) def get_population_count () -> int : \"\"\"This endpoint will use the etag defined in the app. The returned header will be `etag: \"bar\"` \"\"\" return 100000 @get ( \"/population-dynamic\" , etag = ETag ( documentation_only = True )) def get_population_count_dynamic () -> Response [ str ]: \"\"\"The etag defined in this route handler will not be returned, and does not need a value. It will only be used for OpenAPI generation. \"\"\" population_count = random . randint ( 0 , 1000 ) return Response ( content = str ( population_count ), headers = { \"etag\" : ETag ( value = str ( population_count ))}, media_type = MediaType . TEXT , status_code = 200 , ) app = Starlite ( route_handlers = [ MyController , get_population_count ], etag = ETag ( value = \"bar\" )) Parsing ETag heaers from starlite.datastructures import ETag assert ETag . from_header ( '\"foo\"' ) == ETag ( value = \"foo\" ) assert ETag . from_header ( 'W/\"foo\"' ) == ETag ( value = \"foo\" , weak = True )","title":"Response Headers"},{"location":"usage/5-responses/4-response-headers/#response-headers","text":"Starlite allows you to define response headers by using the response_headers kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself: from starlite import Controller , MediaType , Router , Starlite , get from starlite.datastructures import ResponseHeader class MyController ( Controller ): path = \"/controller-path\" response_headers = { \"controller-level-header\" : ResponseHeader ( value = \"controller header\" , description = \"controller level header\" ) } @get ( path = \"/handler-path\" , response_headers = { \"my-local-header\" : ResponseHeader ( value = \"local header\" , description = \"local level header\" )}, media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" router = Router ( path = \"/router-path\" , route_handlers = [ MyController ], response_headers = { \"router-level-header\" : ResponseHeader ( value = \"router header\" , description = \"router level header\" )}, ) app = Starlite ( route_handlers = [ router ], response_headers = { \"app-level-header\" : ResponseHeader ( value = \"app header\" , description = \"app level header\" )}, ) In the above example the response returned from my_route_handler will have headers set from each layer of the application using the given key+value combinations. I.e. it will be a dictionary equal to this: { \"my-local-header\" : \"local header\" , \"controller-level-header\" : \"controller header\" , \"router-level-header\" : \"router header\" , \"app-level-header\" : \"app header\" } The respective descriptions will be used for the OpenAPI documentation.","title":"Response Headers"},{"location":"usage/5-responses/4-response-headers/#dynamic-headers","text":"The above detailed scheme works great for statically configured headers, but how would you go about handling dynamically setting headers? Starlite allows you to set headers dynamically in several ways and below we will detail the two primary patterns.","title":"Dynamic Headers"},{"location":"usage/5-responses/4-response-headers/#setting-response-headers-using-annotated-responses","text":"We can simply return a response instance directly from the route handler and set the headers dictionary manually as you see fit, e.g.: from random import randint from pydantic import BaseModel from starlite import Response , Starlite , get from starlite.datastructures import ResponseHeader class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 1 , 100 ))}, ) app = Starlite ( route_handlers = [ retrieve_resource ]) In the above we use the response_headers kwarg to pass the name and description parameters for the Random-Header to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a value for it and we designate it as documentation_only=True .","title":"Setting Response Headers Using Annotated Responses"},{"location":"usage/5-responses/4-response-headers/#setting-response-headers-using-the-after-request-hook","text":"An alternative pattern would be to use an after request handler . We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the headers on the corresponding layer: In the above we set the response header using an after_request_handler function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router. We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding header specification as required. For example, lets say we have a router level header being set and a local header with the same key but a different value range: from random import randint from pydantic import BaseModel from starlite import Response , Router , Starlite , get from starlite.datastructures import ResponseHeader class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) }, ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), headers = { \"Random-Header\" : str ( randint ( 100 , 1000 ))}, ) def after_request_handler ( response : Response ) -> Response : response . headers . update ({ \"Random-Header\" : str ( randint ( 1 , 100 ))}) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_headers = { \"Random-Header\" : ResponseHeader ( description = \"a random number in the range 1 - 100\" , documentation_only = True ) }, ) app = Starlite ( route_handlers = [ router ])","title":"Setting Response Headers Using the After Request Hook"},{"location":"usage/5-responses/4-response-headers/#specific-headers-implementation","text":"Starlite has a dedicated implementation for a few headers that are commonly used. These headers can be set separately with dedicated keyword arguments or as class attributes on all layers of the app (individual route handlers, controllers, routers and the app itself). Each layer overrides the layer above it - thus, the headers defined for a specific route handler will override those defined on its router, which will in turn override those defined on the app level. These header implementations allow easy creating, serialization and parsing according to the associated header specifications.","title":"Specific Headers Implementation"},{"location":"usage/5-responses/4-response-headers/#cache-control","text":"CacheControlHeader represents a Cache-Control Header . Here is a simple example that shows how to use it: Cache Control Header import time from starlite import Controller , Starlite , get from starlite.datastructures import CacheControlHeader class MyController ( Controller ): cache_control = CacheControlHeader ( max_age = 86_400 , public = True ) @get ( \"/chance_of_rain\" ) def get_chance_of_rain ( self ) -> float : \"\"\"This endpoint uses the cache control value defined in the controller which overrides the app value.\"\"\" return 0.5 @get ( \"/timestamp\" , cache_control = CacheControlHeader ( no_store = True )) def get_server_time ( self ) -> float : \"\"\"This endpoint overrides the cache control value defined in the controller.\"\"\" return time . time () @get ( \"/population\" ) def get_population_count () -> int : \"\"\"This endpoint will use the cache control defined in the app.\"\"\" return 100000 app = Starlite ( route_handlers = [ MyController , get_population_count ], cache_control = CacheControlHeader ( max_age = 2_628_288 , public = True ), ) In this example we have a cache-control with max-age of 1 month for the whole app, a max-age of 1 day for all routes within MyController and no-store for one specific route get_server_time . Here are the cache control values that will be returned from each endpoint: When calling /population the response will have cache-control with max-age=2628288 (1 month). When calling /chance_of_rain the response will have cache-control with max-age=86400 (1 day). When calling /timestamp the response will have cache-control with no-store which means don't store the result in any cache.","title":"Cache Control"},{"location":"usage/5-responses/4-response-headers/#etag","text":"ETag represents an ETag header . Here are some usage examples: Returning ETag headers import random import time from starlite import Controller , Starlite , get from starlite.datastructures import ETag from starlite.enums import MediaType from starlite.response import Response class MyController ( Controller ): etag = ETag ( value = \"foo\" ) @get ( \"/chance_of_rain\" ) def get_chance_of_rain ( self ) -> float : \"\"\"This endpoint uses the etag value in the controller which overrides the app value. The returned header will be `etag: \"foo\"` \"\"\" return 0.5 @get ( \"/timestamp\" , etag = ETag ( value = \"bar\" )) def get_server_time ( self ) -> float : \"\"\"This endpoint overrides the etag defined in the controller. The returned header will be `etag: W/\"bar\"` \"\"\" return time . time () @get ( \"/population\" ) def get_population_count () -> int : \"\"\"This endpoint will use the etag defined in the app. The returned header will be `etag: \"bar\"` \"\"\" return 100000 @get ( \"/population-dynamic\" , etag = ETag ( documentation_only = True )) def get_population_count_dynamic () -> Response [ str ]: \"\"\"The etag defined in this route handler will not be returned, and does not need a value. It will only be used for OpenAPI generation. \"\"\" population_count = random . randint ( 0 , 1000 ) return Response ( content = str ( population_count ), headers = { \"etag\" : ETag ( value = str ( population_count ))}, media_type = MediaType . TEXT , status_code = 200 , ) app = Starlite ( route_handlers = [ MyController , get_population_count ], etag = ETag ( value = \"bar\" )) Parsing ETag heaers from starlite.datastructures import ETag assert ETag . from_header ( '\"foo\"' ) == ETag ( value = \"foo\" ) assert ETag . from_header ( 'W/\"foo\"' ) == ETag ( value = \"foo\" , weak = True )","title":"ETag"},{"location":"usage/5-responses/5-response-cookies/","text":"Response Cookies Starlite allows you to define response cookies by using the response_cookies kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself: from starlite import Controller , MediaType , Router , Starlite , get from starlite.datastructures import Cookie class MyController ( Controller ): path = \"/controller-path\" response_cookies = [ Cookie ( key = \"controller-cookie\" , value = \"controller value\" , description = \"controller level cookie\" , ) ] @get ( path = \"/\" , response_cookies = [ Cookie ( key = \"local-cookie\" , value = \"local value\" , description = \"route handler level cookie\" , ) ], media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" router = Router ( path = \"/router-path\" , route_handlers = [ MyController ], response_cookies = [ Cookie ( key = \"router-cookie\" , value = \"router value\" , description = \"router level cookie\" )], ) app = Starlite ( route_handlers = [ router ], response_cookies = [ Cookie ( key = \"app-cookie\" , value = \"app value\" , description = \"app level cookie\" )], ) In the above example, the response returned by my_route_handler will have cookies set by each layer of the application. Cookies are set using the Set-Cookie header and with above resulting in: Set-Cookie: local-cookie=local value; Path=/; SameSite=lax Set-Cookie: controller-cookie=controller value; Path=/; SameSite=lax Set-Cookie: router-cookie=router value; Path=/; SameSite=lax Set-Cookie: app-cookie=app value; Path=/; SameSite=lax You can easily override cookies declared in higher levels by re-declaring a cookie with the same key in a lower level, e.g.: from starlite import Controller , MediaType , Starlite , get from starlite.datastructures import Cookie class MyController ( Controller ): path = \"/controller-path\" response_cookies = [ Cookie ( key = \"my-cookie\" , value = \"123\" )] @get ( path = \"/\" , response_cookies = [ Cookie ( key = \"my-cookie\" , value = \"456\" )], media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" app = Starlite ( route_handlers = [ MyController ]) Of the two declarations of my-cookie only the route handler one will be used, because its lower level: Set-Cookie: my-cookie=456; Path=/; SameSite=lax The Cookie Class Starlite exports the class starlite.datastructures.Cookie . This is a pydantic model that allows you to define a cookie. See the API Reference for full details on the Cookie class and the kwargs it accepts. Dynamic Cookies While the above scheme works great for static cookie values, it doesn't allow for dynamic cookies. Because cookies are fundamentally a type of response header, we can utilize the same patterns we use for setting dynamic headers also here. Setting Response Cookies Using Annotated Responses We can simply return a response instance directly from the route handler and set the cookies list manually as you see fit, e.g.: from random import randint from pydantic import BaseModel from starlite import Response , Starlite , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), cookies = [ Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 )))], ) app = Starlite ( route_handlers = [ retrieve_resource ]) In the above we use the response_cookies kwarg to pass the key and description parameters for the Random-Header to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a value for it and we designate it as documentation_only=True . Setting Response Cookies Using the After Request Hook An alternative pattern would be to use an after request handler . We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the cookies on the corresponding layer: from random import randint from pydantic import BaseModel from starlite import Response , Router , Starlite , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" , ) def after_request_handler ( response : Response ) -> Response : response . set_cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 ))) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) app = Starlite ( route_handlers = [ router ]) In the above we set the cookie using an after_request_handler function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router. We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding cookie specification as required. For example, lets say we have a router level cookie being set and a local cookie with the same key but a different value range: from random import randint from pydantic import BaseModel from starlite import Response , Router , Starlite , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) ], ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), cookies = [ Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 100 , 1000 )))], ) def after_request_handler ( response : Response ) -> Response : response . set_cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 ))) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) app = Starlite ( route_handlers = [ router ])","title":"Response Cookies"},{"location":"usage/5-responses/5-response-cookies/#response-cookies","text":"Starlite allows you to define response cookies by using the response_cookies kwarg. This kwarg is available on all layers of the app - individual route handlers, controllers, routers and the app itself: from starlite import Controller , MediaType , Router , Starlite , get from starlite.datastructures import Cookie class MyController ( Controller ): path = \"/controller-path\" response_cookies = [ Cookie ( key = \"controller-cookie\" , value = \"controller value\" , description = \"controller level cookie\" , ) ] @get ( path = \"/\" , response_cookies = [ Cookie ( key = \"local-cookie\" , value = \"local value\" , description = \"route handler level cookie\" , ) ], media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" router = Router ( path = \"/router-path\" , route_handlers = [ MyController ], response_cookies = [ Cookie ( key = \"router-cookie\" , value = \"router value\" , description = \"router level cookie\" )], ) app = Starlite ( route_handlers = [ router ], response_cookies = [ Cookie ( key = \"app-cookie\" , value = \"app value\" , description = \"app level cookie\" )], ) In the above example, the response returned by my_route_handler will have cookies set by each layer of the application. Cookies are set using the Set-Cookie header and with above resulting in: Set-Cookie: local-cookie=local value; Path=/; SameSite=lax Set-Cookie: controller-cookie=controller value; Path=/; SameSite=lax Set-Cookie: router-cookie=router value; Path=/; SameSite=lax Set-Cookie: app-cookie=app value; Path=/; SameSite=lax You can easily override cookies declared in higher levels by re-declaring a cookie with the same key in a lower level, e.g.: from starlite import Controller , MediaType , Starlite , get from starlite.datastructures import Cookie class MyController ( Controller ): path = \"/controller-path\" response_cookies = [ Cookie ( key = \"my-cookie\" , value = \"123\" )] @get ( path = \"/\" , response_cookies = [ Cookie ( key = \"my-cookie\" , value = \"456\" )], media_type = MediaType . TEXT , ) def my_route_handler ( self ) -> str : return \"hello world\" app = Starlite ( route_handlers = [ MyController ]) Of the two declarations of my-cookie only the route handler one will be used, because its lower level: Set-Cookie: my-cookie=456; Path=/; SameSite=lax","title":"Response Cookies"},{"location":"usage/5-responses/5-response-cookies/#the-cookie-class","text":"Starlite exports the class starlite.datastructures.Cookie . This is a pydantic model that allows you to define a cookie. See the API Reference for full details on the Cookie class and the kwargs it accepts.","title":"The Cookie Class"},{"location":"usage/5-responses/5-response-cookies/#dynamic-cookies","text":"While the above scheme works great for static cookie values, it doesn't allow for dynamic cookies. Because cookies are fundamentally a type of response header, we can utilize the same patterns we use for setting dynamic headers also here.","title":"Dynamic Cookies"},{"location":"usage/5-responses/5-response-cookies/#setting-response-cookies-using-annotated-responses","text":"We can simply return a response instance directly from the route handler and set the cookies list manually as you see fit, e.g.: from random import randint from pydantic import BaseModel from starlite import Response , Starlite , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), cookies = [ Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 )))], ) app = Starlite ( route_handlers = [ retrieve_resource ]) In the above we use the response_cookies kwarg to pass the key and description parameters for the Random-Header to the OpenAPI documentation, but we set the value dynamically in as part of the annotated response we return. To this end we do not set a value for it and we designate it as documentation_only=True .","title":"Setting Response Cookies Using Annotated Responses"},{"location":"usage/5-responses/5-response-cookies/#setting-response-cookies-using-the-after-request-hook","text":"An alternative pattern would be to use an after request handler . We can define the handler on different layers of the application as explained in the pertinent docs. We should take care to document the cookies on the corresponding layer: from random import randint from pydantic import BaseModel from starlite import Response , Router , Starlite , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" ) def retrieve_resource () -> Resource : return Resource ( id = 1 , name = \"my resource\" , ) def after_request_handler ( response : Response ) -> Response : response . set_cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 ))) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) app = Starlite ( route_handlers = [ router ]) In the above we set the cookie using an after_request_handler function on the router level. Because the handler function is applied on the router, we also set the documentation for it on the router. We can use this pattern to fine-tune the OpenAPI documentation more granularly by overriding cookie specification as required. For example, lets say we have a router level cookie being set and a local cookie with the same key but a different value range: from random import randint from pydantic import BaseModel from starlite import Response , Router , Starlite , get from starlite.datastructures import Cookie class Resource ( BaseModel ): id : int name : str @get ( \"/resources\" , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 100 - 1000\" , documentation_only = True , ) ], ) def retrieve_resource () -> Response [ Resource ]: return Response ( Resource ( id = 1 , name = \"my resource\" , ), cookies = [ Cookie ( key = \"Random-Cookie\" , value = str ( randint ( 100 , 1000 )))], ) def after_request_handler ( response : Response ) -> Response : response . set_cookie ( key = \"Random-Cookie\" , value = str ( randint ( 1 , 100 ))) return response router = Router ( path = \"/router-path\" , route_handlers = [ retrieve_resource ], after_request = after_request_handler , response_cookies = [ Cookie ( key = \"Random-Cookie\" , description = \"a random number in the range 1 - 100\" , documentation_only = True , ) ], ) app = Starlite ( route_handlers = [ router ])","title":"Setting Response Cookies Using the After Request Hook"},{"location":"usage/5-responses/6-redirect-responses/","text":"Redirect Responses Redirect responses are special HTTP responses with a status code in the 30x range. In Starlite, a redirect response looks like this: from starlite.status_codes import HTTP_307_TEMPORARY_REDIRECT from starlite import Redirect , get @get ( path = \"/some-path\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) def redirect () -> Redirect : # do some stuff here # ... # finally return redirect return Redirect ( path = \"/other-path\" ) To return a redirect response you should do the following: set an appropriate status code for the route handler (301, 302, 303, 307, 308) annotate the return value of the route handler as returning Redirect return an instance of the Redirect class with the desired redirect path The Redirect Class Redirect is a container class used to generate redirect responses and their respective OpenAPI documentation. See the API Reference for full details on the Redirect class and the kwargs it accepts.","title":"Redirect Responses"},{"location":"usage/5-responses/6-redirect-responses/#redirect-responses","text":"Redirect responses are special HTTP responses with a status code in the 30x range. In Starlite, a redirect response looks like this: from starlite.status_codes import HTTP_307_TEMPORARY_REDIRECT from starlite import Redirect , get @get ( path = \"/some-path\" , status_code = HTTP_307_TEMPORARY_REDIRECT ) def redirect () -> Redirect : # do some stuff here # ... # finally return redirect return Redirect ( path = \"/other-path\" ) To return a redirect response you should do the following: set an appropriate status code for the route handler (301, 302, 303, 307, 308) annotate the return value of the route handler as returning Redirect return an instance of the Redirect class with the desired redirect path","title":"Redirect Responses"},{"location":"usage/5-responses/6-redirect-responses/#the-redirect-class","text":"Redirect is a container class used to generate redirect responses and their respective OpenAPI documentation. See the API Reference for full details on the Redirect class and the kwargs it accepts.","title":"The Redirect Class"},{"location":"usage/5-responses/7-file-responses/","text":"File Responses File responses send a file: from pathlib import Path from starlite import File , get @get ( path = \"/file-download\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File class expects two kwargs: path : path of the file to download. filename : the filename to set in the response Content-Disposition attachment. Important When a route handler's return value is annotated with File , the default media_type for the route_handler is switched from MediaType.JSON to MediaType.TEXT (i.e. \"text/plain\"). If the file being sent has an IANA media type , you should set it as the value for media_type instead. For example: from pathlib import Path from starlite import File , get @get ( path = \"/file-download\" , media_type = \"application/pdf\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File Class File is a container class used to generate file responses and their respective OpenAPI documentation. See the API Reference for full details on the File class and the kwargs it accepts.","title":"File Responses"},{"location":"usage/5-responses/7-file-responses/#file-responses","text":"File responses send a file: from pathlib import Path from starlite import File , get @get ( path = \"/file-download\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , ) The File class expects two kwargs: path : path of the file to download. filename : the filename to set in the response Content-Disposition attachment. Important When a route handler's return value is annotated with File , the default media_type for the route_handler is switched from MediaType.JSON to MediaType.TEXT (i.e. \"text/plain\"). If the file being sent has an IANA media type , you should set it as the value for media_type instead. For example: from pathlib import Path from starlite import File , get @get ( path = \"/file-download\" , media_type = \"application/pdf\" ) def handle_file_download () -> File : return File ( path = Path ( Path ( __file__ ) . resolve () . parent , \"report\" ) . with_suffix ( \".pdf\" ), filename = \"repost.pdf\" , )","title":"File Responses"},{"location":"usage/5-responses/7-file-responses/#the-file-class","text":"File is a container class used to generate file responses and their respective OpenAPI documentation. See the API Reference for full details on the File class and the kwargs it accepts.","title":"The File Class"},{"location":"usage/5-responses/8-streaming-responses/","text":"Streaming Responses To return a streaming response use the Stream class. The Stream class receives a single required kwarg - iterator : Python 3.8+ Python 3.9+ from asyncio import sleep from datetime import datetime from typing import AsyncGenerator from starlite import Starlite , Stream , get from starlite.utils.serialization import encode_json async def my_generator () -> AsyncGenerator [ bytes , None ]: while True : await sleep ( 0.01 ) yield encode_json ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_generator ()) app = Starlite ( route_handlers = [ stream_time ]) from asyncio import sleep from datetime import datetime from collections.abc import AsyncGenerator from starlite import Starlite , Stream , get from starlite.utils.serialization import encode_json async def my_generator () -> AsyncGenerator [ bytes , None ]: while True : await sleep ( 0.01 ) yield encode_json ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_generator ()) app = Starlite ( route_handlers = [ stream_time ]) Note You can use different kinds of values of the iterator keyword - it can be a callable returning a sync or async generator. The generator itself. A sync or async iterator class, or and instance of this class. The Stream Class Stream is a container class used to generate streaming responses and their respective OpenAPI documentation. See the API Reference for full details on the Stream class and the kwargs it accepts.","title":"Streaming Responses"},{"location":"usage/5-responses/8-streaming-responses/#streaming-responses","text":"To return a streaming response use the Stream class. The Stream class receives a single required kwarg - iterator : Python 3.8+ Python 3.9+ from asyncio import sleep from datetime import datetime from typing import AsyncGenerator from starlite import Starlite , Stream , get from starlite.utils.serialization import encode_json async def my_generator () -> AsyncGenerator [ bytes , None ]: while True : await sleep ( 0.01 ) yield encode_json ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_generator ()) app = Starlite ( route_handlers = [ stream_time ]) from asyncio import sleep from datetime import datetime from collections.abc import AsyncGenerator from starlite import Starlite , Stream , get from starlite.utils.serialization import encode_json async def my_generator () -> AsyncGenerator [ bytes , None ]: while True : await sleep ( 0.01 ) yield encode_json ({ \"current_time\" : datetime . now ()}) @get ( path = \"/time\" ) def stream_time () -> Stream : return Stream ( iterator = my_generator ()) app = Starlite ( route_handlers = [ stream_time ]) Note You can use different kinds of values of the iterator keyword - it can be a callable returning a sync or async generator. The generator itself. A sync or async iterator class, or and instance of this class.","title":"Streaming Responses"},{"location":"usage/5-responses/8-streaming-responses/#the-stream-class","text":"Stream is a container class used to generate streaming responses and their respective OpenAPI documentation. See the API Reference for full details on the Stream class and the kwargs it accepts.","title":"The Stream Class"},{"location":"usage/5-responses/9-template-responses/","text":"Template Responses Template responses are used to render templates into HTML. To use a template response you must first register a template engine on the application level. Once an engine is in place, you can use a template response like so: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) In the above Template is passed the template name, which is a path like value, and a context dictionary that maps string keys into values that will be rendered in the template. The Template Class Template is a container class used to generate template responses and their respective OpenAPI documentation. See the API Reference for full details on the Template class and the kwargs it accepts.","title":"Template Responses"},{"location":"usage/5-responses/9-template-responses/#template-responses","text":"Template responses are used to render templates into HTML. To use a template response you must first register a template engine on the application level. Once an engine is in place, you can use a template response like so: from starlite import Template , Request , get @get ( path = \"/info\" ) def info ( request : Request ) -> Template : return Template ( name = \"info.html\" , context = { \"user\" : request . user }) In the above Template is passed the template name, which is a path like value, and a context dictionary that maps string keys into values that will be rendered in the template.","title":"Template Responses"},{"location":"usage/5-responses/9-template-responses/#the-template-class","text":"Template is a container class used to generate template responses and their respective OpenAPI documentation. See the API Reference for full details on the Template class and the kwargs it accepts.","title":"The Template Class"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/","text":"Dependency Injection Starlite has a simple but powerful dependency injection system that allows for declaring dependencies on all layers of the application: from starlite import Controller , Router , Starlite , Provide , get def bool_fn () -> bool : ... def dict_fn () -> dict : ... def list_fn () -> list : ... def int_fn () -> int : ... class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"controller_dependency\" : Provide ( list_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"local_dependency\" : Provide ( int_fn )}) def my_route_handler ( self , app_dependency : bool , router_dependency : dict , controller_dependency : list , local_dependency : int , ) -> None : ... # on the router my_router = Router ( path = \"/router\" , dependencies = { \"router_dependency\" : Provide ( dict_fn )}, route_handlers = [ MyController ], ) # on the app app = Starlite ( route_handlers = [ my_router ], dependencies = { \"app_dependency\" : Provide ( bool_fn )} ) The above example illustrates how dependencies are declared on the different layers of the application. Dependencies are callables - sync or async functions, methods or class instances that implement the __call__ method - that are wrapped inside an instance of the Provide class. Pre-requisites and Scope The pre-requisites for dependency injection are these: dependencies must be callables. dependencies can receive kwargs and a self arg but not positional args. the kwarg name and the dependency key must be identical. the dependency must be declared using the Provide class. the dependency must be in the scope of the handler function. What is scope in this context? Dependencies are isolated to the context in which they are declared. Thus, in the above example, the local_dependency can only be accessed within the specific route handler on which it was declared; The controller_dependency is available only for route handlers on that specific controller; And the router dependencies are available only to the route handlers registered on that particular router. Only the app_dependencies are available to all route handlers. Dependencies with yield (cleanup step) In addition to simple callables, dependencies can also be (async) generator functions, which allows to execute an additional cleanup step, such as closing a connection, after the handler function has returned. Technical details The cleanup stage is executed after the handler function returns, but before the response is sent (in case of HTTP requests) A basic example Python 3.8+ Python 3.9+ dependencies.py from typing import Dict , Generator from starlite import Provide , Starlite , get CONNECTION = { \"open\" : False } def generator_function () -> Generator [ Dict [ str , bool ], None , None ]: \"\"\"Set connection to open and close it after the handler returns.\"\"\" CONNECTION [ \"open\" ] = True yield CONNECTION CONNECTION [ \"open\" ] = False @get ( \"/\" , dependencies = { \"conn\" : Provide ( generator_function )}) def index ( conn : Dict [ str , bool ]) -> Dict [ str , bool ]: \"\"\"Return the current connection state.\"\"\" return conn app = Starlite ( route_handlers = [ index ]) dependencies.py from collections.abc import Generator from starlite import Provide , Starlite , get CONNECTION = { \"open\" : False } def generator_function () -> Generator [ dict [ str , bool ], None , None ]: \"\"\"Set connection to open and close it after the handler returns.\"\"\" CONNECTION [ \"open\" ] = True yield CONNECTION CONNECTION [ \"open\" ] = False @get ( \"/\" , dependencies = { \"conn\" : Provide ( generator_function )}) def index ( conn : dict [ str , bool ]) -> dict [ str , bool ]: \"\"\"Return the current connection state.\"\"\" return conn app = Starlite ( route_handlers = [ index ]) If you run the code you'll see that CONNECTION has been reset after the handler function returned: from starlite import TestClient from dependencies import app , CONNECTION with TestClient ( app = app ) as client : print ( client . get ( \"/\" ) . json ()) # {\"open\": True} print ( CONNECTION ) # {\"open\": False} Handling exceptions If an exception occurs within the handler function, it will be raised within the generator, at the point where it first yield ed. This makes it possible to adapt behaviour of the dependency based on exceptions, for example rolling back a database session on error and committing otherwise. Python 3.8+ Python 3.9+ dependencies.py from typing import Dict , Generator from starlite import Provide , Starlite , get STATE = { \"result\" : None , \"connection\" : \"closed\" } def generator_function () -> Generator [ str , None , None ]: \"\"\"Set the connection state to open and close it after the handler returns. If an error occurs, set `result` to `\"error\"`, else set it to `\"OK\"`. \"\"\" try : STATE [ \"connection\" ] = \"open\" yield \"hello\" STATE [ \"result\" ] = \"OK\" except ValueError : STATE [ \"result\" ] = \"error\" finally : STATE [ \"connection\" ] = \"closed\" @get ( \"/{name:str}\" , dependencies = { \"message\" : Provide ( generator_function )}) def index ( name : str , message : str ) -> Dict [ str , str ]: \"\"\"If `name` is \"John\", return a message, otherwise raise an error.\"\"\" if name == \"John\" : return { name : message } raise ValueError () app = Starlite ( route_handlers = [ index ]) dependencies.py from collections.abc import Generator from starlite import Provide , Starlite , get STATE = { \"result\" : None , \"connection\" : \"closed\" } def generator_function () -> Generator [ str , None , None ]: \"\"\"Set the connection state to open and close it after the handler returns. If an error occurs, set `result` to `\"error\"`, else set it to `\"OK\"`. \"\"\" try : STATE [ \"connection\" ] = \"open\" yield \"hello\" STATE [ \"result\" ] = \"OK\" except ValueError : STATE [ \"result\" ] = \"error\" finally : STATE [ \"connection\" ] = \"closed\" @get ( \"/{name:str}\" , dependencies = { \"message\" : Provide ( generator_function )}) def index ( name : str , message : str ) -> dict [ str , str ]: \"\"\"If `name` is \"John\", return a message, otherwise raise an error.\"\"\" if name == \"John\" : return { name : message } raise ValueError () app = Starlite ( route_handlers = [ index ]) from starlite import TestClient from dependencies import STATE , app with TestClient ( app = app ) as client : response = client . get ( \"/John\" ) print ( response . json ()) # {\"John\": \"hello\"} print ( STATE ) # {\"result\": \"OK\", \"connection\": \"closed\"} response = client . get ( \"/Peter\" ) print ( response . status_code ) # 500 print ( STATE ) # {\"result\": \"error\", \"connection\": \"closed\"} Best Practice You should always wrap yield in a try / finally block, regardless of whether you want to handle exceptions, to ensure that the cleanup code is run even when exceptions occurred: def generator_dependency (): try : yield finally : ... # cleanup code Important Do not re-raise exceptions within the dependency. Exceptions caught within these dependencies will still be handled by the regular mechanisms without an explicit re-raise","title":"Dependency Injection"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#dependency-injection","text":"Starlite has a simple but powerful dependency injection system that allows for declaring dependencies on all layers of the application: from starlite import Controller , Router , Starlite , Provide , get def bool_fn () -> bool : ... def dict_fn () -> dict : ... def list_fn () -> list : ... def int_fn () -> int : ... class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"controller_dependency\" : Provide ( list_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"local_dependency\" : Provide ( int_fn )}) def my_route_handler ( self , app_dependency : bool , router_dependency : dict , controller_dependency : list , local_dependency : int , ) -> None : ... # on the router my_router = Router ( path = \"/router\" , dependencies = { \"router_dependency\" : Provide ( dict_fn )}, route_handlers = [ MyController ], ) # on the app app = Starlite ( route_handlers = [ my_router ], dependencies = { \"app_dependency\" : Provide ( bool_fn )} ) The above example illustrates how dependencies are declared on the different layers of the application. Dependencies are callables - sync or async functions, methods or class instances that implement the __call__ method - that are wrapped inside an instance of the Provide class.","title":"Dependency Injection"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#pre-requisites-and-scope","text":"The pre-requisites for dependency injection are these: dependencies must be callables. dependencies can receive kwargs and a self arg but not positional args. the kwarg name and the dependency key must be identical. the dependency must be declared using the Provide class. the dependency must be in the scope of the handler function. What is scope in this context? Dependencies are isolated to the context in which they are declared. Thus, in the above example, the local_dependency can only be accessed within the specific route handler on which it was declared; The controller_dependency is available only for route handlers on that specific controller; And the router dependencies are available only to the route handlers registered on that particular router. Only the app_dependencies are available to all route handlers.","title":"Pre-requisites and Scope"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#dependencies-with-yield-cleanup-step","text":"In addition to simple callables, dependencies can also be (async) generator functions, which allows to execute an additional cleanup step, such as closing a connection, after the handler function has returned. Technical details The cleanup stage is executed after the handler function returns, but before the response is sent (in case of HTTP requests)","title":"Dependencies with yield (cleanup step)"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#a-basic-example","text":"Python 3.8+ Python 3.9+ dependencies.py from typing import Dict , Generator from starlite import Provide , Starlite , get CONNECTION = { \"open\" : False } def generator_function () -> Generator [ Dict [ str , bool ], None , None ]: \"\"\"Set connection to open and close it after the handler returns.\"\"\" CONNECTION [ \"open\" ] = True yield CONNECTION CONNECTION [ \"open\" ] = False @get ( \"/\" , dependencies = { \"conn\" : Provide ( generator_function )}) def index ( conn : Dict [ str , bool ]) -> Dict [ str , bool ]: \"\"\"Return the current connection state.\"\"\" return conn app = Starlite ( route_handlers = [ index ]) dependencies.py from collections.abc import Generator from starlite import Provide , Starlite , get CONNECTION = { \"open\" : False } def generator_function () -> Generator [ dict [ str , bool ], None , None ]: \"\"\"Set connection to open and close it after the handler returns.\"\"\" CONNECTION [ \"open\" ] = True yield CONNECTION CONNECTION [ \"open\" ] = False @get ( \"/\" , dependencies = { \"conn\" : Provide ( generator_function )}) def index ( conn : dict [ str , bool ]) -> dict [ str , bool ]: \"\"\"Return the current connection state.\"\"\" return conn app = Starlite ( route_handlers = [ index ]) If you run the code you'll see that CONNECTION has been reset after the handler function returned: from starlite import TestClient from dependencies import app , CONNECTION with TestClient ( app = app ) as client : print ( client . get ( \"/\" ) . json ()) # {\"open\": True} print ( CONNECTION ) # {\"open\": False}","title":"A basic example"},{"location":"usage/6-dependency-injection/0-dependency-injection-intro/#handling-exceptions","text":"If an exception occurs within the handler function, it will be raised within the generator, at the point where it first yield ed. This makes it possible to adapt behaviour of the dependency based on exceptions, for example rolling back a database session on error and committing otherwise. Python 3.8+ Python 3.9+ dependencies.py from typing import Dict , Generator from starlite import Provide , Starlite , get STATE = { \"result\" : None , \"connection\" : \"closed\" } def generator_function () -> Generator [ str , None , None ]: \"\"\"Set the connection state to open and close it after the handler returns. If an error occurs, set `result` to `\"error\"`, else set it to `\"OK\"`. \"\"\" try : STATE [ \"connection\" ] = \"open\" yield \"hello\" STATE [ \"result\" ] = \"OK\" except ValueError : STATE [ \"result\" ] = \"error\" finally : STATE [ \"connection\" ] = \"closed\" @get ( \"/{name:str}\" , dependencies = { \"message\" : Provide ( generator_function )}) def index ( name : str , message : str ) -> Dict [ str , str ]: \"\"\"If `name` is \"John\", return a message, otherwise raise an error.\"\"\" if name == \"John\" : return { name : message } raise ValueError () app = Starlite ( route_handlers = [ index ]) dependencies.py from collections.abc import Generator from starlite import Provide , Starlite , get STATE = { \"result\" : None , \"connection\" : \"closed\" } def generator_function () -> Generator [ str , None , None ]: \"\"\"Set the connection state to open and close it after the handler returns. If an error occurs, set `result` to `\"error\"`, else set it to `\"OK\"`. \"\"\" try : STATE [ \"connection\" ] = \"open\" yield \"hello\" STATE [ \"result\" ] = \"OK\" except ValueError : STATE [ \"result\" ] = \"error\" finally : STATE [ \"connection\" ] = \"closed\" @get ( \"/{name:str}\" , dependencies = { \"message\" : Provide ( generator_function )}) def index ( name : str , message : str ) -> dict [ str , str ]: \"\"\"If `name` is \"John\", return a message, otherwise raise an error.\"\"\" if name == \"John\" : return { name : message } raise ValueError () app = Starlite ( route_handlers = [ index ]) from starlite import TestClient from dependencies import STATE , app with TestClient ( app = app ) as client : response = client . get ( \"/John\" ) print ( response . json ()) # {\"John\": \"hello\"} print ( STATE ) # {\"result\": \"OK\", \"connection\": \"closed\"} response = client . get ( \"/Peter\" ) print ( response . status_code ) # 500 print ( STATE ) # {\"result\": \"error\", \"connection\": \"closed\"} Best Practice You should always wrap yield in a try / finally block, regardless of whether you want to handle exceptions, to ensure that the cleanup code is run even when exceptions occurred: def generator_dependency (): try : yield finally : ... # cleanup code Important Do not re-raise exceptions within the dependency. Exceptions caught within these dependencies will still be handled by the regular mechanisms without an explicit re-raise","title":"Handling exceptions"},{"location":"usage/6-dependency-injection/1-dependency-kwargs/","text":"Dependency Kwargs As stated above dependencies can receive kwargs but no args. The reason for this is that dependencies are parsed using the same mechanism that parses route handler functions, and they too - like route handler functions, can have data injected into them. In fact, you can inject the same data that you can inject into route handlers . from starlite import Controller , Provide , patch from starlite.types.partial import Partial from pydantic import BaseModel , UUID4 class User ( BaseModel ): id : UUID4 name : str async def retrieve_db_user ( user_id : UUID4 ) -> User : ... class UserController ( Controller ): path = \"/user\" dependencies = { \"user\" : Provide ( retrieve_db_user )} @patch ( path = \"/{user_id:uuid}\" ) async def update_user ( self , data : Partial [ User ], user : User ) -> User : ... In the above example we have a User model that we are persisting into a db. The model is fetched using the helper method retrieve_db_user which receives a user_id kwarg and retrieves the corresponding User instance. The UserController class maps the retrieve_db_user provider to the key user in its dependencies dictionary. This in turn makes it available as a kwarg in the update_user method.","title":"Dependency Kwargs"},{"location":"usage/6-dependency-injection/1-dependency-kwargs/#dependency-kwargs","text":"As stated above dependencies can receive kwargs but no args. The reason for this is that dependencies are parsed using the same mechanism that parses route handler functions, and they too - like route handler functions, can have data injected into them. In fact, you can inject the same data that you can inject into route handlers . from starlite import Controller , Provide , patch from starlite.types.partial import Partial from pydantic import BaseModel , UUID4 class User ( BaseModel ): id : UUID4 name : str async def retrieve_db_user ( user_id : UUID4 ) -> User : ... class UserController ( Controller ): path = \"/user\" dependencies = { \"user\" : Provide ( retrieve_db_user )} @patch ( path = \"/{user_id:uuid}\" ) async def update_user ( self , data : Partial [ User ], user : User ) -> User : ... In the above example we have a User model that we are persisting into a db. The model is fetched using the helper method retrieve_db_user which receives a user_id kwarg and retrieves the corresponding User instance. The UserController class maps the retrieve_db_user provider to the key user in its dependencies dictionary. This in turn makes it available as a kwarg in the update_user method.","title":"Dependency Kwargs"},{"location":"usage/6-dependency-injection/2-overriding-dependencies/","text":"Overriding Dependencies Because dependencies are declared at each level of the app using a string keyed dictionary, overriding dependencies is very simple: from starlite import Controller , Provide , get def bool_fn () -> bool : ... def dict_fn () -> dict : ... class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"some_dependency\" : Provide ( dict_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"some_dependency\" : Provide ( bool_fn )}) def my_route_handler ( self , some_dependency : bool , ) -> None : ... The lower scoped route handler function declares a dependency with the same key as the one declared on the higher scoped controller. The lower scoped dependency therefore overrides the higher scoped one.","title":"Overriding Dependencies"},{"location":"usage/6-dependency-injection/2-overriding-dependencies/#overriding-dependencies","text":"Because dependencies are declared at each level of the app using a string keyed dictionary, overriding dependencies is very simple: from starlite import Controller , Provide , get def bool_fn () -> bool : ... def dict_fn () -> dict : ... class MyController ( Controller ): path = \"/controller\" # on the controller dependencies = { \"some_dependency\" : Provide ( dict_fn )} # on the route handler @get ( path = \"/handler\" , dependencies = { \"some_dependency\" : Provide ( bool_fn )}) def my_route_handler ( self , some_dependency : bool , ) -> None : ... The lower scoped route handler function declares a dependency with the same key as the one declared on the higher scoped controller. The lower scoped dependency therefore overrides the higher scoped one.","title":"Overriding Dependencies"},{"location":"usage/6-dependency-injection/3-the-provide-class/","text":"The Provide Class The Provide class is a wrapper used for dependency injection. To inject a callable you must wrap it in Provide : from starlite import Provide , get from random import randint def my_dependency () -> int : return randint ( 1 , 10 ) @get ( \"/some-path\" , dependencies = { \"my_dep\" : Provide ( my_dependency , ) }, ) def my_handler ( my_dep : int ) -> None : ... See the API Reference for full details on the Provide class and the kwargs it accepts. Important If Provide.use_cache is true, the return value of the function will be memoized the first time it is called and then will be used. There is no sophisticated comparison of kwargs, LRU implementation etc. so you should be careful when you choose to use this option. Note that dependencies will only be called once per request, even with Provide.use_cache set to false.","title":"The Provide Class"},{"location":"usage/6-dependency-injection/3-the-provide-class/#the-provide-class","text":"The Provide class is a wrapper used for dependency injection. To inject a callable you must wrap it in Provide : from starlite import Provide , get from random import randint def my_dependency () -> int : return randint ( 1 , 10 ) @get ( \"/some-path\" , dependencies = { \"my_dep\" : Provide ( my_dependency , ) }, ) def my_handler ( my_dep : int ) -> None : ... See the API Reference for full details on the Provide class and the kwargs it accepts. Important If Provide.use_cache is true, the return value of the function will be memoized the first time it is called and then will be used. There is no sophisticated comparison of kwargs, LRU implementation etc. so you should be careful when you choose to use this option. Note that dependencies will only be called once per request, even with Provide.use_cache set to false.","title":"The Provide Class"},{"location":"usage/6-dependency-injection/4-dependencies-in-dependencies/","text":"Using Dependencies in Dependencies You can inject dependencies into other dependencies - exactly like you would into regular functions. from starlite import Starlite , Provide , get from random import randint def first_dependency () -> int : return randint ( 1 , 10 ) def second_dependency ( injected_integer : int ) -> bool : return injected_integer % 2 == 0 @get ( \"/true-or-false\" ) def true_or_false_handler ( injected_bool : bool ) -> str : return \"its true!\" if injected_bool else \"nope, its false...\" app = Starlite ( route_handlers = [ true_or_false_handler ], dependencies = { \"injected_integer\" : Provide ( first_dependency ), \"injected_bool\" : Provide ( second_dependency ), }, ) Note The same rules for overriding dependencies apply here as well.","title":"Using Dependencies in Dependencies"},{"location":"usage/6-dependency-injection/4-dependencies-in-dependencies/#using-dependencies-in-dependencies","text":"You can inject dependencies into other dependencies - exactly like you would into regular functions. from starlite import Starlite , Provide , get from random import randint def first_dependency () -> int : return randint ( 1 , 10 ) def second_dependency ( injected_integer : int ) -> bool : return injected_integer % 2 == 0 @get ( \"/true-or-false\" ) def true_or_false_handler ( injected_bool : bool ) -> str : return \"its true!\" if injected_bool else \"nope, its false...\" app = Starlite ( route_handlers = [ true_or_false_handler ], dependencies = { \"injected_integer\" : Provide ( first_dependency ), \"injected_bool\" : Provide ( second_dependency ), }, ) Note The same rules for overriding dependencies apply here as well.","title":"Using Dependencies in Dependencies"},{"location":"usage/6-dependency-injection/5-the-dependency-function/","text":"The Dependency Function Dependency validation By default, injected dependency values are validated by Starlite, for example, this application will raise an internal server error: Dependency validation error from typing import Any from starlite import Provide , Starlite , get def provide_str () -> str : \"\"\"Returns a string.\"\"\" return \"whoops\" @get ( \"/\" , dependencies = { \"injected\" : Provide ( provide_str )}) def hello_world ( injected : int ) -> dict [ str , Any ]: \"\"\"Handler expects and `int`, but we've provided a `str`.\"\"\" return { \"hello\" : injected } app = Starlite ( route_handlers = [ hello_world ]) Dependency validation can be toggled using the Dependency function. Dependency validation error from typing import Any from starlite import Dependency , Provide , Starlite , get def provide_str () -> str : \"\"\"Returns a string.\"\"\" return \"whoops\" @get ( \"/\" , dependencies = { \"injected\" : Provide ( provide_str )}) def hello_world ( injected : int = Dependency ( skip_validation = True )) -> dict [ str , Any ]: \"\"\"Handler expects an `int`, but we've provided a `str`.\"\"\" return { \"hello\" : injected } app = Starlite ( route_handlers = [ hello_world ]) This may be useful for reasons of efficiency, or if pydantic cannot validate a certain type, but use with caution! Dependency function as a marker The Dependency function can also be used as a marker that gives us a bit more detail about your application. Exclude dependencies with default values from OpenAPI docs Depending on your application design, it is possible to have a dependency declared in a handler or Provide function that has a default value. If the dependency isn't provided for the route, the default should be used by the function. Dependency with default value from typing import Any from starlite import Starlite , get @get ( \"/\" ) def hello_world ( optional_dependency : int = 3 ) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is OK, because of the default value, but the parameter shows in the docs. \"\"\" return { \"hello\" : optional_dependency } app = Starlite ( route_handlers = [ hello_world ]) This doesn't fail, but due to the way the application determines parameter types, this is inferred to be a query parameter: By declaring the parameter to be a dependency, Starlite knows to exclude it from the docs: Dependency with default value from typing import Any from starlite import Dependency , Starlite , get @get ( \"/\" ) def hello_world ( optional_dependency : int = Dependency ( default = 3 )) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is OK, because of the default value, and now the parameter is excluded from the docs. \"\"\" return { \"hello\" : optional_dependency } app = Starlite ( route_handlers = [ hello_world ]) Early detection if a dependency isn't provided The other side of the same coin is when a dependency isn't provided, and no default is specified. Without the dependency marker, the parameter is assumed to be a query parameter and the route will most likely fail when accessed. If the parameter is marked as a dependency, this allows us to fail early instead: Dependency not provided error from typing import Any from starlite import Dependency , get @get ( \"/\" ) def hello_world ( non_optional_dependency : int = Dependency ()) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is not great, however by explicitly marking dependencies, Starlite won't let the app start. \"\"\" return { \"hello\" : non_optional_dependency } # app = Starlite(route_handlers=[hello_world]) # ImproperlyConfiguredException: 500: Explicit dependency 'non_optional_dependency' for 'hello_world' has no default # value, or provided dependency.","title":"The Dependency Function"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#the-dependency-function","text":"","title":"The Dependency Function"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#dependency-validation","text":"By default, injected dependency values are validated by Starlite, for example, this application will raise an internal server error: Dependency validation error from typing import Any from starlite import Provide , Starlite , get def provide_str () -> str : \"\"\"Returns a string.\"\"\" return \"whoops\" @get ( \"/\" , dependencies = { \"injected\" : Provide ( provide_str )}) def hello_world ( injected : int ) -> dict [ str , Any ]: \"\"\"Handler expects and `int`, but we've provided a `str`.\"\"\" return { \"hello\" : injected } app = Starlite ( route_handlers = [ hello_world ]) Dependency validation can be toggled using the Dependency function. Dependency validation error from typing import Any from starlite import Dependency , Provide , Starlite , get def provide_str () -> str : \"\"\"Returns a string.\"\"\" return \"whoops\" @get ( \"/\" , dependencies = { \"injected\" : Provide ( provide_str )}) def hello_world ( injected : int = Dependency ( skip_validation = True )) -> dict [ str , Any ]: \"\"\"Handler expects an `int`, but we've provided a `str`.\"\"\" return { \"hello\" : injected } app = Starlite ( route_handlers = [ hello_world ]) This may be useful for reasons of efficiency, or if pydantic cannot validate a certain type, but use with caution!","title":"Dependency validation"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#dependency-function-as-a-marker","text":"The Dependency function can also be used as a marker that gives us a bit more detail about your application.","title":"Dependency function as a marker"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#exclude-dependencies-with-default-values-from-openapi-docs","text":"Depending on your application design, it is possible to have a dependency declared in a handler or Provide function that has a default value. If the dependency isn't provided for the route, the default should be used by the function. Dependency with default value from typing import Any from starlite import Starlite , get @get ( \"/\" ) def hello_world ( optional_dependency : int = 3 ) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is OK, because of the default value, but the parameter shows in the docs. \"\"\" return { \"hello\" : optional_dependency } app = Starlite ( route_handlers = [ hello_world ]) This doesn't fail, but due to the way the application determines parameter types, this is inferred to be a query parameter: By declaring the parameter to be a dependency, Starlite knows to exclude it from the docs: Dependency with default value from typing import Any from starlite import Dependency , Starlite , get @get ( \"/\" ) def hello_world ( optional_dependency : int = Dependency ( default = 3 )) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is OK, because of the default value, and now the parameter is excluded from the docs. \"\"\" return { \"hello\" : optional_dependency } app = Starlite ( route_handlers = [ hello_world ])","title":"Exclude dependencies with default values from OpenAPI docs"},{"location":"usage/6-dependency-injection/5-the-dependency-function/#early-detection-if-a-dependency-isnt-provided","text":"The other side of the same coin is when a dependency isn't provided, and no default is specified. Without the dependency marker, the parameter is assumed to be a query parameter and the route will most likely fail when accessed. If the parameter is marked as a dependency, this allows us to fail early instead: Dependency not provided error from typing import Any from starlite import Dependency , get @get ( \"/\" ) def hello_world ( non_optional_dependency : int = Dependency ()) -> dict [ str , Any ]: \"\"\"Notice we haven't provided the dependency to the route. This is not great, however by explicitly marking dependencies, Starlite won't let the app start. \"\"\" return { \"hello\" : non_optional_dependency } # app = Starlite(route_handlers=[hello_world]) # ImproperlyConfiguredException: 500: Explicit dependency 'non_optional_dependency' for 'hello_world' has no default # value, or provided dependency.","title":"Early detection if a dependency isn't provided"},{"location":"usage/7-middleware/0-middleware-intro/","text":"Introduction Middlewares in Starlite are ASGI apps that are called \"in the middle\" between the application entrypoint and the route handler function. Starlite ships with several builtin middlewares (some coming from Starlette) that are easy to configure and use. See the documentation regarding these for more details. You can also use the builtin Starlette Middlewares and most 3rd party middlewares created for Starlette or FastAPI. Note 3rd party middlewares for Starlette that rely on the Starlette routing system are incompatible with Starlite. To understand why, read about the Starlite routing system .","title":"Introduction"},{"location":"usage/7-middleware/0-middleware-intro/#introduction","text":"Middlewares in Starlite are ASGI apps that are called \"in the middle\" between the application entrypoint and the route handler function. Starlite ships with several builtin middlewares (some coming from Starlette) that are easy to configure and use. See the documentation regarding these for more details. You can also use the builtin Starlette Middlewares and most 3rd party middlewares created for Starlette or FastAPI. Note 3rd party middlewares for Starlette that rely on the Starlette routing system are incompatible with Starlite. To understand why, read about the Starlite routing system .","title":"Introduction"},{"location":"usage/7-middleware/1-using-middleware/0-using-middleware-intro/","text":"Using Middleware A middleware in Starlite is any callable that receives at least one kwarg called app and returns an ASGIApp . Since these terms are somewhat daunting, lets parse what this means: an ASGIApp is nothing but an async function that receives the ASGI primitives - scope , receive and send - and either calls the next ASGIApp or returns a response / handles the websocket connection. For example, the following function can be used as a middleware because it receives the app kwarg and returns an ASGIApp : from starlite.types import ASGIApp , Scope , Receive , Send def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware We could then use it by passing it to one of the layers of the application. What does this mean? Unlike other frameworks that allow users to define middleware only on the application level, Starlite allows users to user middleware on the different layers of the application. Thus, we could use our middleware on the application layer - like so: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware app = Starlite ( route_handlers = [ ... ], middleware = [ middleware_factory ]) In the above example, Starlite will call the middleware_factory function and pass to it app . It's important to understand that this kwarg does not designate the Starlite application but rather the next ASGIApp in the stack. It will then insert the returned my_middleware function into the stack of every route in the application - because we declared it on the application level.","title":"Using Middleware"},{"location":"usage/7-middleware/1-using-middleware/0-using-middleware-intro/#using-middleware","text":"A middleware in Starlite is any callable that receives at least one kwarg called app and returns an ASGIApp . Since these terms are somewhat daunting, lets parse what this means: an ASGIApp is nothing but an async function that receives the ASGI primitives - scope , receive and send - and either calls the next ASGIApp or returns a response / handles the websocket connection. For example, the following function can be used as a middleware because it receives the app kwarg and returns an ASGIApp : from starlite.types import ASGIApp , Scope , Receive , Send def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware We could then use it by passing it to one of the layers of the application. What does this mean? Unlike other frameworks that allow users to define middleware only on the application level, Starlite allows users to user middleware on the different layers of the application. Thus, we could use our middleware on the application layer - like so: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware app = Starlite ( route_handlers = [ ... ], middleware = [ middleware_factory ]) In the above example, Starlite will call the middleware_factory function and pass to it app . It's important to understand that this kwarg does not designate the Starlite application but rather the next ASGIApp in the stack. It will then insert the returned my_middleware function into the stack of every route in the application - because we declared it on the application level.","title":"Using Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/","text":"Layering Middleware While running middleware on the application level is the most common use-case, sometimes middleware needs to run on only a specific subset of routes. Starlite allows doing this by supporting middleware declaration on all layers of the application - the Starlite instance, routers, controllers and individual route handlers. That is, all of these patterns are supported as well: Router Level Middleware By passing middleware on the router, this middleware will be used for all routes on the router: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , Router , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware @get ( \"/handler1\" ) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... router = Router ( path = \"/router\" , route_handlers = [ handler1 , handler2 ], middleware = [ middleware_factory ] ) app = Starlite ( route_handlers = [ router ]) Controller Level Middleware By passing middleware on the controller, this middleware will be used for all routes on the controller: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , Controller , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware class MyController ( Controller ): path = \"/controller\" middleware = [ middleware_factory ] @get ( \"/handler1\" ) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... app = Starlite ( route_handlers = [ MyController ], middleware = [ middleware_factory ]) Route Handler Level Middleware By passing middleware on the route handler, this middleware will be used only for those route handlers that specify it: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware @get ( \"/handler1\" , middleware = [ middleware_factory ]) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... app = Starlite ( route_handlers = [ handler1 , handler2 ])","title":"Layering Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/#layering-middleware","text":"While running middleware on the application level is the most common use-case, sometimes middleware needs to run on only a specific subset of routes. Starlite allows doing this by supporting middleware declaration on all layers of the application - the Starlite instance, routers, controllers and individual route handlers. That is, all of these patterns are supported as well:","title":"Layering Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/#router-level-middleware","text":"By passing middleware on the router, this middleware will be used for all routes on the router: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , Router , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware @get ( \"/handler1\" ) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... router = Router ( path = \"/router\" , route_handlers = [ handler1 , handler2 ], middleware = [ middleware_factory ] ) app = Starlite ( route_handlers = [ router ])","title":"Router Level Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/#controller-level-middleware","text":"By passing middleware on the controller, this middleware will be used for all routes on the controller: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , Controller , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware class MyController ( Controller ): path = \"/controller\" middleware = [ middleware_factory ] @get ( \"/handler1\" ) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... app = Starlite ( route_handlers = [ MyController ], middleware = [ middleware_factory ])","title":"Controller Level Middleware"},{"location":"usage/7-middleware/1-using-middleware/1-layering-middleware/#route-handler-level-middleware","text":"By passing middleware on the route handler, this middleware will be used only for those route handlers that specify it: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , get def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : ... await app ( scope , receive , send ) return my_middleware @get ( \"/handler1\" , middleware = [ middleware_factory ]) def handler1 ( self ) -> dict [ str , str ]: ... @get ( \"/handler2\" ) def handler2 ( self ) -> dict [ str , str ]: ... app = Starlite ( route_handlers = [ handler1 , handler2 ])","title":"Route Handler Level Middleware"},{"location":"usage/7-middleware/1-using-middleware/2-middleware-call-order/","text":"Middleware Call Order The call order of middleware follows a simple rule: middleware is called top to bottom, left to right . That is to say- application level middleware will be called before router level middleware, which will be called before controller level middleware, which will be called before route handler middleware. And also, that middleware defined first the in the middleware list, will be called first. To illustrate this, consider the following test case: from starlite.types import ASGIApp , Receive , Scope , Send from starlite import ( Controller , MiddlewareProtocol , Router , get , ) from starlite.testing.create_test_client import create_test_client def test_middleware_call_order () -> None : \"\"\"Test that middlewares are called in the order they have been passed.\"\"\" results : list [ int ] = [] def create_test_middleware ( middleware_id : int ) -> type [ MiddlewareProtocol ]: class TestMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : results . append ( middleware_id ) await self . app ( scope , receive , send ) return TestMiddleware class MyController ( Controller ): path = \"/controller\" middleware = [ create_test_middleware ( 4 ), create_test_middleware ( 5 )] @get ( \"/handler\" , middleware = [ create_test_middleware ( 6 ), create_test_middleware ( 7 )], ) def my_handler ( self ) -> None : return None router = Router ( path = \"/router\" , route_handlers = [ MyController ], middleware = [ create_test_middleware ( 2 ), create_test_middleware ( 3 )], ) with create_test_client ( route_handlers = [ router ], middleware = [ create_test_middleware ( 0 ), create_test_middleware ( 1 )], ) as client : client . get ( \"/router/controller/handler\" ) assert results == [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ]","title":"Middleware Call Order"},{"location":"usage/7-middleware/1-using-middleware/2-middleware-call-order/#middleware-call-order","text":"The call order of middleware follows a simple rule: middleware is called top to bottom, left to right . That is to say- application level middleware will be called before router level middleware, which will be called before controller level middleware, which will be called before route handler middleware. And also, that middleware defined first the in the middleware list, will be called first. To illustrate this, consider the following test case: from starlite.types import ASGIApp , Receive , Scope , Send from starlite import ( Controller , MiddlewareProtocol , Router , get , ) from starlite.testing.create_test_client import create_test_client def test_middleware_call_order () -> None : \"\"\"Test that middlewares are called in the order they have been passed.\"\"\" results : list [ int ] = [] def create_test_middleware ( middleware_id : int ) -> type [ MiddlewareProtocol ]: class TestMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : results . append ( middleware_id ) await self . app ( scope , receive , send ) return TestMiddleware class MyController ( Controller ): path = \"/controller\" middleware = [ create_test_middleware ( 4 ), create_test_middleware ( 5 )] @get ( \"/handler\" , middleware = [ create_test_middleware ( 6 ), create_test_middleware ( 7 )], ) def my_handler ( self ) -> None : return None router = Router ( path = \"/router\" , route_handlers = [ MyController ], middleware = [ create_test_middleware ( 2 ), create_test_middleware ( 3 )], ) with create_test_client ( route_handlers = [ router ], middleware = [ create_test_middleware ( 0 ), create_test_middleware ( 1 )], ) as client : client . get ( \"/router/controller/handler\" ) assert results == [ 0 , 1 , 2 , 3 , 4 , 5 , 6 , 7 ]","title":"Middleware Call Order"},{"location":"usage/7-middleware/1-using-middleware/3-define-middleware/","text":"Passing Args and Kwargs to Middleware Starlite offers a simple way to pass positional arguments ( *args ) and key-word arguments ( **kwargs ) to middleware using the DefineMiddleware class. Let's extend the factory function used in the examples above to take some args and kwargs and then use DefineMiddleware to pass these values to our middleware: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , DefineMiddleware def middleware_factory ( my_arg : int , * , app : ASGIApp , my_kwarg : str ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # here we can use my_arg and my_kwarg for some purpose ... await app ( scope , receive , send ) return my_middleware app = Starlite ( route_handlers = [ ... ], middleware = [ DefineMiddleware ( middleware_factory , 1 , my_kwarg = \"abc\" )], ) The DefineMiddleware is a simple container - it takes a middleware callable as a first parameter, and then any positional arguments, followed by key word arguments. The middleware callable will be called with these values as well as the kwarg app as mentioned above. Note Starlette also includes a middleware container - starlette.middleware.Middleware , and this class is also supported by Starlite - so feel free to use it. You should note though that the Starlette class though does not support positional arguments.","title":"Passing Args and Kwargs to Middleware"},{"location":"usage/7-middleware/1-using-middleware/3-define-middleware/#passing-args-and-kwargs-to-middleware","text":"Starlite offers a simple way to pass positional arguments ( *args ) and key-word arguments ( **kwargs ) to middleware using the DefineMiddleware class. Let's extend the factory function used in the examples above to take some args and kwargs and then use DefineMiddleware to pass these values to our middleware: from starlite.types import ASGIApp , Scope , Receive , Send from starlite import Starlite , DefineMiddleware def middleware_factory ( my_arg : int , * , app : ASGIApp , my_kwarg : str ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # here we can use my_arg and my_kwarg for some purpose ... await app ( scope , receive , send ) return my_middleware app = Starlite ( route_handlers = [ ... ], middleware = [ DefineMiddleware ( middleware_factory , 1 , my_kwarg = \"abc\" )], ) The DefineMiddleware is a simple container - it takes a middleware callable as a first parameter, and then any positional arguments, followed by key word arguments. The middleware callable will be called with these values as well as the kwarg app as mentioned above. Note Starlette also includes a middleware container - starlette.middleware.Middleware , and this class is also supported by Starlite - so feel free to use it. You should note though that the Starlette class though does not support positional arguments.","title":"Passing Args and Kwargs to Middleware"},{"location":"usage/7-middleware/1-using-middleware/4-middleware-and-exceptions/","text":"Middlewares and Exceptions When an exception is raised by a route handler or dependency and is then transformed into a response by an exception handler , middlewares are still applied to it. The one limitation on this though are the two exceptions that can be raised by the ASGI router - 404 Not Found and 405 Method Not Allowed . These exceptions are raised before the middleware stack is called, and are only handled by exceptions handlers defined on the Starlite app instance itself. Thus, if you need to modify the responses generated for these exceptions, you will need to define a custom exception handler on the app instance level.","title":"Middlewares and Exceptions"},{"location":"usage/7-middleware/1-using-middleware/4-middleware-and-exceptions/#middlewares-and-exceptions","text":"When an exception is raised by a route handler or dependency and is then transformed into a response by an exception handler , middlewares are still applied to it. The one limitation on this though are the two exceptions that can be raised by the ASGI router - 404 Not Found and 405 Method Not Allowed . These exceptions are raised before the middleware stack is called, and are only handled by exceptions handlers defined on the Starlite app instance itself. Thus, if you need to modify the responses generated for these exceptions, you will need to define a custom exception handler on the app instance level.","title":"Middlewares and Exceptions"},{"location":"usage/7-middleware/2-creating-middleware/0-creating-middleware-intro/","text":"Creating Middleware As mentioned in the using middleware section, a middleware in Starlite is any callable that takes a kwarg called app , which is the next ASGI handler, i.e. an ASGIApp , and returns an ASGIApp . The example previously given was using a factory function, i.e.: from starlite.types import ASGIApp , Scope , Receive , Send def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware While using functions is a perfectly viable approach, you can also use classes to do the same. See the next sections on two base classes you can use for this purpose - the MiddlewareProtocol , which gives a bare-bone type, or the AbstractMiddleware that offers a base class with some built in functionality.","title":"Creating Middleware"},{"location":"usage/7-middleware/2-creating-middleware/0-creating-middleware-intro/#creating-middleware","text":"As mentioned in the using middleware section, a middleware in Starlite is any callable that takes a kwarg called app , which is the next ASGI handler, i.e. an ASGIApp , and returns an ASGIApp . The example previously given was using a factory function, i.e.: from starlite.types import ASGIApp , Scope , Receive , Send def middleware_factory ( app : ASGIApp ) -> ASGIApp : async def my_middleware ( scope : Scope , receive : Receive , send : Send ) -> None : # do something here ... await app ( scope , receive , send ) return my_middleware While using functions is a perfectly viable approach, you can also use classes to do the same. See the next sections on two base classes you can use for this purpose - the MiddlewareProtocol , which gives a bare-bone type, or the AbstractMiddleware that offers a base class with some built in functionality.","title":"Creating Middleware"},{"location":"usage/7-middleware/2-creating-middleware/1-using-middleware-protocol/","text":"Using MiddlewareProtocol The MiddlewareProtocol class is a PEP 544 Protocol that specifies the minimal implementation of a middleware as follows: from typing import Protocol , Any from starlite.types import ASGIApp , Scope , Receive , Send class MiddlewareProtocol ( Protocol ): def __init__ ( self , app : ASGIApp , ** kwargs : Any ) -> None : ... async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ... The __init__ method receives and sets \"app\". It's important to understand that app is not an instance of Starlite in this case, but rather the next middleware in the stack, which is also an ASGI app. The __call__ method makes this class into a callable , i.e. once instantiated this class acts like a function, that has the signature of an ASGI app: The three parameters, scope, receive, send are specified by the ASGI specification , and their values originate with the ASGI server (e.g. uvicorn ) used to run Starlite. To use this protocol as a basis, simply subclass it - as you would any other class, and implement the two methods it specifies: import logging from starlite.types import ASGIApp , Receive , Scope , Send from starlite import Request from starlite.middleware.base import MiddlewareProtocol logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : request = Request ( scope ) logger . info ( \" %s - %s \" % request . method , request . url ) await self . app ( scope , receive , send ) Important Although scope is used to create an instance of request by passing it to the Request constructor, which makes it simpler to access because it does some parsing for you already, the actual source of truth remains scope - not the request. If you need to modify the data of the request you must modify the scope object, not any ephemeral request objects created as in the above. Responding using the MiddlewareProtocol Once a middleware finishes doing whatever its doing, it should pass scope , receive and send to an ASGI app and await it. This is what's happening in the above example with : await self.app(scope, receive, send) . Let's explore another example - redirecting the request to a different url from a middleware: from starlite.types import ASGIApp , Receive , Scope , Send from starlite.response import RedirectResponse from starlite import Request from starlite.middleware.base import MiddlewareProtocol class RedirectMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if Request ( scope ) . session is None : response = RedirectResponse ( url = \"/login\" ) await response ( scope , receive , send ) else : await self . app ( scope , receive , send ) As you can see in the above, given some condition (request.session being None) we create a RedirectResponse and then await it. Otherwise, we await self.app Modifying ASGI Requests and Responses using the MiddlewareProtocol Important If you'd like to modify a Response object after it was created for a route handler function but before the actual response message is transmitted, the correct place to do this is using the special life-cycle hook called After Request . The instructions in this section are for how to modify the ASGI response message itself, which is a step further in the response process. Using the MiddlewareProtocol you can intercept and modifying both the incoming and outgoing data in a request / response cycle by \"wrapping\" that respective receive and send ASGI functions. To demonstrate this, lets say we want to append a header with a timestamp to all outgoing responses. We could achieve this by doing the following: import time from starlite.datastructures import MutableScopeHeaders from starlite.types import Message , Receive , Scope , Send from starlite.middleware.base import MiddlewareProtocol from starlite.types import ASGIApp class ProcessTimeHeader ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : start_time = time . time () async def send_wrapper ( message : Message ) -> None : if message [ \"type\" ] == \"http.response.start\" : process_time = time . time () - start_time headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"X-Process-Time\" ] = str ( process_time ) await send ( message ) await self . app ( scope , receive , send_wrapper ) else : await self . app ( scope , receive , send )","title":"Using MiddlewareProtocol"},{"location":"usage/7-middleware/2-creating-middleware/1-using-middleware-protocol/#using-middlewareprotocol","text":"The MiddlewareProtocol class is a PEP 544 Protocol that specifies the minimal implementation of a middleware as follows: from typing import Protocol , Any from starlite.types import ASGIApp , Scope , Receive , Send class MiddlewareProtocol ( Protocol ): def __init__ ( self , app : ASGIApp , ** kwargs : Any ) -> None : ... async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : ... The __init__ method receives and sets \"app\". It's important to understand that app is not an instance of Starlite in this case, but rather the next middleware in the stack, which is also an ASGI app. The __call__ method makes this class into a callable , i.e. once instantiated this class acts like a function, that has the signature of an ASGI app: The three parameters, scope, receive, send are specified by the ASGI specification , and their values originate with the ASGI server (e.g. uvicorn ) used to run Starlite. To use this protocol as a basis, simply subclass it - as you would any other class, and implement the two methods it specifies: import logging from starlite.types import ASGIApp , Receive , Scope , Send from starlite import Request from starlite.middleware.base import MiddlewareProtocol logger = logging . getLogger ( __name__ ) class MyRequestLoggingMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : request = Request ( scope ) logger . info ( \" %s - %s \" % request . method , request . url ) await self . app ( scope , receive , send ) Important Although scope is used to create an instance of request by passing it to the Request constructor, which makes it simpler to access because it does some parsing for you already, the actual source of truth remains scope - not the request. If you need to modify the data of the request you must modify the scope object, not any ephemeral request objects created as in the above.","title":"Using MiddlewareProtocol"},{"location":"usage/7-middleware/2-creating-middleware/1-using-middleware-protocol/#responding-using-the-middlewareprotocol","text":"Once a middleware finishes doing whatever its doing, it should pass scope , receive and send to an ASGI app and await it. This is what's happening in the above example with : await self.app(scope, receive, send) . Let's explore another example - redirecting the request to a different url from a middleware: from starlite.types import ASGIApp , Receive , Scope , Send from starlite.response import RedirectResponse from starlite import Request from starlite.middleware.base import MiddlewareProtocol class RedirectMiddleware ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if Request ( scope ) . session is None : response = RedirectResponse ( url = \"/login\" ) await response ( scope , receive , send ) else : await self . app ( scope , receive , send ) As you can see in the above, given some condition (request.session being None) we create a RedirectResponse and then await it. Otherwise, we await self.app","title":"Responding using the MiddlewareProtocol"},{"location":"usage/7-middleware/2-creating-middleware/1-using-middleware-protocol/#modifying-asgi-requests-and-responses-using-the-middlewareprotocol","text":"Important If you'd like to modify a Response object after it was created for a route handler function but before the actual response message is transmitted, the correct place to do this is using the special life-cycle hook called After Request . The instructions in this section are for how to modify the ASGI response message itself, which is a step further in the response process. Using the MiddlewareProtocol you can intercept and modifying both the incoming and outgoing data in a request / response cycle by \"wrapping\" that respective receive and send ASGI functions. To demonstrate this, lets say we want to append a header with a timestamp to all outgoing responses. We could achieve this by doing the following: import time from starlite.datastructures import MutableScopeHeaders from starlite.types import Message , Receive , Scope , Send from starlite.middleware.base import MiddlewareProtocol from starlite.types import ASGIApp class ProcessTimeHeader ( MiddlewareProtocol ): def __init__ ( self , app : ASGIApp ) -> None : super () . __init__ ( app ) self . app = app async def __call__ ( self , scope : Scope , receive : Receive , send : Send ) -> None : if scope [ \"type\" ] == \"http\" : start_time = time . time () async def send_wrapper ( message : Message ) -> None : if message [ \"type\" ] == \"http.response.start\" : process_time = time . time () - start_time headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"X-Process-Time\" ] = str ( process_time ) await send ( message ) await self . app ( scope , receive , send_wrapper ) else : await self . app ( scope , receive , send )","title":"Modifying ASGI Requests and Responses using the MiddlewareProtocol"},{"location":"usage/7-middleware/2-creating-middleware/2-using-abstract-middleware/","text":"Inheriting AbstractMiddleware Starlite offers an AbstractMiddleware class that can be extended to create middleware: from typing import TYPE_CHECKING from time import time from starlite import AbstractMiddleware , ScopeType from starlite.datastructures import MutableScopeHeaders if TYPE_CHECKING : from starlite.types import Message , Receive , Scope , Send class MyMiddleware ( AbstractMiddleware ): scopes = { ScopeType . HTTP } exclude = [ \"first_path\" , \"second_path\" ] exclude_opt_key = \"exclude_from_middleware\" async def __call__ ( self , scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" ) -> None : start_time = time () async def send_wrapper ( message : \"Message\" ) -> None : if message [ \"type\" ] == \"http.response.start\" : process_time = time () - start_time headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"X-Process-Time\" ] = str ( process_time ) await send ( message ) await self . app ( scope , receive , send_wrapper ) The three class variables defined in the above example scopes , exclude and exclude_opt_key can be used to fine-tune for which routes and request types the middleware is called: The scopes variable is a set that can include either or both ScopeType.HTTP and ScopeType.WEBSOCKET , with the default being both. exclude accepts either a single string or list of strings that are compiled into a regex against which the request's path is checked. exclude_opt_key is the key to use for in a route handler's opt dict for a boolean, whether to omit from the middleware. Thus, in the following example, the middleware will only run against the route handler called not_excluded_handler : from time import time from typing import TYPE_CHECKING from starlite import AbstractMiddleware , ScopeType , Starlite , get , websocket from starlite.datastructures import MutableScopeHeaders if TYPE_CHECKING : from starlite import WebSocket from starlite.types import Message , Receive , Scope , Send class MyMiddleware ( AbstractMiddleware ): scopes = { ScopeType . HTTP } exclude = [ \"first_path\" , \"second_path\" ] exclude_opt_key = \"exclude_from_middleware\" async def __call__ ( self , scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" , ) -> None : start_time = time () async def send_wrapper ( message : \"Message\" ) -> None : if message [ \"type\" ] == \"http.response.start\" : process_time = time () - start_time headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"X-Process-Time\" ] = str ( process_time ) await send ( message ) await self . app ( scope , receive , send_wrapper ) @websocket ( \"/my-websocket\" ) async def websocket_handler ( socket : \"WebSocket\" ) -> None : \"\"\" Websocket handler - is excluded because the middleware scopes includes 'ScopeType.HTTP' \"\"\" await socket . accept () await socket . send_json ({ \"hello websocket\" }) await socket . close () @get ( \"/first_path\" ) def first_handler () -> dict [ str , str ]: \"\"\"Handler is excluded due to regex pattern matching \"first_path\".\"\"\" return { \"hello\" : \"first\" } @get ( \"/second_path\" ) def second_handler () -> dict [ str , str ]: \"\"\"Handler is excluded due to regex pattern matching \"second_path\".\"\"\" return { \"hello\" : \"second\" } @get ( \"/third_path\" , exclude_from_middleware = True ) def third_handler () -> dict [ str , str ]: \"\"\"Handler is excluded due to the opt key 'exclude_from_middleware' matching the middleware 'exclude_opt_key'.\"\"\" return { \"hello\" : \"second\" } @get ( \"/greet\" ) def not_excluded_handler () -> dict [ str , str ]: \"\"\"This handler is not excluded, and thus the middleware will execute on every incoming request to it.\"\"\" return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ websocket_handler , first_handler , second_handler , third_handler , not_excluded_handler ], middleware = [ MyMiddleware ], )","title":"Inheriting AbstractMiddleware"},{"location":"usage/7-middleware/2-creating-middleware/2-using-abstract-middleware/#inheriting-abstractmiddleware","text":"Starlite offers an AbstractMiddleware class that can be extended to create middleware: from typing import TYPE_CHECKING from time import time from starlite import AbstractMiddleware , ScopeType from starlite.datastructures import MutableScopeHeaders if TYPE_CHECKING : from starlite.types import Message , Receive , Scope , Send class MyMiddleware ( AbstractMiddleware ): scopes = { ScopeType . HTTP } exclude = [ \"first_path\" , \"second_path\" ] exclude_opt_key = \"exclude_from_middleware\" async def __call__ ( self , scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" ) -> None : start_time = time () async def send_wrapper ( message : \"Message\" ) -> None : if message [ \"type\" ] == \"http.response.start\" : process_time = time () - start_time headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"X-Process-Time\" ] = str ( process_time ) await send ( message ) await self . app ( scope , receive , send_wrapper ) The three class variables defined in the above example scopes , exclude and exclude_opt_key can be used to fine-tune for which routes and request types the middleware is called: The scopes variable is a set that can include either or both ScopeType.HTTP and ScopeType.WEBSOCKET , with the default being both. exclude accepts either a single string or list of strings that are compiled into a regex against which the request's path is checked. exclude_opt_key is the key to use for in a route handler's opt dict for a boolean, whether to omit from the middleware. Thus, in the following example, the middleware will only run against the route handler called not_excluded_handler : from time import time from typing import TYPE_CHECKING from starlite import AbstractMiddleware , ScopeType , Starlite , get , websocket from starlite.datastructures import MutableScopeHeaders if TYPE_CHECKING : from starlite import WebSocket from starlite.types import Message , Receive , Scope , Send class MyMiddleware ( AbstractMiddleware ): scopes = { ScopeType . HTTP } exclude = [ \"first_path\" , \"second_path\" ] exclude_opt_key = \"exclude_from_middleware\" async def __call__ ( self , scope : \"Scope\" , receive : \"Receive\" , send : \"Send\" , ) -> None : start_time = time () async def send_wrapper ( message : \"Message\" ) -> None : if message [ \"type\" ] == \"http.response.start\" : process_time = time () - start_time headers = MutableScopeHeaders . from_message ( message = message ) headers [ \"X-Process-Time\" ] = str ( process_time ) await send ( message ) await self . app ( scope , receive , send_wrapper ) @websocket ( \"/my-websocket\" ) async def websocket_handler ( socket : \"WebSocket\" ) -> None : \"\"\" Websocket handler - is excluded because the middleware scopes includes 'ScopeType.HTTP' \"\"\" await socket . accept () await socket . send_json ({ \"hello websocket\" }) await socket . close () @get ( \"/first_path\" ) def first_handler () -> dict [ str , str ]: \"\"\"Handler is excluded due to regex pattern matching \"first_path\".\"\"\" return { \"hello\" : \"first\" } @get ( \"/second_path\" ) def second_handler () -> dict [ str , str ]: \"\"\"Handler is excluded due to regex pattern matching \"second_path\".\"\"\" return { \"hello\" : \"second\" } @get ( \"/third_path\" , exclude_from_middleware = True ) def third_handler () -> dict [ str , str ]: \"\"\"Handler is excluded due to the opt key 'exclude_from_middleware' matching the middleware 'exclude_opt_key'.\"\"\" return { \"hello\" : \"second\" } @get ( \"/greet\" ) def not_excluded_handler () -> dict [ str , str ]: \"\"\"This handler is not excluded, and thus the middleware will execute on every incoming request to it.\"\"\" return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ websocket_handler , first_handler , second_handler , third_handler , not_excluded_handler ], middleware = [ MyMiddleware ], )","title":"Inheriting AbstractMiddleware"},{"location":"usage/7-middleware/3-builtin-middlewares/0-builtin-middlewares-intro/","text":"Builtin Middlewares Starlite comes with several builtin middlewares that you can easily configure to run in your application.","title":"Builtin Middlewares"},{"location":"usage/7-middleware/3-builtin-middlewares/0-builtin-middlewares-intro/#builtin-middlewares","text":"Starlite comes with several builtin middlewares that you can easily configure to run in your application.","title":"Builtin Middlewares"},{"location":"usage/7-middleware/3-builtin-middlewares/1-cors-middleware/","text":"CORS CORS ( Cross-Origin Resource Sharing ) is a common security mechanism - that is often implemented using middleware. To enable CORS in a starlite application simply pass an instance of CORSConfig to the Starlite constructor : from starlite import CORSConfig , Starlite cors_config = CORSConfig ( allow_origins = [ \"https://www.example.com\" ]) app = Starlite ( route_handlers = [ ... ], cors_config = cors_config ) See the API Reference for full details on the CORSConfig class and the kwargs it accepts. Note The asterisks symbol in the above kwargs means \"match any\".","title":"CORS"},{"location":"usage/7-middleware/3-builtin-middlewares/1-cors-middleware/#cors","text":"CORS ( Cross-Origin Resource Sharing ) is a common security mechanism - that is often implemented using middleware. To enable CORS in a starlite application simply pass an instance of CORSConfig to the Starlite constructor : from starlite import CORSConfig , Starlite cors_config = CORSConfig ( allow_origins = [ \"https://www.example.com\" ]) app = Starlite ( route_handlers = [ ... ], cors_config = cors_config ) See the API Reference for full details on the CORSConfig class and the kwargs it accepts. Note The asterisks symbol in the above kwargs means \"match any\".","title":"CORS"},{"location":"usage/7-middleware/3-builtin-middlewares/2-allowed-hosts-middleware/","text":"Allowed Hosts Another common security mechanism is to require that each incoming request has a \"Host\" or \"X-Forwarded-Host\" header, and then to restrict hosts to a specific set of domains - what's called \"allowed hosts\". Starlite includes an AllowedHostsMiddleware class that can be easily enabled by either passing an instance of AllowedHostsConfig or a list of domains to the Starlite constructor : from starlite import Starlite , AllowedHostsConfig app = Starlite ( route_handlers = [ ... ], allowed_hosts = AllowedHostsConfig ( allowed_hosts = [ \"*.example.com\" , \"www.wikipedia.org\" ] ), ) Note You can use wildcard prefixes ( *. ) in the beginning of a domain to match any combination of subdomains. Thus, *.example.com will match www.example.com but also x.y.z.example.com etc. You can also simply put * in trusted hosts, which means - allow all. This though is basically turning the middleware off, so it's better to simply not enable it to begin with in this case. You should note that a wildcard cannot be used only in the prefix of a domain name, not in the middle or end. Doing so will result in a validation exception being raised. For further configuration options, consult the config reference documentation .","title":"Allowed Hosts"},{"location":"usage/7-middleware/3-builtin-middlewares/2-allowed-hosts-middleware/#allowed-hosts","text":"Another common security mechanism is to require that each incoming request has a \"Host\" or \"X-Forwarded-Host\" header, and then to restrict hosts to a specific set of domains - what's called \"allowed hosts\". Starlite includes an AllowedHostsMiddleware class that can be easily enabled by either passing an instance of AllowedHostsConfig or a list of domains to the Starlite constructor : from starlite import Starlite , AllowedHostsConfig app = Starlite ( route_handlers = [ ... ], allowed_hosts = AllowedHostsConfig ( allowed_hosts = [ \"*.example.com\" , \"www.wikipedia.org\" ] ), ) Note You can use wildcard prefixes ( *. ) in the beginning of a domain to match any combination of subdomains. Thus, *.example.com will match www.example.com but also x.y.z.example.com etc. You can also simply put * in trusted hosts, which means - allow all. This though is basically turning the middleware off, so it's better to simply not enable it to begin with in this case. You should note that a wildcard cannot be used only in the prefix of a domain name, not in the middle or end. Doing so will result in a validation exception being raised. For further configuration options, consult the config reference documentation .","title":"Allowed Hosts"},{"location":"usage/7-middleware/3-builtin-middlewares/3-csrf-middleware/","text":"CSRF CSRF ( Cross-site request forgery ) is a type of attack where unauthorized commands are submitted from a user that the web application trusts. This attack often uses social engineering that tricks the victim into clicking a URL that contains a maliciously crafted, unauthorized request for a particular Web application. The user\u2019s browser then sends this maliciously crafted request to the targeted Web application. If the user is in an active session with the Web application, the application treats this new request as an authorized request submitted by the user. Thus, the attacker can force the user to perform an action the user didn't intend, for example: POST /send-money HTTP/1.1 Host: target.web.app Content-Type: application/x-www-form-urlencoded amount=1000usd&to=attacker@evil.com This middleware prevents CSRF attacks by doing the following: On the first \"safe\" request (e.g GET ) - set a cookie with a special token created by the server On each subsequent \"unsafe\" request (e.g POST ) - make sure the request contains either a form field or an additional header that has this token To enable CSRF protection in a Starlite application simply pass an instance of CSRFConfig to the Starlite constructor : from starlite import Starlite , CSRFConfig csrf_config = CSRFConfig ( secret = \"my-secret\" ) app = Starlite ( route_handlers = [ ... ], csrf_config = csrf_config ) Some routes can be marked as being exempt from the protection offered by this middleware via handler opts from starlite import post @post ( \"/post\" , exclude_from_csrf = True ) def handler () -> None : ... If you need to exempt many routes at once you might want to consider using exclude kwarg which accepts list of path patterns to skip in the middleware. See the API Reference for full details on the CSRFConfig class and the kwargs it accepts.","title":"CSRF"},{"location":"usage/7-middleware/3-builtin-middlewares/3-csrf-middleware/#csrf","text":"CSRF ( Cross-site request forgery ) is a type of attack where unauthorized commands are submitted from a user that the web application trusts. This attack often uses social engineering that tricks the victim into clicking a URL that contains a maliciously crafted, unauthorized request for a particular Web application. The user\u2019s browser then sends this maliciously crafted request to the targeted Web application. If the user is in an active session with the Web application, the application treats this new request as an authorized request submitted by the user. Thus, the attacker can force the user to perform an action the user didn't intend, for example: POST /send-money HTTP/1.1 Host: target.web.app Content-Type: application/x-www-form-urlencoded amount=1000usd&to=attacker@evil.com This middleware prevents CSRF attacks by doing the following: On the first \"safe\" request (e.g GET ) - set a cookie with a special token created by the server On each subsequent \"unsafe\" request (e.g POST ) - make sure the request contains either a form field or an additional header that has this token To enable CSRF protection in a Starlite application simply pass an instance of CSRFConfig to the Starlite constructor : from starlite import Starlite , CSRFConfig csrf_config = CSRFConfig ( secret = \"my-secret\" ) app = Starlite ( route_handlers = [ ... ], csrf_config = csrf_config ) Some routes can be marked as being exempt from the protection offered by this middleware via handler opts from starlite import post @post ( \"/post\" , exclude_from_csrf = True ) def handler () -> None : ... If you need to exempt many routes at once you might want to consider using exclude kwarg which accepts list of path patterns to skip in the middleware. See the API Reference for full details on the CSRFConfig class and the kwargs it accepts.","title":"CSRF"},{"location":"usage/7-middleware/3-builtin-middlewares/4-compression-middleware/","text":"Compression HTML responses can optionally be compressed. Starlite has built in support for gzip and brotli. Gzip support is provided through the built-in Starlette classes, and brotli support can be added by installing the brotli extras. You can enable either backend by passing an instance of CompressionConfig into the compression_config the Starlite constructor . GZIP You can enable gzip compression of responses by passing an instance of starlite.config.CompressionConfig with the backend parameter set to \"gzip\" : You can configure the following additional gzip-specific values: minimum_size : the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is 500 , i.e. half a kilobyte. gzip_compress_level : a range between 0-9, see the official python docs . Defaults to 9 , which is the maximum value. from starlite import Starlite , CompressionConfig app = Starlite ( route_handlers = [ ... ], compression_config = CompressionConfig ( backend = \"gzip\" , gzip_compress_level = 9 ), ) Brotli The Brotli package is required to run this middleware. It is available as an extras to starlite with the brotli extra. ( pip install starlite[brotli] ) You can enable brotli compression of responses by passing an instance of starlite.config.CompressionConfig with the backend parameter set to \"brotli\" : You can configure the following additional brotli-specific values: minimum_size : the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is 500 , i.e. half a kilobyte. brotli_quality : Range [0-11], Controls the compression-speed vs compression-density tradeoff. The higher the quality, the slower the compression. brotli_mode : The compression mode can be MODE_GENERIC (default), MODE_TEXT (for UTF-8 format text input) or MODE_FONT (for WOFF 2.0). brotli_lgwin : Base 2 logarithm of size. Range is 10 to 24. Defaults to 22. brotli_lgblock : Base 2 logarithm of the maximum input block size. Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0. brotli_gzip_fallback : a boolean to indicate if gzip should be used if brotli is not supported. from starlite import Starlite from starlite.config import CompressionConfig app = Starlite ( route_handlers = [ ... ], compression_config = CompressionConfig ( backend = \"brotli\" , brotli_gzip_fallback = True ), )","title":"Compression"},{"location":"usage/7-middleware/3-builtin-middlewares/4-compression-middleware/#compression","text":"HTML responses can optionally be compressed. Starlite has built in support for gzip and brotli. Gzip support is provided through the built-in Starlette classes, and brotli support can be added by installing the brotli extras. You can enable either backend by passing an instance of CompressionConfig into the compression_config the Starlite constructor .","title":"Compression"},{"location":"usage/7-middleware/3-builtin-middlewares/4-compression-middleware/#gzip","text":"You can enable gzip compression of responses by passing an instance of starlite.config.CompressionConfig with the backend parameter set to \"gzip\" : You can configure the following additional gzip-specific values: minimum_size : the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is 500 , i.e. half a kilobyte. gzip_compress_level : a range between 0-9, see the official python docs . Defaults to 9 , which is the maximum value. from starlite import Starlite , CompressionConfig app = Starlite ( route_handlers = [ ... ], compression_config = CompressionConfig ( backend = \"gzip\" , gzip_compress_level = 9 ), )","title":"GZIP"},{"location":"usage/7-middleware/3-builtin-middlewares/4-compression-middleware/#brotli","text":"The Brotli package is required to run this middleware. It is available as an extras to starlite with the brotli extra. ( pip install starlite[brotli] ) You can enable brotli compression of responses by passing an instance of starlite.config.CompressionConfig with the backend parameter set to \"brotli\" : You can configure the following additional brotli-specific values: minimum_size : the minimum threshold for response size to enable compression. Smaller responses will not be compressed. Defaults is 500 , i.e. half a kilobyte. brotli_quality : Range [0-11], Controls the compression-speed vs compression-density tradeoff. The higher the quality, the slower the compression. brotli_mode : The compression mode can be MODE_GENERIC (default), MODE_TEXT (for UTF-8 format text input) or MODE_FONT (for WOFF 2.0). brotli_lgwin : Base 2 logarithm of size. Range is 10 to 24. Defaults to 22. brotli_lgblock : Base 2 logarithm of the maximum input block size. Range is 16 to 24. If set to 0, the value will be set based on the quality. Defaults to 0. brotli_gzip_fallback : a boolean to indicate if gzip should be used if brotli is not supported. from starlite import Starlite from starlite.config import CompressionConfig app = Starlite ( route_handlers = [ ... ], compression_config = CompressionConfig ( backend = \"brotli\" , brotli_gzip_fallback = True ), )","title":"Brotli"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/","text":"Session Middleware Starlite includes a SessionMiddleware , offering client- and server-side sessions. Different storage mechanisms are available through SessionBackends , and include support for storing data in: Cookies Files Redis Memcached (through aiomcache ) Databases (through sqlalchemy ) Memory Info The Starlite's SesionMiddleware is not based on the Starlette SessionMiddleware , although it is compatible with it, and it can act as a drop-in replacement. Setting up the middleware To start using sessions in your application all you have to do is create an instance of a configuration object and add its middleware to your application's middleware stack: Python 3.8+ Python 3.9+ Hello World from os import urandom from typing import Dict from starlite import Request , Starlite , delete , get , post from starlite.middleware.session.cookie_backend import CookieBackendConfig # we initialize to config with a 16 byte key, i.e. 128 a bit key. # in real world usage we should inject the secret from the environment session_config = CookieBackendConfig ( secret = urandom ( 16 )) # type: ignore[arg-type] @get ( \"/session\" ) def check_session_handler ( request : Request ) -> Dict [ str , bool ]: \"\"\"Handler function that accesses request.session.\"\"\" return { \"has_session\" : request . session != {}} @post ( \"/session\" ) def create_session_handler ( request : Request ) -> None : \"\"\"Handler to set the session.\"\"\" if not request . session : # value can be a dictionary or pydantic model request . set_session ({ \"username\" : \"moishezuchmir\" }) @delete ( \"/session\" ) def delete_session_handler ( request : Request ) -> None : \"\"\"Handler to clear the session.\"\"\" if request . session : request . clear_session () app = Starlite ( route_handlers = [ check_session_handler , create_session_handler , delete_session_handler ], middleware = [ session_config . middleware ], ) Hello World from os import urandom from starlite import Request , Starlite , delete , get , post from starlite.middleware.session.cookie_backend import CookieBackendConfig # we initialize to config with a 16 byte key, i.e. 128 a bit key. # in real world usage we should inject the secret from the environment session_config = CookieBackendConfig ( secret = urandom ( 16 )) # type: ignore[arg-type] @get ( \"/session\" ) def check_session_handler ( request : Request ) -> dict [ str , bool ]: \"\"\"Handler function that accesses request.session.\"\"\" return { \"has_session\" : request . session != {}} @post ( \"/session\" ) def create_session_handler ( request : Request ) -> None : \"\"\"Handler to set the session.\"\"\" if not request . session : # value can be a dictionary or pydantic model request . set_session ({ \"username\" : \"moishezuchmir\" }) @delete ( \"/session\" ) def delete_session_handler ( request : Request ) -> None : \"\"\"Handler to clear the session.\"\"\" if request . session : request . clear_session () app = Starlite ( route_handlers = [ check_session_handler , create_session_handler , delete_session_handler ], middleware = [ session_config . middleware ], ) Note Since both client- and server-side sessions rely on cookies (one for storing the actual session data, the other for storing the session ID), they share most of the cookie configuration. A complete reference of the cookie configuration can be found here: BaseBackendConfig Client-side sessions Client side sessions are available through the CookieBackend , which offers strong AES-CGM encryption security best practices while support cookie splitting. Important CookieBackend requires the cryptography library, which can be installed together with starlite as an extra using pip install starlite[cryptography] cookie_backend.py from os import urandom from starlite import Starlite from starlite.middleware.session.cookie_backend import CookieBackendConfig session_config = CookieBackendConfig ( secret = urandom ( 16 )) # type: ignore[arg-type] app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ]) See also CookieBackendConfig Server-side sessions Server side session store data - as the name suggests - on the server instead of the client. They use a cookie containing a session ID which is a randomly generated string to identify a client and load the appropriate data from the storage backend. File storage The FileBackend will store session data in files on disk, alongside some metadata. Files containing expired sessions will only be deleted when trying to access them. Expired session files can be manually deleted using the delete_expired method. file_backend.py from pathlib import Path from starlite import Starlite from starlite.middleware.session.file_backend import FileBackendConfig session_config = FileBackendConfig ( storage_path = Path ( \"/path/to/session/storage\" )) app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ]) See also Accessing the storage backend directly BaseBackendConfig ServerSideSessionConfig FileBackendConfig Redis storage The Redis backend can store session data in redis. Session data stored in redis will expire automatically after its max_age has been passed. Important This requires the redis package. To install it you can install starlite with pip install starlite[redis] redis_backend.py from redis.asyncio import Redis from starlite import Starlite from starlite.middleware.session.redis_backend import RedisBackendConfig session_config = RedisBackendConfig ( redis = Redis ( host = \"localhost\" , port = 6379 , db = 0 )) app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ]) See also Accessing the storage backend directly BaseBackendConfig ServerSideSessionConfig Memcached storage The Memcached backend can store session data in memcached. Session data stored in memcached will expire automatically after its max_age has been passed. Important This requires the aiomamcache package. To install it you can install starlite with pip install starlite[memcached] memcached_backend.py from aiomcache import Client from starlite import Starlite from starlite.middleware.session.memcached_backend import MemcachedBackendConfig session_config = MemcachedBackendConfig ( memcached = Client ( \"127.0.0.1\" )) app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ]) See also Accessing the storage backend directly BaseBackendConfig ServerSideSessionConfig In-memory storage The Memory backend can store session data in memory. Danger This should not be used in production. It primarily exists as a dummy backend for testing purposes. It is not process safe, and data will not be persisted. memory_backend.py from starlite import Starlite from starlite.middleware.session.memory_backend import MemoryBackendConfig session_config = MemoryBackendConfig () app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ]) Database storage Database storage is currently offered through the SQLAlchemyBackend . It supports both sync and async-engines and integrates with the SQLAlchemyPlugin . Expired sessions will only be deleted when trying to access them. They can be manually deleted using the delete_expired method. There are two backends for SQLAlchemy: SQLAlchemyBackend for synchronous engines AsyncSQLAlchemyBackend for asynchronous engines When using the configuration object, it will automatically pick the correct backend to use based on the engine configuration. Info This requires sqlalchemy . You can install it via pip install sqlalchemy . Synchronous engine Asynchronous engine sqlalchemy_backend.py from sqlalchemy.orm import declarative_base from starlite import Starlite from starlite.middleware.session.sqlalchemy_backend import ( SQLAlchemyBackendConfig , create_session_model , ) from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+pysqlite://\" , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) SessionModel = create_session_model ( Base ) session_config = SQLAlchemyBackendConfig ( plugin = sqlalchemy_plugin , model = SessionModel ) def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( sqlalchemy_config . engine ) # type: ignore app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ], plugins = [ sqlalchemy_plugin ], on_startup = [ on_startup ], ) sqlalchemy_backend.py from sqlalchemy.orm import declarative_base from starlite import Starlite from starlite.middleware.session.sqlalchemy_backend import ( SQLAlchemyBackendConfig , create_session_model , ) from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin Base = declarative_base () SessionModel = create_session_model ( Base ) sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite://\" ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) session_config = SQLAlchemyBackendConfig ( plugin = sqlalchemy_plugin , model = SessionModel , ) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" async with sqlalchemy_config . engine . begin () as conn : # type: ignore await conn . run_sync ( Base . metadata . create_all ) # pyright: ignore app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ], plugins = [ sqlalchemy_plugin ], on_startup = [ on_startup ] ) Supplying your own session model If you wish to extend the built-in session model, you can mixin the SessionModelMixin into your own classes: sqlalchemy_backend_custom_model.py from sqlalchemy import Column , Integer , String from sqlalchemy.orm import declarative_base from starlite import Starlite from starlite.middleware.session.sqlalchemy_backend import ( SessionModelMixin , SQLAlchemyBackendConfig , ) from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin Base = declarative_base () class SessionModel ( Base , SessionModelMixin ): # pyright: ignore [reportGeneralTypeIssues] __tablename__ = \"my-session-table\" id = Column ( Integer , primary_key = True ) additional_data = Column ( String ) sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite://\" ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) session_config = SQLAlchemyBackendConfig ( plugin = sqlalchemy_plugin , model = SessionModel , ) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" async with sqlalchemy_config . engine . begin () as conn : # type: ignore await conn . run_sync ( Base . metadata . create_all ) # pyright: ignore app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ], plugins = [ sqlalchemy_plugin ], on_startup = [ on_startup ] ) See also BaseBackendConfig ServerSideSessionConfig Accessing the storage backend directly In some situations you might want to access the storage backend directly, outside a request. For example to delete a specific session's data, or delete expired sessions from the database when using the SQLAlchemyBackend . from pathlib import Path from starlite import Starlite from starlite.middleware.session.file_backend import FileBackend , FileBackendConfig session_config = FileBackendConfig ( storage_path = Path ( \"/path/to/session/storage\" )) session_backend = FileBackend ( config = session_config ) async def clear_expired_sessions () -> None : \"\"\"Delete all expired sessions.\"\"\" await session_backend . delete_expired () app = Starlite ( route_handlers = [], middleware = [ session_backend . config . middleware ])","title":"Session Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#session-middleware","text":"Starlite includes a SessionMiddleware , offering client- and server-side sessions. Different storage mechanisms are available through SessionBackends , and include support for storing data in: Cookies Files Redis Memcached (through aiomcache ) Databases (through sqlalchemy ) Memory Info The Starlite's SesionMiddleware is not based on the Starlette SessionMiddleware , although it is compatible with it, and it can act as a drop-in replacement.","title":"Session Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#setting-up-the-middleware","text":"To start using sessions in your application all you have to do is create an instance of a configuration object and add its middleware to your application's middleware stack: Python 3.8+ Python 3.9+ Hello World from os import urandom from typing import Dict from starlite import Request , Starlite , delete , get , post from starlite.middleware.session.cookie_backend import CookieBackendConfig # we initialize to config with a 16 byte key, i.e. 128 a bit key. # in real world usage we should inject the secret from the environment session_config = CookieBackendConfig ( secret = urandom ( 16 )) # type: ignore[arg-type] @get ( \"/session\" ) def check_session_handler ( request : Request ) -> Dict [ str , bool ]: \"\"\"Handler function that accesses request.session.\"\"\" return { \"has_session\" : request . session != {}} @post ( \"/session\" ) def create_session_handler ( request : Request ) -> None : \"\"\"Handler to set the session.\"\"\" if not request . session : # value can be a dictionary or pydantic model request . set_session ({ \"username\" : \"moishezuchmir\" }) @delete ( \"/session\" ) def delete_session_handler ( request : Request ) -> None : \"\"\"Handler to clear the session.\"\"\" if request . session : request . clear_session () app = Starlite ( route_handlers = [ check_session_handler , create_session_handler , delete_session_handler ], middleware = [ session_config . middleware ], ) Hello World from os import urandom from starlite import Request , Starlite , delete , get , post from starlite.middleware.session.cookie_backend import CookieBackendConfig # we initialize to config with a 16 byte key, i.e. 128 a bit key. # in real world usage we should inject the secret from the environment session_config = CookieBackendConfig ( secret = urandom ( 16 )) # type: ignore[arg-type] @get ( \"/session\" ) def check_session_handler ( request : Request ) -> dict [ str , bool ]: \"\"\"Handler function that accesses request.session.\"\"\" return { \"has_session\" : request . session != {}} @post ( \"/session\" ) def create_session_handler ( request : Request ) -> None : \"\"\"Handler to set the session.\"\"\" if not request . session : # value can be a dictionary or pydantic model request . set_session ({ \"username\" : \"moishezuchmir\" }) @delete ( \"/session\" ) def delete_session_handler ( request : Request ) -> None : \"\"\"Handler to clear the session.\"\"\" if request . session : request . clear_session () app = Starlite ( route_handlers = [ check_session_handler , create_session_handler , delete_session_handler ], middleware = [ session_config . middleware ], ) Note Since both client- and server-side sessions rely on cookies (one for storing the actual session data, the other for storing the session ID), they share most of the cookie configuration. A complete reference of the cookie configuration can be found here: BaseBackendConfig","title":"Setting up the middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#client-side-sessions","text":"Client side sessions are available through the CookieBackend , which offers strong AES-CGM encryption security best practices while support cookie splitting. Important CookieBackend requires the cryptography library, which can be installed together with starlite as an extra using pip install starlite[cryptography] cookie_backend.py from os import urandom from starlite import Starlite from starlite.middleware.session.cookie_backend import CookieBackendConfig session_config = CookieBackendConfig ( secret = urandom ( 16 )) # type: ignore[arg-type] app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ]) See also CookieBackendConfig","title":"Client-side sessions"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#server-side-sessions","text":"Server side session store data - as the name suggests - on the server instead of the client. They use a cookie containing a session ID which is a randomly generated string to identify a client and load the appropriate data from the storage backend.","title":"Server-side sessions"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#file-storage","text":"The FileBackend will store session data in files on disk, alongside some metadata. Files containing expired sessions will only be deleted when trying to access them. Expired session files can be manually deleted using the delete_expired method. file_backend.py from pathlib import Path from starlite import Starlite from starlite.middleware.session.file_backend import FileBackendConfig session_config = FileBackendConfig ( storage_path = Path ( \"/path/to/session/storage\" )) app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ]) See also Accessing the storage backend directly BaseBackendConfig ServerSideSessionConfig FileBackendConfig","title":"File storage"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#redis-storage","text":"The Redis backend can store session data in redis. Session data stored in redis will expire automatically after its max_age has been passed. Important This requires the redis package. To install it you can install starlite with pip install starlite[redis] redis_backend.py from redis.asyncio import Redis from starlite import Starlite from starlite.middleware.session.redis_backend import RedisBackendConfig session_config = RedisBackendConfig ( redis = Redis ( host = \"localhost\" , port = 6379 , db = 0 )) app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ]) See also Accessing the storage backend directly BaseBackendConfig ServerSideSessionConfig","title":"Redis storage"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#memcached-storage","text":"The Memcached backend can store session data in memcached. Session data stored in memcached will expire automatically after its max_age has been passed. Important This requires the aiomamcache package. To install it you can install starlite with pip install starlite[memcached] memcached_backend.py from aiomcache import Client from starlite import Starlite from starlite.middleware.session.memcached_backend import MemcachedBackendConfig session_config = MemcachedBackendConfig ( memcached = Client ( \"127.0.0.1\" )) app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ]) See also Accessing the storage backend directly BaseBackendConfig ServerSideSessionConfig","title":"Memcached storage"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#in-memory-storage","text":"The Memory backend can store session data in memory. Danger This should not be used in production. It primarily exists as a dummy backend for testing purposes. It is not process safe, and data will not be persisted. memory_backend.py from starlite import Starlite from starlite.middleware.session.memory_backend import MemoryBackendConfig session_config = MemoryBackendConfig () app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ])","title":"In-memory storage"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#database-storage","text":"Database storage is currently offered through the SQLAlchemyBackend . It supports both sync and async-engines and integrates with the SQLAlchemyPlugin . Expired sessions will only be deleted when trying to access them. They can be manually deleted using the delete_expired method. There are two backends for SQLAlchemy: SQLAlchemyBackend for synchronous engines AsyncSQLAlchemyBackend for asynchronous engines When using the configuration object, it will automatically pick the correct backend to use based on the engine configuration. Info This requires sqlalchemy . You can install it via pip install sqlalchemy . Synchronous engine Asynchronous engine sqlalchemy_backend.py from sqlalchemy.orm import declarative_base from starlite import Starlite from starlite.middleware.session.sqlalchemy_backend import ( SQLAlchemyBackendConfig , create_session_model , ) from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin Base = declarative_base () sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+pysqlite://\" , use_async_engine = False ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) SessionModel = create_session_model ( Base ) session_config = SQLAlchemyBackendConfig ( plugin = sqlalchemy_plugin , model = SessionModel ) def on_startup () -> None : \"\"\"Initialize the database.\"\"\" Base . metadata . create_all ( sqlalchemy_config . engine ) # type: ignore app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ], plugins = [ sqlalchemy_plugin ], on_startup = [ on_startup ], ) sqlalchemy_backend.py from sqlalchemy.orm import declarative_base from starlite import Starlite from starlite.middleware.session.sqlalchemy_backend import ( SQLAlchemyBackendConfig , create_session_model , ) from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin Base = declarative_base () SessionModel = create_session_model ( Base ) sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite://\" ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) session_config = SQLAlchemyBackendConfig ( plugin = sqlalchemy_plugin , model = SessionModel , ) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" async with sqlalchemy_config . engine . begin () as conn : # type: ignore await conn . run_sync ( Base . metadata . create_all ) # pyright: ignore app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ], plugins = [ sqlalchemy_plugin ], on_startup = [ on_startup ] )","title":"Database storage"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#supplying-your-own-session-model","text":"If you wish to extend the built-in session model, you can mixin the SessionModelMixin into your own classes: sqlalchemy_backend_custom_model.py from sqlalchemy import Column , Integer , String from sqlalchemy.orm import declarative_base from starlite import Starlite from starlite.middleware.session.sqlalchemy_backend import ( SessionModelMixin , SQLAlchemyBackendConfig , ) from starlite.plugins.sql_alchemy import SQLAlchemyConfig , SQLAlchemyPlugin Base = declarative_base () class SessionModel ( Base , SessionModelMixin ): # pyright: ignore [reportGeneralTypeIssues] __tablename__ = \"my-session-table\" id = Column ( Integer , primary_key = True ) additional_data = Column ( String ) sqlalchemy_config = SQLAlchemyConfig ( connection_string = \"sqlite+aiosqlite://\" ) sqlalchemy_plugin = SQLAlchemyPlugin ( config = sqlalchemy_config ) session_config = SQLAlchemyBackendConfig ( plugin = sqlalchemy_plugin , model = SessionModel , ) async def on_startup () -> None : \"\"\"Initialize the database.\"\"\" async with sqlalchemy_config . engine . begin () as conn : # type: ignore await conn . run_sync ( Base . metadata . create_all ) # pyright: ignore app = Starlite ( route_handlers = [], middleware = [ session_config . middleware ], plugins = [ sqlalchemy_plugin ], on_startup = [ on_startup ] ) See also BaseBackendConfig ServerSideSessionConfig","title":"Supplying your own session model"},{"location":"usage/7-middleware/3-builtin-middlewares/5-session-middleware/#accessing-the-storage-backend-directly","text":"In some situations you might want to access the storage backend directly, outside a request. For example to delete a specific session's data, or delete expired sessions from the database when using the SQLAlchemyBackend . from pathlib import Path from starlite import Starlite from starlite.middleware.session.file_backend import FileBackend , FileBackendConfig session_config = FileBackendConfig ( storage_path = Path ( \"/path/to/session/storage\" )) session_backend = FileBackend ( config = session_config ) async def clear_expired_sessions () -> None : \"\"\"Delete all expired sessions.\"\"\" await session_backend . delete_expired () app = Starlite ( route_handlers = [], middleware = [ session_backend . config . middleware ])","title":"Accessing the storage backend directly"},{"location":"usage/7-middleware/3-builtin-middlewares/6-rate-limit-middleware/","text":"Rate-Limit Middleware Starlite includes an optional RateLimitMiddleware that follows the IETF RateLimit draft specification . To use the rate limit middleware, use the RateLimitConfig : from starlite import MediaType , Starlite , get from starlite.middleware import RateLimitConfig rate_limit_config = RateLimitConfig ( rate_limit = ( \"minute\" , 1 ), exclude = [ \"/schema\" ]) @get ( \"/\" , media_type = MediaType . TEXT ) def handler () -> str : \"\"\"Handler which should not be accessed more than once per minute.\"\"\" return \"ok\" app = Starlite ( route_handlers = [ handler ], middleware = [ rate_limit_config . middleware ]) The only required configuration kwarg is rate_limit , which expects a tuple containing a time-unit ( second , minute , hour , day ) and a value for the request quota (integer). For the other configuration options, see the additional configuration options in the reference .","title":"Rate-Limit Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/6-rate-limit-middleware/#rate-limit-middleware","text":"Starlite includes an optional RateLimitMiddleware that follows the IETF RateLimit draft specification . To use the rate limit middleware, use the RateLimitConfig : from starlite import MediaType , Starlite , get from starlite.middleware import RateLimitConfig rate_limit_config = RateLimitConfig ( rate_limit = ( \"minute\" , 1 ), exclude = [ \"/schema\" ]) @get ( \"/\" , media_type = MediaType . TEXT ) def handler () -> str : \"\"\"Handler which should not be accessed more than once per minute.\"\"\" return \"ok\" app = Starlite ( route_handlers = [ handler ], middleware = [ rate_limit_config . middleware ]) The only required configuration kwarg is rate_limit , which expects a tuple containing a time-unit ( second , minute , hour , day ) and a value for the request quota (integer). For the other configuration options, see the additional configuration options in the reference .","title":"Rate-Limit Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/7-logging-middleware/","text":"Logging Middleware Starlite ships with a robust logging middleware that allows logging HTTP request and responses while building on the app level logging configuration : from starlite import Starlite , LoggingConfig , get from starlite.middleware import LoggingMiddlewareConfig logging_middleware_config = LoggingMiddlewareConfig () @get ( \"/\" ) def my_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ my_handler ], logging_config = LoggingConfig (), middleware = [ logging_middleware_config . middleware ], ) The logging middleware uses the logger configuration defined on the application level, which allows for using both stdlib logging or structlog , depending on the configuration used ( see logging for more details). Obfuscating Logging Output Sometimes certain data, e.g. request or response headers, needs to be obfuscated. This is supported by the middleware configuration: from starlite.middleware import LoggingMiddlewareConfig logging_middleware_config = LoggingMiddlewareConfig ( request_cookies_to_obfuscate = { \"my-custom-session-key\" }, response_cookies_to_obfuscate = { \"my-custom-session-key\" }, request_headers_to_obfuscate = { \"my-custom-header\" }, response_headers_to_obfuscate = { \"my-custom-header\" }, ) The middleware will obfuscate the headers Authorization and X-API-KEY , and the cookie session by default. You can read more about the configuration options in the api reference Compression and Logging of Response Body If both CompressionConfig and LoggingMiddleware have been defined for the application, the response body will be omitted from response logging if it has been compressed, even if \"body\" has been included in response_log_fields . To force the body of compressed responses to be logged, set include_compressed_body to True , in addition to including \"body\" in response_log_fields .","title":"Logging Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/7-logging-middleware/#logging-middleware","text":"Starlite ships with a robust logging middleware that allows logging HTTP request and responses while building on the app level logging configuration : from starlite import Starlite , LoggingConfig , get from starlite.middleware import LoggingMiddlewareConfig logging_middleware_config = LoggingMiddlewareConfig () @get ( \"/\" ) def my_handler () -> dict [ str , str ]: return { \"hello\" : \"world\" } app = Starlite ( route_handlers = [ my_handler ], logging_config = LoggingConfig (), middleware = [ logging_middleware_config . middleware ], ) The logging middleware uses the logger configuration defined on the application level, which allows for using both stdlib logging or structlog , depending on the configuration used ( see logging for more details).","title":"Logging Middleware"},{"location":"usage/7-middleware/3-builtin-middlewares/7-logging-middleware/#obfuscating-logging-output","text":"Sometimes certain data, e.g. request or response headers, needs to be obfuscated. This is supported by the middleware configuration: from starlite.middleware import LoggingMiddlewareConfig logging_middleware_config = LoggingMiddlewareConfig ( request_cookies_to_obfuscate = { \"my-custom-session-key\" }, response_cookies_to_obfuscate = { \"my-custom-session-key\" }, request_headers_to_obfuscate = { \"my-custom-header\" }, response_headers_to_obfuscate = { \"my-custom-header\" }, ) The middleware will obfuscate the headers Authorization and X-API-KEY , and the cookie session by default. You can read more about the configuration options in the api reference","title":"Obfuscating Logging Output"},{"location":"usage/7-middleware/3-builtin-middlewares/7-logging-middleware/#compression-and-logging-of-response-body","text":"If both CompressionConfig and LoggingMiddleware have been defined for the application, the response body will be omitted from response logging if it has been compressed, even if \"body\" has been included in response_log_fields . To force the body of compressed responses to be logged, set include_compressed_body to True , in addition to including \"body\" in response_log_fields .","title":"Compression and Logging of Response Body"},{"location":"usage/8-security/0-intro/","text":"Security While Starlite is agnostic to the security scheme used - allowing users to use any standard and non-standard security scheme they deem necessary, it does include several builtin components that allow for easy implementation of authentication and authorization.","title":"Security"},{"location":"usage/8-security/0-intro/#security","text":"While Starlite is agnostic to the security scheme used - allowing users to use any standard and non-standard security scheme they deem necessary, it does include several builtin components that allow for easy implementation of authentication and authorization.","title":"Security"},{"location":"usage/8-security/1-abstract-authentication-middleware/","text":"AbstractAuthenticationMiddleware Starlite exports a class called AbstractAuthenticationMiddleware , which is an Abstract Base Class (ABC) that implements the middleware protocol . To add authentication to your app using this class as a basis, subclass it and implement the abstract method authenticate_request : from starlite import ( AbstractAuthenticationMiddleware , AuthenticationResult , ASGIConnection , ) class MyAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , connection : ASGIConnection ) -> AuthenticationResult : # do something here. ... As you can see, authenticate_request is an async function that receives a connection instance and is supposed to return an AuthenticationResult instance, which is a pydantic model that has two attributes: user : a non-optional value representing a user. It's typed as Any so it receives any value, including None . auth : an optional value representing the authentication scheme. Defaults to None . These values are then set as part of the \"scope\" dictionary, and they are made available as Request.user and Request.auth respectively, for HTTP route handlers, and WebSocket.user and WebSocket.auth for websocket route handlers. Example: Implementing a JWTAuthenticationMiddleware Since the above is quite hard to grasp in the abstract, lets see an example. We start off by creating a user model. It can be implemented using pydantic, and ODM, ORM etc. For the sake of the example here lets say it's a pydantic model: my_app/db/models.py import uuid from sqlalchemy import Column from sqlalchemy.dialects.postgresql import UUID from sqlalchemy.orm import declarative_base Base = declarative_base () class User ( Base ): id : uuid . UUID | None = Column ( UUID ( as_uuid = True ), default = uuid . uuid4 , primary_key = True ) # ... other fields follow, but we only require id for this example We will also need some utility methods to encode and decode tokens. To this end we will use the python-jose library. We will also create a pydantic model representing a JWT Token: my_app/security/jwt.py from datetime import datetime , timedelta from uuid import UUID from jose import JWTError , jwt from pydantic import BaseModel , UUID4 from starlite.exceptions import NotAuthorizedException from app.config import settings DEFAULT_TIME_DELTA = timedelta ( days = 1 ) ALGORITHM = \"HS256\" class Token ( BaseModel ): exp : datetime iat : datetime sub : UUID4 def decode_jwt_token ( encoded_token : str ) -> Token : \"\"\" Helper function that decodes a jwt token and returns the value stored under the 'sub' key If the token is invalid or expired (i.e. the value stored under the exp key is in the past) an exception is raised \"\"\" try : payload = jwt . decode ( token = encoded_token , key = settings . JWT_SECRET , algorithms = [ ALGORITHM ]) return Token ( ** payload ) except JWTError as e : raise NotAuthorizedException ( \"Invalid token\" ) from e def encode_jwt_token ( user_id : UUID , expiration : timedelta = DEFAULT_TIME_DELTA ) -> str : \"\"\"Helper function that encodes a JWT token with expiration and a given user_id\"\"\" token = Token ( exp = datetime . now () + expiration , iat = datetime . now (), sub = user_id , ) return jwt . encode ( token . dict (), settings . JWT_SECRET , algorithm = ALGORITHM ) We can now create our authentication middleware: my_app/security/authentication_middleware.py from typing import cast , TYPE_CHECKING from sqlalchemy import select from sqlalchemy.ext.asyncio import AsyncSession from starlite import ( AbstractAuthenticationMiddleware , AuthenticationResult , NotAuthorizedException , ASGIConnection , ) from app.db.models import User from app.security.jwt import decode_jwt_token if TYPE_CHECKING : from sqlalchemy.ext.asyncio import AsyncEngine API_KEY_HEADER = \"X-API-KEY\" class JWTAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , connection : ASGIConnection ) -> AuthenticationResult : \"\"\" Given a request, parse the request api key stored in the header and retrieve the user correlating to the token from the DB \"\"\" # retrieve the auth header auth_header = connection . headers . get ( API_KEY_HEADER ) if not auth_header : raise NotAuthorizedException () # decode the token, the result is a 'Token' model instance token = decode_jwt_token ( encoded_token = auth_header ) engine = cast ( \"AsyncEngine\" , connection . app . state . postgres_connection ) async with AsyncSession ( engine ) as async_session : async with async_session . begin (): user = await async_session . execute ( select ( User ) . where ( User . id == token . sub ) ) if not user : raise NotAuthorizedException () return AuthenticationResult ( user = user , auth = token ) Finally, we need to pass our middleware to the Starlite constructor: my_app/main.py from starlite import Starlite from starlite.middleware.base import DefineMiddleware from my_app.security.authentication_middleware import JWTAuthenticationMiddleware # you can optionally exclude certain paths from authentication. # the following excludes all routes mounted at or under `/schema*` auth_mw = DefineMiddleware ( JWTAuthenticationMiddleware , exclude = \"schema\" ) app = Starlite ( request_handlers = [ ... ], middleware = [ auth_mw ]) That's it. The JWTAuthenticationMiddleware will now run for every request, and we would be able to access these in a http route handler in the following way: from starlite import Request , get from my_app.db.models import User from my_app.security.jwt import Token @get ( \"/\" ) def my_route_handler ( request : Request [ User , Token ]) -> None : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) Or for a websocket route: from starlite import WebSocket , websocket from my_app.db.models import User from my_app.security.jwt import Token @websocket ( \"/\" ) async def my_route_handler ( socket : WebSocket [ User , Token ]) -> None : user = socket . user # correctly typed as User auth = socket . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) And if you'd like to exclude individual routes outside those configured: import anyio from starlite import Starlite , MediaType , NotFoundException , Response , get from starlite.middleware.base import DefineMiddleware from my_app.security.authentication_middleware import JWTAuthenticationMiddleware # you can optionally exclude certain paths from authentication. # the following excludes all routes mounted at or under `/schema*` # additionally, # you can modify the default exclude key of \"exclude_from_auth\", by overriding the `exclude_from_auth_key` parameter on the Authentication Middleware auth_mw = DefineMiddleware ( JWTAuthenticationMiddleware , exclude = \"schema\" ) @get ( path = \"/\" , exclude_from_auth = True ) async def site_index () -> Response : \"\"\"Site index\"\"\" exists = await anyio . Path ( \"index.html\" ) . exists () if exists : async with await anyio . open_file ( anyio . Path ( \"index.html\" )) as file : content = await file . read () return Response ( content = content , status_code = 200 , media_type = MediaType . HTML ) raise NotFoundException ( \"Site index was not found\" ) app = Starlite ( route_handlers = [ site_index ], middleware = [ auth_mw ]) And of course use the same kind of mechanism for dependencies: from typing import Any from starlite import Request , Provide , Router from my_app.db.models import User from my_app.security.jwt import Token async def my_dependency ( request : Request [ User , Token ]) -> Any : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) my_router = Router ( path = \"sub-path/\" , dependencies = { \"some_dependency\" : Provide ( my_dependency )} )","title":"AbstractAuthenticationMiddleware"},{"location":"usage/8-security/1-abstract-authentication-middleware/#abstractauthenticationmiddleware","text":"Starlite exports a class called AbstractAuthenticationMiddleware , which is an Abstract Base Class (ABC) that implements the middleware protocol . To add authentication to your app using this class as a basis, subclass it and implement the abstract method authenticate_request : from starlite import ( AbstractAuthenticationMiddleware , AuthenticationResult , ASGIConnection , ) class MyAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , connection : ASGIConnection ) -> AuthenticationResult : # do something here. ... As you can see, authenticate_request is an async function that receives a connection instance and is supposed to return an AuthenticationResult instance, which is a pydantic model that has two attributes: user : a non-optional value representing a user. It's typed as Any so it receives any value, including None . auth : an optional value representing the authentication scheme. Defaults to None . These values are then set as part of the \"scope\" dictionary, and they are made available as Request.user and Request.auth respectively, for HTTP route handlers, and WebSocket.user and WebSocket.auth for websocket route handlers.","title":"AbstractAuthenticationMiddleware"},{"location":"usage/8-security/1-abstract-authentication-middleware/#example-implementing-a-jwtauthenticationmiddleware","text":"Since the above is quite hard to grasp in the abstract, lets see an example. We start off by creating a user model. It can be implemented using pydantic, and ODM, ORM etc. For the sake of the example here lets say it's a pydantic model: my_app/db/models.py import uuid from sqlalchemy import Column from sqlalchemy.dialects.postgresql import UUID from sqlalchemy.orm import declarative_base Base = declarative_base () class User ( Base ): id : uuid . UUID | None = Column ( UUID ( as_uuid = True ), default = uuid . uuid4 , primary_key = True ) # ... other fields follow, but we only require id for this example We will also need some utility methods to encode and decode tokens. To this end we will use the python-jose library. We will also create a pydantic model representing a JWT Token: my_app/security/jwt.py from datetime import datetime , timedelta from uuid import UUID from jose import JWTError , jwt from pydantic import BaseModel , UUID4 from starlite.exceptions import NotAuthorizedException from app.config import settings DEFAULT_TIME_DELTA = timedelta ( days = 1 ) ALGORITHM = \"HS256\" class Token ( BaseModel ): exp : datetime iat : datetime sub : UUID4 def decode_jwt_token ( encoded_token : str ) -> Token : \"\"\" Helper function that decodes a jwt token and returns the value stored under the 'sub' key If the token is invalid or expired (i.e. the value stored under the exp key is in the past) an exception is raised \"\"\" try : payload = jwt . decode ( token = encoded_token , key = settings . JWT_SECRET , algorithms = [ ALGORITHM ]) return Token ( ** payload ) except JWTError as e : raise NotAuthorizedException ( \"Invalid token\" ) from e def encode_jwt_token ( user_id : UUID , expiration : timedelta = DEFAULT_TIME_DELTA ) -> str : \"\"\"Helper function that encodes a JWT token with expiration and a given user_id\"\"\" token = Token ( exp = datetime . now () + expiration , iat = datetime . now (), sub = user_id , ) return jwt . encode ( token . dict (), settings . JWT_SECRET , algorithm = ALGORITHM ) We can now create our authentication middleware: my_app/security/authentication_middleware.py from typing import cast , TYPE_CHECKING from sqlalchemy import select from sqlalchemy.ext.asyncio import AsyncSession from starlite import ( AbstractAuthenticationMiddleware , AuthenticationResult , NotAuthorizedException , ASGIConnection , ) from app.db.models import User from app.security.jwt import decode_jwt_token if TYPE_CHECKING : from sqlalchemy.ext.asyncio import AsyncEngine API_KEY_HEADER = \"X-API-KEY\" class JWTAuthenticationMiddleware ( AbstractAuthenticationMiddleware ): async def authenticate_request ( self , connection : ASGIConnection ) -> AuthenticationResult : \"\"\" Given a request, parse the request api key stored in the header and retrieve the user correlating to the token from the DB \"\"\" # retrieve the auth header auth_header = connection . headers . get ( API_KEY_HEADER ) if not auth_header : raise NotAuthorizedException () # decode the token, the result is a 'Token' model instance token = decode_jwt_token ( encoded_token = auth_header ) engine = cast ( \"AsyncEngine\" , connection . app . state . postgres_connection ) async with AsyncSession ( engine ) as async_session : async with async_session . begin (): user = await async_session . execute ( select ( User ) . where ( User . id == token . sub ) ) if not user : raise NotAuthorizedException () return AuthenticationResult ( user = user , auth = token ) Finally, we need to pass our middleware to the Starlite constructor: my_app/main.py from starlite import Starlite from starlite.middleware.base import DefineMiddleware from my_app.security.authentication_middleware import JWTAuthenticationMiddleware # you can optionally exclude certain paths from authentication. # the following excludes all routes mounted at or under `/schema*` auth_mw = DefineMiddleware ( JWTAuthenticationMiddleware , exclude = \"schema\" ) app = Starlite ( request_handlers = [ ... ], middleware = [ auth_mw ]) That's it. The JWTAuthenticationMiddleware will now run for every request, and we would be able to access these in a http route handler in the following way: from starlite import Request , get from my_app.db.models import User from my_app.security.jwt import Token @get ( \"/\" ) def my_route_handler ( request : Request [ User , Token ]) -> None : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) Or for a websocket route: from starlite import WebSocket , websocket from my_app.db.models import User from my_app.security.jwt import Token @websocket ( \"/\" ) async def my_route_handler ( socket : WebSocket [ User , Token ]) -> None : user = socket . user # correctly typed as User auth = socket . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) And if you'd like to exclude individual routes outside those configured: import anyio from starlite import Starlite , MediaType , NotFoundException , Response , get from starlite.middleware.base import DefineMiddleware from my_app.security.authentication_middleware import JWTAuthenticationMiddleware # you can optionally exclude certain paths from authentication. # the following excludes all routes mounted at or under `/schema*` # additionally, # you can modify the default exclude key of \"exclude_from_auth\", by overriding the `exclude_from_auth_key` parameter on the Authentication Middleware auth_mw = DefineMiddleware ( JWTAuthenticationMiddleware , exclude = \"schema\" ) @get ( path = \"/\" , exclude_from_auth = True ) async def site_index () -> Response : \"\"\"Site index\"\"\" exists = await anyio . Path ( \"index.html\" ) . exists () if exists : async with await anyio . open_file ( anyio . Path ( \"index.html\" )) as file : content = await file . read () return Response ( content = content , status_code = 200 , media_type = MediaType . HTML ) raise NotFoundException ( \"Site index was not found\" ) app = Starlite ( route_handlers = [ site_index ], middleware = [ auth_mw ]) And of course use the same kind of mechanism for dependencies: from typing import Any from starlite import Request , Provide , Router from my_app.db.models import User from my_app.security.jwt import Token async def my_dependency ( request : Request [ User , Token ]) -> Any : user = request . user # correctly typed as User auth = request . auth # correctly typed as Token assert isinstance ( user , User ) assert isinstance ( auth , Token ) my_router = Router ( path = \"sub-path/\" , dependencies = { \"some_dependency\" : Provide ( my_dependency )} )","title":"Example: Implementing a JWTAuthenticationMiddleware"},{"location":"usage/8-security/2-security-backends/","text":"Security Backends AbstractSecurityConfig The package starlite.security includes an AbstractSecurityConfig class that serves as a basis for all the security backends offered by Starlite, and is also meant to be used as a basis for custom security backends created by users. You can read more about this class in the API References . Session Auth Backend Starlite offers a builtin session auth backend that can be used out of the box with any of the session backends supported by the Starlite session middleware. Python 3.8+ Python 3.9+ Python 3.10+ Using Session Auth from typing import Any , Dict , Literal , Optional from uuid import UUID , uuid4 from pydantic import BaseModel , EmailStr , SecretStr from starlite import ( ASGIConnection , NotAuthorizedException , OpenAPIConfig , Request , Starlite , get , post , ) from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.security.session_auth import SessionAuth # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, # a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # we also have pydantic types for two different # kinds of POST request bodies: one for creating # a user, e.g. \"sign-up\", and the other for logging # an existing user in. class UserCreatePayload ( BaseModel ): name : str email : EmailStr password : SecretStr class UserLoginPayload ( BaseModel ): email : EmailStr password : SecretStr # The SessionAuth class requires a handler callable # that takes the session dictionary, and returns the # 'User' instance correlating to it. # # The session dictionary itself is a value the user decides # upon. So for example, it might be a simple dictionary # that holds a user id, for example: { \"id\": \"abcd123\" } # # Note: The callable can be either sync or async - both will work. async def retrieve_user_handler ( session : Dict [ str , Any ], connection : ASGIConnection ) -> Optional [ User ]: # we retrieve the user instance based on session data value = await connection . cache . get ( session . get ( \"user_id\" , \"\" )) if value : return User ( ** value ) return None @post ( \"/login\" ) async def login ( data : UserLoginPayload , request : Request ) -> User : # we received log-in data via post. # our login handler should retrieve from persistence (a db etc.) # the user data and verify that the login details # are correct. If we are using passwords, we should check that # the password hashes match etc. We will simply assume that we # have done all of that we now have a user value: user_id = await request . cache . get ( data . email ) if not user_id : raise NotAuthorizedException user_data = await request . cache . get ( user_id ) # once verified we can create a session. # to do this we simply need to call the Starlite # 'Request.set_session' method, which accepts either dictionaries # or pydantic models. In our case, we can simply record a # simple dictionary with the user ID value: request . set_session ({ \"user_id\" : user_id }) # you can do whatever we want here. In this case, we will simply return the user data: return User ( ** user_data ) @post ( \"/signup\" ) async def signup ( data : UserCreatePayload , request : Request ) -> User : # this is similar to the login handler, except here we should # insert into persistence - after doing whatever extra # validation we might require. We will assume that this is done, # and we now have a user instance with an assigned ID value: user = User ( name = data . name , email = data . email , id = uuid4 ()) await request . cache . set ( data . email , str ( user . id )) await request . cache . set ( str ( user . id ), user . dict ()) # we are creating a session the same as we do in the # 'login_handler' above: request . set_session ({ \"user_id\" : str ( user . id )}) # and again, you can add whatever logic is required here, we # will simply return the user: return user # the endpoint below requires the user to be already authenticated # to be able to access it. @get ( \"/user\" ) def get_user ( request : Request [ User , dict [ Literal [ \"user_id\" ], str ]]) -> Any : # because this route requires authentication, we can access # `request.user`, which is the authenticated user returned # by the 'retrieve_user_handler' function we passed to SessionAuth. return request . user # We add the session security schema to the OpenAPI config. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) session_auth = SessionAuth [ User ]( retrieve_user_handler = retrieve_user_handler , # we must pass a config for a session backend. # all session backends are supported session_backend_config = MemoryBackendConfig (), # exclude any URLs that should not have authentication. # We exclude the documentation URLs, signup and login. exclude = [ \"/login\" , \"/signup\" , \"/schema\" ], ) # We initialize the app instance, passing to it the 'session_auth.on_app_init' and the 'openapi_config'. app = Starlite ( route_handlers = [ login , signup , get_user ], on_app_init = [ session_auth . on_app_init ], openapi_config = openapi_config , ) Using Session Auth from typing import Any , Literal , Optional from uuid import UUID , uuid4 from pydantic import BaseModel , EmailStr , SecretStr from starlite import ( ASGIConnection , NotAuthorizedException , OpenAPIConfig , Request , Starlite , get , post , ) from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.security.session_auth import SessionAuth # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, # a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # we also have pydantic types for two different # kinds of POST request bodies: one for creating # a user, e.g. \"sign-up\", and the other for logging # an existing user in. class UserCreatePayload ( BaseModel ): name : str email : EmailStr password : SecretStr class UserLoginPayload ( BaseModel ): email : EmailStr password : SecretStr # The SessionAuth class requires a handler callable # that takes the session dictionary, and returns the # 'User' instance correlating to it. # # The session dictionary itself is a value the user decides # upon. So for example, it might be a simple dictionary # that holds a user id, for example: { \"id\": \"abcd123\" } # # Note: The callable can be either sync or async - both will work. async def retrieve_user_handler ( session : dict [ str , Any ], connection : ASGIConnection ) -> Optional [ User ]: # we retrieve the user instance based on session data value = await connection . cache . get ( session . get ( \"user_id\" , \"\" )) if value : return User ( ** value ) return None @post ( \"/login\" ) async def login ( data : UserLoginPayload , request : Request ) -> User : # we received log-in data via post. # our login handler should retrieve from persistence (a db etc.) # the user data and verify that the login details # are correct. If we are using passwords, we should check that # the password hashes match etc. We will simply assume that we # have done all of that we now have a user value: user_id = await request . cache . get ( data . email ) if not user_id : raise NotAuthorizedException user_data = await request . cache . get ( user_id ) # once verified we can create a session. # to do this we simply need to call the Starlite # 'Request.set_session' method, which accepts either dictionaries # or pydantic models. In our case, we can simply record a # simple dictionary with the user ID value: request . set_session ({ \"user_id\" : user_id }) # you can do whatever we want here. In this case, we will simply return the user data: return User ( ** user_data ) @post ( \"/signup\" ) async def signup ( data : UserCreatePayload , request : Request ) -> User : # this is similar to the login handler, except here we should # insert into persistence - after doing whatever extra # validation we might require. We will assume that this is done, # and we now have a user instance with an assigned ID value: user = User ( name = data . name , email = data . email , id = uuid4 ()) await request . cache . set ( data . email , str ( user . id )) await request . cache . set ( str ( user . id ), user . dict ()) # we are creating a session the same as we do in the # 'login_handler' above: request . set_session ({ \"user_id\" : str ( user . id )}) # and again, you can add whatever logic is required here, we # will simply return the user: return user # the endpoint below requires the user to be already authenticated # to be able to access it. @get ( \"/user\" ) def get_user ( request : Request [ User , dict [ Literal [ \"user_id\" ], str ]]) -> Any : # because this route requires authentication, we can access # `request.user`, which is the authenticated user returned # by the 'retrieve_user_handler' function we passed to SessionAuth. return request . user # We add the session security schema to the OpenAPI config. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) session_auth = SessionAuth [ User ]( retrieve_user_handler = retrieve_user_handler , # we must pass a config for a session backend. # all session backends are supported session_backend_config = MemoryBackendConfig (), # exclude any URLs that should not have authentication. # We exclude the documentation URLs, signup and login. exclude = [ \"/login\" , \"/signup\" , \"/schema\" ], ) # We initialize the app instance, passing to it the 'session_auth.on_app_init' and the 'openapi_config'. app = Starlite ( route_handlers = [ login , signup , get_user ], on_app_init = [ session_auth . on_app_init ], openapi_config = openapi_config , ) Using Session Auth from typing import Any , Literal from uuid import UUID , uuid4 from pydantic import BaseModel , EmailStr , SecretStr from starlite import ( ASGIConnection , NotAuthorizedException , OpenAPIConfig , Request , Starlite , get , post , ) from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.security.session_auth import SessionAuth # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, # a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # we also have pydantic types for two different # kinds of POST request bodies: one for creating # a user, e.g. \"sign-up\", and the other for logging # an existing user in. class UserCreatePayload ( BaseModel ): name : str email : EmailStr password : SecretStr class UserLoginPayload ( BaseModel ): email : EmailStr password : SecretStr # The SessionAuth class requires a handler callable # that takes the session dictionary, and returns the # 'User' instance correlating to it. # # The session dictionary itself is a value the user decides # upon. So for example, it might be a simple dictionary # that holds a user id, for example: { \"id\": \"abcd123\" } # # Note: The callable can be either sync or async - both will work. async def retrieve_user_handler ( session : dict [ str , Any ], connection : ASGIConnection ) -> User | None : # we retrieve the user instance based on session data value = await connection . cache . get ( session . get ( \"user_id\" , \"\" )) if value : return User ( ** value ) return None @post ( \"/login\" ) async def login ( data : UserLoginPayload , request : Request ) -> User : # we received log-in data via post. # our login handler should retrieve from persistence (a db etc.) # the user data and verify that the login details # are correct. If we are using passwords, we should check that # the password hashes match etc. We will simply assume that we # have done all of that we now have a user value: user_id = await request . cache . get ( data . email ) if not user_id : raise NotAuthorizedException user_data = await request . cache . get ( user_id ) # once verified we can create a session. # to do this we simply need to call the Starlite # 'Request.set_session' method, which accepts either dictionaries # or pydantic models. In our case, we can simply record a # simple dictionary with the user ID value: request . set_session ({ \"user_id\" : user_id }) # you can do whatever we want here. In this case, we will simply return the user data: return User ( ** user_data ) @post ( \"/signup\" ) async def signup ( data : UserCreatePayload , request : Request ) -> User : # this is similar to the login handler, except here we should # insert into persistence - after doing whatever extra # validation we might require. We will assume that this is done, # and we now have a user instance with an assigned ID value: user = User ( name = data . name , email = data . email , id = uuid4 ()) await request . cache . set ( data . email , str ( user . id )) await request . cache . set ( str ( user . id ), user . dict ()) # we are creating a session the same as we do in the # 'login_handler' above: request . set_session ({ \"user_id\" : str ( user . id )}) # and again, you can add whatever logic is required here, we # will simply return the user: return user # the endpoint below requires the user to be already authenticated # to be able to access it. @get ( \"/user\" ) def get_user ( request : Request [ User , dict [ Literal [ \"user_id\" ], str ]]) -> Any : # because this route requires authentication, we can access # `request.user`, which is the authenticated user returned # by the 'retrieve_user_handler' function we passed to SessionAuth. return request . user # We add the session security schema to the OpenAPI config. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) session_auth = SessionAuth [ User ]( retrieve_user_handler = retrieve_user_handler , # we must pass a config for a session backend. # all session backends are supported session_backend_config = MemoryBackendConfig (), # exclude any URLs that should not have authentication. # We exclude the documentation URLs, signup and login. exclude = [ \"/login\" , \"/signup\" , \"/schema\" ], ) # We initialize the app instance, passing to it the 'session_auth.on_app_init' and the 'openapi_config'. app = Starlite ( route_handlers = [ login , signup , get_user ], on_app_init = [ session_auth . on_app_init ], openapi_config = openapi_config , ) JWT Auth Starlite also includes several JWT security backends under the contrib package, checkout the jwt contrib documentation for more details.","title":"Security Backends"},{"location":"usage/8-security/2-security-backends/#security-backends","text":"","title":"Security Backends"},{"location":"usage/8-security/2-security-backends/#abstractsecurityconfig","text":"The package starlite.security includes an AbstractSecurityConfig class that serves as a basis for all the security backends offered by Starlite, and is also meant to be used as a basis for custom security backends created by users. You can read more about this class in the API References .","title":"AbstractSecurityConfig"},{"location":"usage/8-security/2-security-backends/#session-auth-backend","text":"Starlite offers a builtin session auth backend that can be used out of the box with any of the session backends supported by the Starlite session middleware. Python 3.8+ Python 3.9+ Python 3.10+ Using Session Auth from typing import Any , Dict , Literal , Optional from uuid import UUID , uuid4 from pydantic import BaseModel , EmailStr , SecretStr from starlite import ( ASGIConnection , NotAuthorizedException , OpenAPIConfig , Request , Starlite , get , post , ) from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.security.session_auth import SessionAuth # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, # a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # we also have pydantic types for two different # kinds of POST request bodies: one for creating # a user, e.g. \"sign-up\", and the other for logging # an existing user in. class UserCreatePayload ( BaseModel ): name : str email : EmailStr password : SecretStr class UserLoginPayload ( BaseModel ): email : EmailStr password : SecretStr # The SessionAuth class requires a handler callable # that takes the session dictionary, and returns the # 'User' instance correlating to it. # # The session dictionary itself is a value the user decides # upon. So for example, it might be a simple dictionary # that holds a user id, for example: { \"id\": \"abcd123\" } # # Note: The callable can be either sync or async - both will work. async def retrieve_user_handler ( session : Dict [ str , Any ], connection : ASGIConnection ) -> Optional [ User ]: # we retrieve the user instance based on session data value = await connection . cache . get ( session . get ( \"user_id\" , \"\" )) if value : return User ( ** value ) return None @post ( \"/login\" ) async def login ( data : UserLoginPayload , request : Request ) -> User : # we received log-in data via post. # our login handler should retrieve from persistence (a db etc.) # the user data and verify that the login details # are correct. If we are using passwords, we should check that # the password hashes match etc. We will simply assume that we # have done all of that we now have a user value: user_id = await request . cache . get ( data . email ) if not user_id : raise NotAuthorizedException user_data = await request . cache . get ( user_id ) # once verified we can create a session. # to do this we simply need to call the Starlite # 'Request.set_session' method, which accepts either dictionaries # or pydantic models. In our case, we can simply record a # simple dictionary with the user ID value: request . set_session ({ \"user_id\" : user_id }) # you can do whatever we want here. In this case, we will simply return the user data: return User ( ** user_data ) @post ( \"/signup\" ) async def signup ( data : UserCreatePayload , request : Request ) -> User : # this is similar to the login handler, except here we should # insert into persistence - after doing whatever extra # validation we might require. We will assume that this is done, # and we now have a user instance with an assigned ID value: user = User ( name = data . name , email = data . email , id = uuid4 ()) await request . cache . set ( data . email , str ( user . id )) await request . cache . set ( str ( user . id ), user . dict ()) # we are creating a session the same as we do in the # 'login_handler' above: request . set_session ({ \"user_id\" : str ( user . id )}) # and again, you can add whatever logic is required here, we # will simply return the user: return user # the endpoint below requires the user to be already authenticated # to be able to access it. @get ( \"/user\" ) def get_user ( request : Request [ User , dict [ Literal [ \"user_id\" ], str ]]) -> Any : # because this route requires authentication, we can access # `request.user`, which is the authenticated user returned # by the 'retrieve_user_handler' function we passed to SessionAuth. return request . user # We add the session security schema to the OpenAPI config. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) session_auth = SessionAuth [ User ]( retrieve_user_handler = retrieve_user_handler , # we must pass a config for a session backend. # all session backends are supported session_backend_config = MemoryBackendConfig (), # exclude any URLs that should not have authentication. # We exclude the documentation URLs, signup and login. exclude = [ \"/login\" , \"/signup\" , \"/schema\" ], ) # We initialize the app instance, passing to it the 'session_auth.on_app_init' and the 'openapi_config'. app = Starlite ( route_handlers = [ login , signup , get_user ], on_app_init = [ session_auth . on_app_init ], openapi_config = openapi_config , ) Using Session Auth from typing import Any , Literal , Optional from uuid import UUID , uuid4 from pydantic import BaseModel , EmailStr , SecretStr from starlite import ( ASGIConnection , NotAuthorizedException , OpenAPIConfig , Request , Starlite , get , post , ) from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.security.session_auth import SessionAuth # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, # a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # we also have pydantic types for two different # kinds of POST request bodies: one for creating # a user, e.g. \"sign-up\", and the other for logging # an existing user in. class UserCreatePayload ( BaseModel ): name : str email : EmailStr password : SecretStr class UserLoginPayload ( BaseModel ): email : EmailStr password : SecretStr # The SessionAuth class requires a handler callable # that takes the session dictionary, and returns the # 'User' instance correlating to it. # # The session dictionary itself is a value the user decides # upon. So for example, it might be a simple dictionary # that holds a user id, for example: { \"id\": \"abcd123\" } # # Note: The callable can be either sync or async - both will work. async def retrieve_user_handler ( session : dict [ str , Any ], connection : ASGIConnection ) -> Optional [ User ]: # we retrieve the user instance based on session data value = await connection . cache . get ( session . get ( \"user_id\" , \"\" )) if value : return User ( ** value ) return None @post ( \"/login\" ) async def login ( data : UserLoginPayload , request : Request ) -> User : # we received log-in data via post. # our login handler should retrieve from persistence (a db etc.) # the user data and verify that the login details # are correct. If we are using passwords, we should check that # the password hashes match etc. We will simply assume that we # have done all of that we now have a user value: user_id = await request . cache . get ( data . email ) if not user_id : raise NotAuthorizedException user_data = await request . cache . get ( user_id ) # once verified we can create a session. # to do this we simply need to call the Starlite # 'Request.set_session' method, which accepts either dictionaries # or pydantic models. In our case, we can simply record a # simple dictionary with the user ID value: request . set_session ({ \"user_id\" : user_id }) # you can do whatever we want here. In this case, we will simply return the user data: return User ( ** user_data ) @post ( \"/signup\" ) async def signup ( data : UserCreatePayload , request : Request ) -> User : # this is similar to the login handler, except here we should # insert into persistence - after doing whatever extra # validation we might require. We will assume that this is done, # and we now have a user instance with an assigned ID value: user = User ( name = data . name , email = data . email , id = uuid4 ()) await request . cache . set ( data . email , str ( user . id )) await request . cache . set ( str ( user . id ), user . dict ()) # we are creating a session the same as we do in the # 'login_handler' above: request . set_session ({ \"user_id\" : str ( user . id )}) # and again, you can add whatever logic is required here, we # will simply return the user: return user # the endpoint below requires the user to be already authenticated # to be able to access it. @get ( \"/user\" ) def get_user ( request : Request [ User , dict [ Literal [ \"user_id\" ], str ]]) -> Any : # because this route requires authentication, we can access # `request.user`, which is the authenticated user returned # by the 'retrieve_user_handler' function we passed to SessionAuth. return request . user # We add the session security schema to the OpenAPI config. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) session_auth = SessionAuth [ User ]( retrieve_user_handler = retrieve_user_handler , # we must pass a config for a session backend. # all session backends are supported session_backend_config = MemoryBackendConfig (), # exclude any URLs that should not have authentication. # We exclude the documentation URLs, signup and login. exclude = [ \"/login\" , \"/signup\" , \"/schema\" ], ) # We initialize the app instance, passing to it the 'session_auth.on_app_init' and the 'openapi_config'. app = Starlite ( route_handlers = [ login , signup , get_user ], on_app_init = [ session_auth . on_app_init ], openapi_config = openapi_config , ) Using Session Auth from typing import Any , Literal from uuid import UUID , uuid4 from pydantic import BaseModel , EmailStr , SecretStr from starlite import ( ASGIConnection , NotAuthorizedException , OpenAPIConfig , Request , Starlite , get , post , ) from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.security.session_auth import SessionAuth # Let's assume we have a User model that is a pydantic model. # This though is not required - we need some sort of user class - # but it can be any arbitrary value, e.g. an SQLAlchemy model, # a representation of a MongoDB etc. class User ( BaseModel ): id : UUID name : str email : EmailStr # we also have pydantic types for two different # kinds of POST request bodies: one for creating # a user, e.g. \"sign-up\", and the other for logging # an existing user in. class UserCreatePayload ( BaseModel ): name : str email : EmailStr password : SecretStr class UserLoginPayload ( BaseModel ): email : EmailStr password : SecretStr # The SessionAuth class requires a handler callable # that takes the session dictionary, and returns the # 'User' instance correlating to it. # # The session dictionary itself is a value the user decides # upon. So for example, it might be a simple dictionary # that holds a user id, for example: { \"id\": \"abcd123\" } # # Note: The callable can be either sync or async - both will work. async def retrieve_user_handler ( session : dict [ str , Any ], connection : ASGIConnection ) -> User | None : # we retrieve the user instance based on session data value = await connection . cache . get ( session . get ( \"user_id\" , \"\" )) if value : return User ( ** value ) return None @post ( \"/login\" ) async def login ( data : UserLoginPayload , request : Request ) -> User : # we received log-in data via post. # our login handler should retrieve from persistence (a db etc.) # the user data and verify that the login details # are correct. If we are using passwords, we should check that # the password hashes match etc. We will simply assume that we # have done all of that we now have a user value: user_id = await request . cache . get ( data . email ) if not user_id : raise NotAuthorizedException user_data = await request . cache . get ( user_id ) # once verified we can create a session. # to do this we simply need to call the Starlite # 'Request.set_session' method, which accepts either dictionaries # or pydantic models. In our case, we can simply record a # simple dictionary with the user ID value: request . set_session ({ \"user_id\" : user_id }) # you can do whatever we want here. In this case, we will simply return the user data: return User ( ** user_data ) @post ( \"/signup\" ) async def signup ( data : UserCreatePayload , request : Request ) -> User : # this is similar to the login handler, except here we should # insert into persistence - after doing whatever extra # validation we might require. We will assume that this is done, # and we now have a user instance with an assigned ID value: user = User ( name = data . name , email = data . email , id = uuid4 ()) await request . cache . set ( data . email , str ( user . id )) await request . cache . set ( str ( user . id ), user . dict ()) # we are creating a session the same as we do in the # 'login_handler' above: request . set_session ({ \"user_id\" : str ( user . id )}) # and again, you can add whatever logic is required here, we # will simply return the user: return user # the endpoint below requires the user to be already authenticated # to be able to access it. @get ( \"/user\" ) def get_user ( request : Request [ User , dict [ Literal [ \"user_id\" ], str ]]) -> Any : # because this route requires authentication, we can access # `request.user`, which is the authenticated user returned # by the 'retrieve_user_handler' function we passed to SessionAuth. return request . user # We add the session security schema to the OpenAPI config. openapi_config = OpenAPIConfig ( title = \"My API\" , version = \"1.0.0\" , ) session_auth = SessionAuth [ User ]( retrieve_user_handler = retrieve_user_handler , # we must pass a config for a session backend. # all session backends are supported session_backend_config = MemoryBackendConfig (), # exclude any URLs that should not have authentication. # We exclude the documentation URLs, signup and login. exclude = [ \"/login\" , \"/signup\" , \"/schema\" ], ) # We initialize the app instance, passing to it the 'session_auth.on_app_init' and the 'openapi_config'. app = Starlite ( route_handlers = [ login , signup , get_user ], on_app_init = [ session_auth . on_app_init ], openapi_config = openapi_config , )","title":"Session Auth Backend"},{"location":"usage/8-security/2-security-backends/#jwt-auth","text":"Starlite also includes several JWT security backends under the contrib package, checkout the jwt contrib documentation for more details.","title":"JWT Auth"},{"location":"usage/8-security/3-guards/","text":"Guards Guards are callables that receive two arguments - connection , which is the ASGIConnection instance, and route_handler , which is a copy of the BaseRouteHandler . Their role is to authorize the request by verifying that the connection is allowed to reach the endpoint handler in question. If verification fails, the guard should raise an HTTPException, usually a NotAuthorizedException with a status_code of 401. To illustrate this we will implement a rudimentary role based authorization system in our Starlite app. As we have done for authentication , we will assume that we added some sort of persistence layer without actually specifying it in the example. We begin by creating an Enum with two roles - consumer and admin : from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" Our User model will now look like this: from pydantic import BaseModel , UUID4 from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN Given that the User model has a \"role\" property we can use it to authorize a request. Let's create a guard that only allows admin users to access certain route handlers and then add it to a route handler function: from starlite import ASGIConnection , BaseRouteHandler , NotAuthorizedException from pydantic import BaseModel , UUID4 from starlite import post from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN def admin_user_guard ( connection : ASGIConnection , _ : BaseRouteHandler ) -> None : if not connection . user . is_admin : raise NotAuthorizedException () @post ( path = \"/user\" , guards = [ admin_user_guard ]) def create_user ( data : User ) -> User : ... Thus, only an admin user would be able to send a post request to the create_user handler. Guard Scopes Guards can be declared on all levels of the app - the Starlite instance, routers, controllers and individual route handlers: from starlite import ASGIConnection , Controller , Router , Starlite , BaseRouteHandler def my_guard ( connection : ASGIConnection , handler : BaseRouteHandler ) -> None : ... # controller class UserController ( Controller ): path = \"/user\" guards = [ my_guard ] ... # router admin_router = Router ( path = \"admin\" , route_handlers = [ UserController ], guards = [ my_guard ]) # app app = Starlite ( route_handlers = [ admin_router ], guards = [ my_guard ]) The deciding factor on where to place a guard is on the kind of access restriction that are required: do only specific route handlers need to be restricted? An entire controller? All the paths under a specific router? Or the entire app? As you can see in the above examples - guards is a list. This means you can add multiple guards at every layer. Unlike dependencies , guards do not override each other but are rather cumulative . This means that you can define guards on different levels of your app, and they will combine. The Route Handler \"opt\" Key Occasionally there might be a need to set some values on the route handler itself - these can be permissions, or some other flag. This can be achieved with opts kwarg of route handler To illustrate this lets say we want to have an endpoint that is guarded by a \"secret\" token, to which end we create the following guard: from starlite import ASGIConnection , BaseRouteHandler , NotAuthorizedException , get from os import environ def secret_token_guard ( connection : ASGIConnection , route_handler : BaseRouteHandler ) -> None : if ( route_handler . opt . get ( \"secret\" ) and not connection . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ] ): raise NotAuthorizedException () @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ...","title":"Guards"},{"location":"usage/8-security/3-guards/#guards","text":"Guards are callables that receive two arguments - connection , which is the ASGIConnection instance, and route_handler , which is a copy of the BaseRouteHandler . Their role is to authorize the request by verifying that the connection is allowed to reach the endpoint handler in question. If verification fails, the guard should raise an HTTPException, usually a NotAuthorizedException with a status_code of 401. To illustrate this we will implement a rudimentary role based authorization system in our Starlite app. As we have done for authentication , we will assume that we added some sort of persistence layer without actually specifying it in the example. We begin by creating an Enum with two roles - consumer and admin : from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" Our User model will now look like this: from pydantic import BaseModel , UUID4 from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN Given that the User model has a \"role\" property we can use it to authorize a request. Let's create a guard that only allows admin users to access certain route handlers and then add it to a route handler function: from starlite import ASGIConnection , BaseRouteHandler , NotAuthorizedException from pydantic import BaseModel , UUID4 from starlite import post from enum import Enum class UserRole ( str , Enum ): CONSUMER = \"consumer\" ADMIN = \"admin\" class User ( BaseModel ): id : UUID4 role : UserRole @property def is_admin ( self ) -> bool : \"\"\"Determines whether the user is an admin user\"\"\" return self . role == UserRole . ADMIN def admin_user_guard ( connection : ASGIConnection , _ : BaseRouteHandler ) -> None : if not connection . user . is_admin : raise NotAuthorizedException () @post ( path = \"/user\" , guards = [ admin_user_guard ]) def create_user ( data : User ) -> User : ... Thus, only an admin user would be able to send a post request to the create_user handler.","title":"Guards"},{"location":"usage/8-security/3-guards/#guard-scopes","text":"Guards can be declared on all levels of the app - the Starlite instance, routers, controllers and individual route handlers: from starlite import ASGIConnection , Controller , Router , Starlite , BaseRouteHandler def my_guard ( connection : ASGIConnection , handler : BaseRouteHandler ) -> None : ... # controller class UserController ( Controller ): path = \"/user\" guards = [ my_guard ] ... # router admin_router = Router ( path = \"admin\" , route_handlers = [ UserController ], guards = [ my_guard ]) # app app = Starlite ( route_handlers = [ admin_router ], guards = [ my_guard ]) The deciding factor on where to place a guard is on the kind of access restriction that are required: do only specific route handlers need to be restricted? An entire controller? All the paths under a specific router? Or the entire app? As you can see in the above examples - guards is a list. This means you can add multiple guards at every layer. Unlike dependencies , guards do not override each other but are rather cumulative . This means that you can define guards on different levels of your app, and they will combine.","title":"Guard Scopes"},{"location":"usage/8-security/3-guards/#the-route-handler-opt-key","text":"Occasionally there might be a need to set some values on the route handler itself - these can be permissions, or some other flag. This can be achieved with opts kwarg of route handler To illustrate this lets say we want to have an endpoint that is guarded by a \"secret\" token, to which end we create the following guard: from starlite import ASGIConnection , BaseRouteHandler , NotAuthorizedException , get from os import environ def secret_token_guard ( connection : ASGIConnection , route_handler : BaseRouteHandler ) -> None : if ( route_handler . opt . get ( \"secret\" ) and not connection . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ] ): raise NotAuthorizedException () @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ...","title":"The Route Handler \"opt\" Key"},{"location":"usage/9-testing/0-intro/","text":"Testing Testing is a first class citizen in Starlite, which offers several powerful testing utilities out of the box.","title":"Testing"},{"location":"usage/9-testing/0-intro/#testing","text":"Testing is a first class citizen in Starlite, which offers several powerful testing utilities out of the box.","title":"Testing"},{"location":"usage/9-testing/1-test-client/","text":"Test Client Starlite's test client is built on top of the httpx library. To use the test client you should pass to it an instance of Starlite as the app kwarg. Let's say we have a very simple app with a health check endpoint: my_app/main.py from starlite import Starlite , MediaType , get @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) We would then test it using the test client like so: tests/test_health_check.py from starlite.status_codes import HTTP_200_OK from starlite.testing import TestClient from my_app.main import app def test_health_check (): with TestClient ( app = app ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Since we would probably need to use the client in multiple places, it's better to make it into a pytest fixture: tests/conftest.py import pytest from starlite.testing import TestClient from my_app.main import app @pytest . fixture ( scope = \"function\" ) def test_client () -> TestClient : return TestClient ( app = app ) We would then be able to rewrite our test like so: tests/test_health_check.py from starlite.status_codes import HTTP_200_OK from starlite.testing import TestClient def test_health_check ( test_client : TestClient ): with test_client as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Using sessions If you are using Session Middleware for session persistence across requests, then you might want to inject or inspect session data outside a request. For this, TestClient provides two methods: set_session_data set_session_data Important The Session Middleware must be enabled in Starlite app provided to the TestClient to use sessions. If you are using the CookieBackend you need to install the cryptography package. You can do so by installing starlite with e.g. pip install starlite[cryptography] or poetry install starlite[cryptography] Python 3.8+ Python 3.9+ Setting session data from typing import Any , Dict from starlite import Request , Starlite , get from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.testing import TestClient session_config = MemoryBackendConfig () @get ( path = \"/test\" ) def get_session_data ( request : Request ) -> Dict [ str , Any ]: return request . session app = Starlite ( route_handlers = [ get_session_data ], middleware = [ session_config . middleware ]) with TestClient ( app = app , session_config = session_config ) as client : client . set_session_data ({ \"foo\" : \"bar\" }) assert client . get ( \"/test\" ) . json () == { \"foo\" : \"bar\" } Setting session data from typing import Any from starlite import Request , Starlite , get from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.testing import TestClient session_config = MemoryBackendConfig () @get ( path = \"/test\" ) def get_session_data ( request : Request ) -> dict [ str , Any ]: return request . session app = Starlite ( route_handlers = [ get_session_data ], middleware = [ session_config . middleware ]) with TestClient ( app = app , session_config = session_config ) as client : client . set_session_data ({ \"foo\" : \"bar\" }) assert client . get ( \"/test\" ) . json () == { \"foo\" : \"bar\" } Getting session data from starlite import Request , Starlite , post from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.testing import TestClient session_config = MemoryBackendConfig () @post ( path = \"/test\" ) def set_session_data ( request : Request ) -> None : request . session [ \"foo\" ] = \"bar\" app = Starlite ( route_handlers = [ set_session_data ], middleware = [ session_config . middleware ]) with TestClient ( app = app , session_config = session_config ) as client : client . post ( \"/test\" ) . json () assert client . get_session_data () == { \"foo\" : \"bar\" } Using a blocking portal The TestClient uses a feature of anyio called a Blocking Portal . The anyio.abc.BlockingPortal allows TestClient to execute asynchronous functions using a synchronous call. TestClient creates a blocking portal to manage Starlite 's async logic, and it allows TestClient 's API to remain fully synchronous. Any tests that are using an instance of TestClient can also make use of the blocking portal to execute asynchronous functions without the test itself being asynchronous. Using a blocking portal from concurrent.futures import Future , wait import anyio from starlite.testing import create_test_client def test_with_portal () -> None : \"\"\"This example shows how to manage asynchronous tasks using a portal. The test function itself is not async. Asynchronous functions are executed and awaited using the portal. \"\"\" async def get_float ( value : float ) -> float : await anyio . sleep ( value ) return value with create_test_client ( route_handlers = []) as test_client , test_client . portal () as portal : # start a background task with the portal future : Future [ float ] = portal . start_task_soon ( get_float , 0.25 ) # do other work assert portal . call ( get_float , 0.1 ) == 0.1 # wait for the background task to complete wait ([ future ]) assert future . done () assert future . result () == 0.25","title":"Test Client"},{"location":"usage/9-testing/1-test-client/#test-client","text":"Starlite's test client is built on top of the httpx library. To use the test client you should pass to it an instance of Starlite as the app kwarg. Let's say we have a very simple app with a health check endpoint: my_app/main.py from starlite import Starlite , MediaType , get @get ( path = \"/health-check\" , media_type = MediaType . TEXT ) def health_check () -> str : return \"healthy\" app = Starlite ( route_handlers = [ health_check ]) We would then test it using the test client like so: tests/test_health_check.py from starlite.status_codes import HTTP_200_OK from starlite.testing import TestClient from my_app.main import app def test_health_check (): with TestClient ( app = app ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" Since we would probably need to use the client in multiple places, it's better to make it into a pytest fixture: tests/conftest.py import pytest from starlite.testing import TestClient from my_app.main import app @pytest . fixture ( scope = \"function\" ) def test_client () -> TestClient : return TestClient ( app = app ) We would then be able to rewrite our test like so: tests/test_health_check.py from starlite.status_codes import HTTP_200_OK from starlite.testing import TestClient def test_health_check ( test_client : TestClient ): with test_client as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\"","title":"Test Client"},{"location":"usage/9-testing/1-test-client/#using-sessions","text":"If you are using Session Middleware for session persistence across requests, then you might want to inject or inspect session data outside a request. For this, TestClient provides two methods: set_session_data set_session_data Important The Session Middleware must be enabled in Starlite app provided to the TestClient to use sessions. If you are using the CookieBackend you need to install the cryptography package. You can do so by installing starlite with e.g. pip install starlite[cryptography] or poetry install starlite[cryptography] Python 3.8+ Python 3.9+ Setting session data from typing import Any , Dict from starlite import Request , Starlite , get from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.testing import TestClient session_config = MemoryBackendConfig () @get ( path = \"/test\" ) def get_session_data ( request : Request ) -> Dict [ str , Any ]: return request . session app = Starlite ( route_handlers = [ get_session_data ], middleware = [ session_config . middleware ]) with TestClient ( app = app , session_config = session_config ) as client : client . set_session_data ({ \"foo\" : \"bar\" }) assert client . get ( \"/test\" ) . json () == { \"foo\" : \"bar\" } Setting session data from typing import Any from starlite import Request , Starlite , get from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.testing import TestClient session_config = MemoryBackendConfig () @get ( path = \"/test\" ) def get_session_data ( request : Request ) -> dict [ str , Any ]: return request . session app = Starlite ( route_handlers = [ get_session_data ], middleware = [ session_config . middleware ]) with TestClient ( app = app , session_config = session_config ) as client : client . set_session_data ({ \"foo\" : \"bar\" }) assert client . get ( \"/test\" ) . json () == { \"foo\" : \"bar\" } Getting session data from starlite import Request , Starlite , post from starlite.middleware.session.memory_backend import MemoryBackendConfig from starlite.testing import TestClient session_config = MemoryBackendConfig () @post ( path = \"/test\" ) def set_session_data ( request : Request ) -> None : request . session [ \"foo\" ] = \"bar\" app = Starlite ( route_handlers = [ set_session_data ], middleware = [ session_config . middleware ]) with TestClient ( app = app , session_config = session_config ) as client : client . post ( \"/test\" ) . json () assert client . get_session_data () == { \"foo\" : \"bar\" }","title":"Using sessions"},{"location":"usage/9-testing/1-test-client/#using-a-blocking-portal","text":"The TestClient uses a feature of anyio called a Blocking Portal . The anyio.abc.BlockingPortal allows TestClient to execute asynchronous functions using a synchronous call. TestClient creates a blocking portal to manage Starlite 's async logic, and it allows TestClient 's API to remain fully synchronous. Any tests that are using an instance of TestClient can also make use of the blocking portal to execute asynchronous functions without the test itself being asynchronous. Using a blocking portal from concurrent.futures import Future , wait import anyio from starlite.testing import create_test_client def test_with_portal () -> None : \"\"\"This example shows how to manage asynchronous tasks using a portal. The test function itself is not async. Asynchronous functions are executed and awaited using the portal. \"\"\" async def get_float ( value : float ) -> float : await anyio . sleep ( value ) return value with create_test_client ( route_handlers = []) as test_client , test_client . portal () as portal : # start a background task with the portal future : Future [ float ] = portal . start_task_soon ( get_float , 0.25 ) # do other work assert portal . call ( get_float , 0.1 ) == 0.1 # wait for the background task to complete wait ([ future ]) assert future . done () assert future . result () == 0.25","title":"Using a blocking portal"},{"location":"usage/9-testing/2-create-test-app/","text":"Creating a Test App Starlite also offers a helper function called create_test_client which first creates an instance of Starlite and then a test client using it. There are multiple use cases for this helper - when you need to check generic logic that is decoupled from a specific Starlite app, or when you want to test endpoints in isolation. You can pass to this helper all the kwargs accepted by the starlite constructor , with the route_handlers kwarg being required . Yet unlike the Starlite app, which expects route_handlers to be a list, here you can also pass individual values. For example, you can do this: my_app/tests/test_health_check.py from starlite.status_codes import HTTP_200_OK from starlite.testing import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = [ health_check ]) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" But also this: my_app/tests/test_health_check.py from starlite.status_codes import HTTP_200_OK from starlite.testing import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = health_check ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\"","title":"Creating a Test App"},{"location":"usage/9-testing/2-create-test-app/#creating-a-test-app","text":"Starlite also offers a helper function called create_test_client which first creates an instance of Starlite and then a test client using it. There are multiple use cases for this helper - when you need to check generic logic that is decoupled from a specific Starlite app, or when you want to test endpoints in isolation. You can pass to this helper all the kwargs accepted by the starlite constructor , with the route_handlers kwarg being required . Yet unlike the Starlite app, which expects route_handlers to be a list, here you can also pass individual values. For example, you can do this: my_app/tests/test_health_check.py from starlite.status_codes import HTTP_200_OK from starlite.testing import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = [ health_check ]) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\" But also this: my_app/tests/test_health_check.py from starlite.status_codes import HTTP_200_OK from starlite.testing import create_test_client from my_app.main import health_check def test_health_check (): with create_test_client ( route_handlers = health_check ) as client : response = client . get ( \"/health-check\" ) assert response . status_code == HTTP_200_OK assert response . text == \"healthy\"","title":"Creating a Test App"},{"location":"usage/9-testing/3-request-factory/","text":"Request Factory Another helper is the RequestFactory class, which creates instances of starlite.connection.request.Request . The use case for this helper is when you need to test logic that expects to receive a request object. For example, lets say we wanted to unit test a guard function in isolation, to which end we'll reuse the examples from the route guards documentation: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request , route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We already have our route handler in place: my_app/secret.py from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ... We could thus test the guard function like so: tests/guards/test_secret_token_guard.py import pytest from starlite import NotAuthorizedException from starlite.testing import RequestFactory from my_app.guards import secret_token_guard from my_app.secret import secret_endpoint request = RequestFactory () . get ( \"/\" ) def test_secret_token_guard_failure_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = None with pytest . raises ( NotAuthorizedException ): secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) def test_secret_token_guard_success_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = \"super-secret\" secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) The RequestFactory constructor accepts the following parameters: app : An instance of the Starlite class. server : The server's domain. Defaults to test.org . port : The server's port. Defaults to 3000 . root_path : Root path for the server. Defaults to / . scheme : Scheme for the server. Defaults to \"http\" . It exposes methods for all supported HTTP methods: RequestFactory().get() RequestFactory().post() RequestFactory().put() RequestFactory().patch() RequestFactory().delete() All of these methods accept the following parameters: path : The request's path. This parameter is required . headers : A dictionary of headers. Defaults to None . cookies : A string representing the cookie header or a list of Cookie instances. This value can include multiple cookies. Defaults to None . session : A dictionary of session data. Defaults to None . user : A value for request.scope[\"user\"] . Defaults to None . auth : A value for request.scope[\"auth\"] . Defaults to None . state : Arbitrary request state. path_params : A string keyed dictionary of path parameter values. http_version : HTTP version. Defaults to \"1.1\". route_handler : A route handler instance or method. If not provided a default handler is set. In addition, the following methods accepts a few more parameters: RequestFactory().get() : query_params : A dictionary of values from which the request's query will be generated. Defaults to None . RequestFactory().post() , RequestFactory().put() , RequestFactory().patch() : request_media_type : The 'Content-Type' header of the request. Defaults to None . data : A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. Defaults to None .","title":"Request Factory"},{"location":"usage/9-testing/3-request-factory/#request-factory","text":"Another helper is the RequestFactory class, which creates instances of starlite.connection.request.Request . The use case for this helper is when you need to test logic that expects to receive a request object. For example, lets say we wanted to unit test a guard function in isolation, to which end we'll reuse the examples from the route guards documentation: my_app/guards.py from starlite import Request , RouteHandler , NotAuthorizedException def secret_token_guard ( request : Request , route_handler : RouteHandler ) -> None : if route_handler . opt . get ( \"secret\" ) and not request . headers . get ( \"Secret-Header\" , \"\" ) == route_handler . opt [ \"secret\" ]: raise NotAuthorizedException () We already have our route handler in place: my_app/secret.py from os import environ from starlite import get from my_app.guards import secret_token_guard @get ( path = \"/secret\" , guards = [ secret_token_guard ], opt = { \"secret\" : environ . get ( \"SECRET\" )}) def secret_endpoint () -> None : ... We could thus test the guard function like so: tests/guards/test_secret_token_guard.py import pytest from starlite import NotAuthorizedException from starlite.testing import RequestFactory from my_app.guards import secret_token_guard from my_app.secret import secret_endpoint request = RequestFactory () . get ( \"/\" ) def test_secret_token_guard_failure_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = None with pytest . raises ( NotAuthorizedException ): secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) def test_secret_token_guard_success_scenario (): copied_endpoint_handler = secret_endpoint . copy () copied_endpoint_handler . opt [ \"secret\" ] = \"super-secret\" secret_token_guard ( request = request , route_handler = copied_endpoint_handler ) The RequestFactory constructor accepts the following parameters: app : An instance of the Starlite class. server : The server's domain. Defaults to test.org . port : The server's port. Defaults to 3000 . root_path : Root path for the server. Defaults to / . scheme : Scheme for the server. Defaults to \"http\" . It exposes methods for all supported HTTP methods: RequestFactory().get() RequestFactory().post() RequestFactory().put() RequestFactory().patch() RequestFactory().delete() All of these methods accept the following parameters: path : The request's path. This parameter is required . headers : A dictionary of headers. Defaults to None . cookies : A string representing the cookie header or a list of Cookie instances. This value can include multiple cookies. Defaults to None . session : A dictionary of session data. Defaults to None . user : A value for request.scope[\"user\"] . Defaults to None . auth : A value for request.scope[\"auth\"] . Defaults to None . state : Arbitrary request state. path_params : A string keyed dictionary of path parameter values. http_version : HTTP version. Defaults to \"1.1\". route_handler : A route handler instance or method. If not provided a default handler is set. In addition, the following methods accepts a few more parameters: RequestFactory().get() : query_params : A dictionary of values from which the request's query will be generated. Defaults to None . RequestFactory().post() , RequestFactory().put() , RequestFactory().patch() : request_media_type : The 'Content-Type' header of the request. Defaults to None . data : A value for the request's body. Can be either a pydantic model instance or a string keyed dictionary. Defaults to None .","title":"Request Factory"},{"location":"usage/9-testing/4-pydantic-factories/","text":"Using pydantic-factories Pydantic-factories offers an easy and powerful way to generate mock data from pydantic models and dataclasses. Let's say we have an API that talks to an external service and retrieves some data: main.py from typing import Protocol , runtime_checkable from pydantic import BaseModel from starlite import get class Item ( BaseModel ): name : str @runtime_checkable class Service ( Protocol ): def get ( self ) -> Item : ... @get ( path = \"/item\" ) def get_item ( service : Service ) -> Item : return service . get () We could test the /item route like so: tests/conftest.py import pytest from starlite.status_codes import HTTP_200_OK from starlite import Provide , create_test_client from my_app.main import Service , Item , get_item @pytest . fixture () def item (): return Item ( name = \"Chair\" ) def test_get_item ( item : Item ): class MyService ( Service ): def get_one ( self ) -> Item : return item with create_test_client ( route_handlers = get_item , dependencies = { \"service\" : Provide ( lambda : MyService ())}) as client : response = client . get ( \"/item\" ) assert response . status_code == HTTP_200_OK assert response . json () == item . dict () While we can define the test data manually, as is done in the above, this can be quite cumbersome. That's where pydantic-factories library comes in. It generates mock data for pydantic models and dataclasses based on type annotations. With it, we could rewrite the above example like so: main.py from typing import Protocol , runtime_checkable import pytest from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite.status_codes import HTTP_200_OK from starlite import Provide , get from starlite.testing import create_test_client class Item ( BaseModel ): name : str @runtime_checkable class Service ( Protocol ): def get_one ( self ) -> Item : ... @get ( path = \"/item\" ) def get_item ( service : Service ) -> Item : return service . get_one () class ItemFactory ( ModelFactory [ Item ]): __model__ = Item @pytest . fixture () def item (): return ItemFactory . build () def test_get_item ( item : Item ): class MyService ( Service ): def get_one ( self ) -> Item : return item with create_test_client ( route_handlers = get_item , dependencies = { \"service\" : Provide ( lambda : MyService ())}) as client : response = client . get ( \"/item\" ) assert response . status_code == HTTP_200_OK assert response . json () == item . dict ()","title":"Using pydantic-factories"},{"location":"usage/9-testing/4-pydantic-factories/#using-pydantic-factories","text":"Pydantic-factories offers an easy and powerful way to generate mock data from pydantic models and dataclasses. Let's say we have an API that talks to an external service and retrieves some data: main.py from typing import Protocol , runtime_checkable from pydantic import BaseModel from starlite import get class Item ( BaseModel ): name : str @runtime_checkable class Service ( Protocol ): def get ( self ) -> Item : ... @get ( path = \"/item\" ) def get_item ( service : Service ) -> Item : return service . get () We could test the /item route like so: tests/conftest.py import pytest from starlite.status_codes import HTTP_200_OK from starlite import Provide , create_test_client from my_app.main import Service , Item , get_item @pytest . fixture () def item (): return Item ( name = \"Chair\" ) def test_get_item ( item : Item ): class MyService ( Service ): def get_one ( self ) -> Item : return item with create_test_client ( route_handlers = get_item , dependencies = { \"service\" : Provide ( lambda : MyService ())}) as client : response = client . get ( \"/item\" ) assert response . status_code == HTTP_200_OK assert response . json () == item . dict () While we can define the test data manually, as is done in the above, this can be quite cumbersome. That's where pydantic-factories library comes in. It generates mock data for pydantic models and dataclasses based on type annotations. With it, we could rewrite the above example like so: main.py from typing import Protocol , runtime_checkable import pytest from pydantic import BaseModel from pydantic_factories import ModelFactory from starlite.status_codes import HTTP_200_OK from starlite import Provide , get from starlite.testing import create_test_client class Item ( BaseModel ): name : str @runtime_checkable class Service ( Protocol ): def get_one ( self ) -> Item : ... @get ( path = \"/item\" ) def get_item ( service : Service ) -> Item : return service . get_one () class ItemFactory ( ModelFactory [ Item ]): __model__ = Item @pytest . fixture () def item (): return ItemFactory . build () def test_get_item ( item : Item ): class MyService ( Service ): def get_one ( self ) -> Item : return item with create_test_client ( route_handlers = get_item , dependencies = { \"service\" : Provide ( lambda : MyService ())}) as client : response = client . get ( \"/item\" ) assert response . status_code == HTTP_200_OK assert response . json () == item . dict ()","title":"Using pydantic-factories"}]}